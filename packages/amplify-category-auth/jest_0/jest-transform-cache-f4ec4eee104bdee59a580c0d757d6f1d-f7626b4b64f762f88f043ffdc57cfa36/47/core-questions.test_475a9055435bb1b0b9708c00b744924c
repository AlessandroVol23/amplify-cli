4cc23d04669b9325d7920bece9dae0ce
/* eslint-disable max-len */

const coreQuestions = require('../../provider-utils/awscloudformation/question-factories/core-questions');
const defaults = require('../../provider-utils/awscloudformation/assets/cognito-defaults');
const maps = require('../../provider-utils/awscloudformation/assets/string-maps');

const defaultFileName = 'cognito-defaults';
const stringMapFileName = 'string-maps';
const mockContext = {};
let mockAmplify = {};
const mappedOptions1 = [{ name: 'name1', value: 'value1' }];
const mappedOptions2 = [{ name: 'name1', value: 'value1' }];
const mappedOptions3 = [{ name: 'name1', value: 'value1' }, { name: 'name2', value: 'value2' }];
let currentAnswers = {};

describe('When generating auth questions...', () => {
  beforeEach(() => {
    mockAmplify = {
      getWhen: jest.fn(),
      inputValidation: jest.fn(),
      getAllDefaults: jest.fn(),
      getProjectDetails: jest.fn()
    };
    defaults.getAllDefaults = jest.fn();
    defaults.getAllDefaults.mockReturnValue({ Q1: 'default' });
    maps.getAllMaps = jest.fn();
    maps.getAllMaps.mockReturnValue({ mappedOptions1, mappedOptions2, mappedOptions3 });
    mockAmplify.getProjectDetails.mockReturnValue('testName');
    delete input.type;
    delete input.map;
    delete input.options;
  });
  afterEach(() => {
    delete mockContext.updatingAuth;
    currentAnswers = {};
  });

  const key = 'Q1';
  const question = 'What is your name?';

  const input = {
    key,
    question
  };

  describe('...and when generating simple inputs...', () => {
    it('it should return a question object when passed a simple input without getWhen conditions.', () => {
      const res = coreQuestions.parseInputs(input, mockAmplify, defaultFileName, stringMapFileName, currentAnswers, mockContext);
      expect(res).toBeInstanceOf(Object);
      expect(res.type).toEqual('input');
      expect(res.name).toEqual(key);
      expect(res.message).toEqual(question);
    });

    it('should try calling getWhen.', () => {
      coreQuestions.parseInputs(input, mockAmplify, defaultFileName, stringMapFileName, currentAnswers, mockContext);
      expect(mockAmplify.getWhen).toHaveBeenCalled();
    });

    it('should try calling inputValidation.', () => {
      coreQuestions.parseInputs(input, mockAmplify, defaultFileName, stringMapFileName, currentAnswers, mockContext);
      expect(mockAmplify.inputValidation).toHaveBeenCalled();
    });

    it('should try calling getAllDefaults if updatingAuth is not present in the context.', () => {
      const res = coreQuestions.parseInputs(input, mockAmplify, defaultFileName, stringMapFileName, currentAnswers, mockContext);
      res.default();
      expect(defaults.getAllDefaults).toHaveBeenCalled();
    });

    it('should not getAllDefaults if updatingAuth is present in the context.', () => {
      mockContext.updatingAuth = { Q1: 'my old answer' };
      const res = coreQuestions.parseInputs(input, mockAmplify, defaultFileName, stringMapFileName, currentAnswers, mockContext);
      res.default();
      expect(defaults.getAllDefaults).not.toHaveBeenCalled();
    });

    it('should return the answer from context.updatingAuth if updatingAuth is present.', () => {
      mockContext.updatingAuth = { Q1: 'my old answer' };
      const res = coreQuestions.parseInputs(input, mockAmplify, defaultFileName, stringMapFileName, currentAnswers, mockContext);
      const def = res.default();
      expect(def).toEqual('my old answer');
    });

    it('should return the choices from the input.options if getWhen is false', () => {
      mockAmplify.getWhen.mockReturnValue(() => false);
      input.type = 'list';
      input.requiredOptions = [{ key: 'required1' }];
      input.options = [{ key: 'testkey', val: 'testval' }];
      const res = coreQuestions.parseInputs(input, mockAmplify, defaultFileName, stringMapFileName, currentAnswers, mockContext);
      expect(res.choices).toEqual(input.options);
    });

    it('should return the choices from the input.options if getWhen is false', () => {
      mockAmplify.getWhen.mockReturnValue(() => true);
      input.type = 'list';
      input.requiredOptions = null;
      input.options = [{ key: 'testkey', val: 'testval' }];
      const res = coreQuestions.parseInputs(input, mockAmplify, defaultFileName, stringMapFileName, currentAnswers, mockContext);
      expect(res.choices).toEqual(input.options);
    });

    it('should render inputs of type "multiselect" as type "checkbox"', () => {
      input.type = 'multiselect';
      const res = coreQuestions.parseInputs(input, mockAmplify, defaultFileName, stringMapFileName, currentAnswers, mockContext);
      expect(res.type).toEqual('checkbox');
    });

    it('should render inputs of type "confirm" as type "confirm"', () => {
      input.type = 'confirm';
      const res = coreQuestions.parseInputs(input, mockAmplify, defaultFileName, stringMapFileName, currentAnswers, mockContext);
      expect(res.type).toEqual('confirm');
    });

    it('should render inputs of type "input" as type "input"', () => {
      input.type = 'input';
      const res = coreQuestions.parseInputs(input, mockAmplify, defaultFileName, stringMapFileName, currentAnswers, mockContext);
      expect(res.type).toEqual('input');
    });

    it('should render inputs without a type as type "input"', () => {
      input.type = undefined;
      const res = coreQuestions.parseInputs(input, mockAmplify, defaultFileName, stringMapFileName, currentAnswers, mockContext);
      expect(res.type).toEqual('input');
    });
  });

  describe('...and when generating complex inputs', () => {
    it('should get mapped option values for list inputs with map values when getWhen is false but requiredOptions are present', () => {
      mockAmplify.getWhen.mockReturnValue(() => false);
      input.requiredOptions = 'keyone';
      input.type = 'list';
      input.map = 'mappedOptions1';
      const res = coreQuestions.parseInputs(input, mockAmplify, defaultFileName, stringMapFileName, currentAnswers, mockContext);
      expect(res.choices).toEqual(mappedOptions1);
    });

    it('should get mapped option values for list inputs with map values when getWhen is true but requiredOptions are missing ', () => {
      mockAmplify.getWhen.mockReturnValue(() => true);
      input.requiredOptions = undefined;
      input.type = 'list';
      input.map = 'mappedOptions1';
      const res = coreQuestions.parseInputs(input, mockAmplify, defaultFileName, stringMapFileName, currentAnswers, mockContext);
      expect(res.choices).toEqual(mappedOptions1);
    });

    it('should get mapped option values for list inputs with map value when getWhen is false and requiredOptions are missing ', () => {
      mockAmplify.getWhen.mockReturnValue(() => false);
      input.requiredOptions = undefined;
      input.type = 'list';
      input.map = 'mappedOptions1';
      const res = coreQuestions.parseInputs(input, mockAmplify, defaultFileName, stringMapFileName, currentAnswers, mockContext);
      expect(res.choices).toEqual(mappedOptions1);
    });

    it('should add required options to the inputs answers using the filter method', () => {
      mockAmplify.getWhen.mockReturnValue(() => true);
      input.map = 'mappedOptions1';
      input.requiredOptions = 'mappedOptions2';
      currentAnswers.mappedOptions2 = 'valueone';
      input.type = 'list';
      const res = coreQuestions.parseInputs(input, mockAmplify, defaultFileName, stringMapFileName, currentAnswers, mockContext);
      expect(res.filter).toBeTruthy();
    });

    it('should remove required options from the choices presented to the user (currentAnswers variant)', () => {
      mockAmplify.getWhen.mockReturnValue(() => true);
      input.map = 'mappedOptions3';
      input.requiredOptions = 'mappedOptions2';
      currentAnswers.mappedOptions2 = 'value2';
      input.type = 'list';
      const res = coreQuestions.parseInputs(input, mockAmplify, defaultFileName, stringMapFileName, currentAnswers, mockContext);
      const requiredPresent = res.choices.filter(a => a.name === 'name2').length > 0;
      expect(requiredPresent).toBe(false);
    });

    it('should remove required options from the choices presented to the user (updatingAuth variant)', () => {
      mockAmplify.getWhen.mockReturnValue(() => true);
      input.map = 'mappedOptions3';
      input.requiredOptions = 'mappedOptions2';
      Object.assign(mockContext, { updatingAuth: { mappedOptions2: 'value2' } });
      input.type = 'list';
      const res = coreQuestions.parseInputs(input, mockAmplify, defaultFileName, stringMapFileName, currentAnswers, mockContext);
      const requiredPresent = res.choices.filter(a => a.name === 'name2').length > 0;
      expect(requiredPresent).toBe(false);
    });
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvcmUtcXVlc3Rpb25zLnRlc3QuanMiXSwibmFtZXMiOlsiY29yZVF1ZXN0aW9ucyIsInJlcXVpcmUiLCJkZWZhdWx0cyIsIm1hcHMiLCJkZWZhdWx0RmlsZU5hbWUiLCJzdHJpbmdNYXBGaWxlTmFtZSIsIm1vY2tDb250ZXh0IiwibW9ja0FtcGxpZnkiLCJtYXBwZWRPcHRpb25zMSIsIm5hbWUiLCJ2YWx1ZSIsIm1hcHBlZE9wdGlvbnMyIiwibWFwcGVkT3B0aW9uczMiLCJjdXJyZW50QW5zd2VycyIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImdldFdoZW4iLCJqZXN0IiwiZm4iLCJpbnB1dFZhbGlkYXRpb24iLCJnZXRBbGxEZWZhdWx0cyIsImdldFByb2plY3REZXRhaWxzIiwibW9ja1JldHVyblZhbHVlIiwiUTEiLCJnZXRBbGxNYXBzIiwiaW5wdXQiLCJ0eXBlIiwibWFwIiwib3B0aW9ucyIsImFmdGVyRWFjaCIsInVwZGF0aW5nQXV0aCIsImtleSIsInF1ZXN0aW9uIiwiaXQiLCJyZXMiLCJwYXJzZUlucHV0cyIsImV4cGVjdCIsInRvQmVJbnN0YW5jZU9mIiwiT2JqZWN0IiwidG9FcXVhbCIsIm1lc3NhZ2UiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwiZGVmYXVsdCIsIm5vdCIsImRlZiIsInJlcXVpcmVkT3B0aW9ucyIsInZhbCIsImNob2ljZXMiLCJ1bmRlZmluZWQiLCJmaWx0ZXIiLCJ0b0JlVHJ1dGh5IiwicmVxdWlyZWRQcmVzZW50IiwiYSIsImxlbmd0aCIsInRvQmUiLCJhc3NpZ24iXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLE1BQU1BLGdCQUFnQkMsUUFBUSwwRUFBUixDQUF0QjtBQUNBLE1BQU1DLFdBQVdELFFBQVEsZ0VBQVIsQ0FBakI7QUFDQSxNQUFNRSxPQUFPRixRQUFRLDJEQUFSLENBQWI7O0FBR0EsTUFBTUcsa0JBQWtCLGtCQUF4QjtBQUNBLE1BQU1DLG9CQUFvQixhQUExQjtBQUNBLE1BQU1DLGNBQWMsRUFBcEI7QUFDQSxJ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QUFjLEVBQUVuQixnQkFBZ0IsUUFBbEIsRUFBaEIsRUFBM0I7QUFDQWMsWUFBTUMsSUFBTixHQUFhLE1BQWI7QUFDQSxZQUFNUSxNQUFNbEMsY0FBY21DLFdBQWQsQ0FBMEJWLEtBQTFCLEVBQWlDbEIsV0FBakMsRUFBOENILGVBQTlDLEVBQStEQyxpQkFBL0QsRUFBa0ZRLGNBQWxGLEVBQWtHUCxXQUFsRyxDQUFaO0FBQ0EsWUFBTTZDLGtCQUFrQmpCLElBQUlhLE9BQUosQ0FBWUUsTUFBWixDQUFtQkcsS0FBS0EsRUFBRTNDLElBQUYsS0FBVyxPQUFuQyxFQUE0QzRDLE1BQTVDLEdBQXFELENBQTdFO0FBQ0FqQixhQUFPZSxlQUFQLEVBQXdCRyxJQUF4QixDQUE2QixLQUE3QjtBQUNELEtBVEQ7QUFVRCxHQTNERDtBQTRERCxDQTdLRCIsImZpbGUiOiJjb3JlLXF1ZXN0aW9ucy50ZXN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG5jb25zdCBjb3JlUXVlc3Rpb25zID0gcmVxdWlyZSgnLi4vLi4vcHJvdmlkZXItdXRpbHMvYXdzY2xvdWRmb3JtYXRpb24vcXVlc3Rpb24tZmFjdG9yaWVzL2NvcmUtcXVlc3Rpb25zJyk7XG5jb25zdCBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uLy4uL3Byb3ZpZGVyLXV0aWxzL2F3c2Nsb3VkZm9ybWF0aW9uL2Fzc2V0cy9jb2duaXRvLWRlZmF1bHRzJyk7XG5jb25zdCBtYXBzID0gcmVxdWlyZSgnLi4vLi4vcHJvdmlkZXItdXRpbHMvYXdzY2xvdWRmb3JtYXRpb24vYXNzZXRzL3N0cmluZy1tYXBzJyk7XG5cblxuY29uc3QgZGVmYXVsdEZpbGVOYW1lID0gJ2NvZ25pdG8tZGVmYXVsdHMnO1xuY29uc3Qgc3RyaW5nTWFwRmlsZU5hbWUgPSAnc3RyaW5nLW1hcHMnO1xuY29uc3QgbW9ja0NvbnRleHQgPSB7fTtcbmxldCBtb2NrQW1wbGlmeSA9IHt9O1xuY29uc3QgbWFwcGVkT3B0aW9uczEgPSBbeyBuYW1lOiAnbmFtZTEnLCB2YWx1ZTogJ3ZhbHVlMScgfV07XG5jb25zdCBtYXBwZWRPcHRpb25zMiA9IFt7IG5hbWU6ICduYW1lMScsIHZhbHVlOiAndmFsdWUxJyB9XTtcbmNvbnN0IG1hcHBlZE9wdGlvbnMzID0gW1xuICB7IG5hbWU6ICduYW1lMScsIHZhbHVlOiAndmFsdWUxJyB9LFxuICB7IG5hbWU6ICduYW1lMicsIHZhbHVlOiAndmFsdWUyJyB9LFxuXTtcbmxldCBjdXJyZW50QW5zd2VycyA9IHt9O1xuXG5kZXNjcmliZSgnV2hlbiBnZW5lcmF0aW5nIGF1dGggcXVlc3Rpb25zLi4uJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBtb2NrQW1wbGlmeSA9IHtcbiAgICAgIGdldFdoZW46IGplc3QuZm4oKSxcbiAgICAgIGlucHV0VmFsaWRhdGlvbjogamVzdC5mbigpLFxuICAgICAgZ2V0QWxsRGVmYXVsdHM6IGplc3QuZm4oKSxcbiAgICAgIGdldFByb2plY3REZXRhaWxzOiBqZXN0LmZuKCksXG4gICAgfTtcbiAgICBkZWZhdWx0cy5nZXRBbGxEZWZhdWx0cyA9IGplc3QuZm4oKTtcbiAgICBkZWZhdWx0cy5nZXRBbGxEZWZhdWx0cy5tb2NrUmV0dXJuVmFsdWUoeyBRMTogJ2RlZmF1bHQnIH0pO1xuICAgIG1hcHMuZ2V0QWxsTWFwcyA9IGplc3QuZm4oKTtcbiAgICBtYXBzLmdldEFsbE1hcHMubW9ja1JldHVyblZhbHVlKHsgbWFwcGVkT3B0aW9uczEsIG1hcHBlZE9wdGlvbnMyLCBtYXBwZWRPcHRpb25zMyB9KTtcbiAgICBtb2NrQW1wbGlmeS5nZXRQcm9qZWN0RGV0YWlscy5tb2NrUmV0dXJuVmFsdWUoJ3Rlc3ROYW1lJyk7XG4gICAgZGVsZXRlIGlucHV0LnR5cGU7XG4gICAgZGVsZXRlIGlucHV0Lm1hcDtcbiAgICBkZWxldGUgaW5wdXQub3B0aW9ucztcbiAgfSk7XG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgZGVsZXRlIG1vY2tDb250ZXh0LnVwZGF0aW5nQXV0aDtcbiAgICBjdXJyZW50QW5zd2VycyA9IHt9O1xuICB9KTtcblxuXG4gIGNvbnN0IGtleSA9ICdRMSc7XG4gIGNvbnN0IHF1ZXN0aW9uID0gJ1doYXQgaXMgeW91ciBuYW1lPyc7XG5cbiAgY29uc3QgaW5wdXQgPSB7XG4gICAga2V5LFxuICAgIHF1ZXN0aW9uLFxuICB9O1xuXG4gIGRlc2NyaWJlKCcuLi5hbmQgd2hlbiBnZW5lcmF0aW5nIHNpbXBsZSBpbnB1dHMuLi4nLCAoKSA9PiB7XG4gICAgaXQoJ2l0IHNob3VsZCByZXR1cm4gYSBxdWVzdGlvbiBvYmplY3Qgd2hlbiBwYXNzZWQgYSBzaW1wbGUgaW5wdXQgd2l0aG91dCBnZXRXaGVuIGNvbmRpdGlvbnMuJywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzID0gY29yZVF1ZXN0aW9ucy5wYXJzZUlucHV0cyhpbnB1dCwgbW9ja0FtcGxpZnksIGRlZmF1bHRGaWxlTmFtZSwgc3RyaW5nTWFwRmlsZU5hbWUsIGN1cnJlbnRBbnN3ZXJzLCBtb2NrQ29udGV4dCk7XG4gICAgICBleHBlY3QocmVzKS50b0JlSW5zdGFuY2VPZihPYmplY3QpO1xuICAgICAgZXhwZWN0KHJlcy50eXBlKS50b0VxdWFsKCdpbnB1dCcpO1xuICAgICAgZXhwZWN0KHJlcy5uYW1lKS50b0VxdWFsKGtleSk7XG4gICAgICBleHBlY3QocmVzLm1lc3NhZ2UpLnRvRXF1YWwocXVlc3Rpb24pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0cnkgY2FsbGluZyBnZXRXaGVuLicsICgpID0+IHtcbiAgICAgIGNvcmVRdWVzdGlvbnMucGFyc2VJbnB1dHMoaW5wdXQsIG1vY2tBbXBsaWZ5LCBkZWZhdWx0RmlsZU5hbWUsIHN0cmluZ01hcEZpbGVOYW1lLCBjdXJyZW50QW5zd2VycywgbW9ja0NvbnRleHQpO1xuICAgICAgZXhwZWN0KG1vY2tBbXBsaWZ5LmdldFdoZW4pLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdHJ5IGNhbGxpbmcgaW5wdXRWYWxpZGF0aW9uLicsICgpID0+IHtcbiAgICAgIGNvcmVRdWVzdGlvbnMucGFyc2VJbnB1dHMoaW5wdXQsIG1vY2tBbXBsaWZ5LCBkZWZhdWx0RmlsZU5hbWUsIHN0cmluZ01hcEZpbGVOYW1lLCBjdXJyZW50QW5zd2VycywgbW9ja0NvbnRleHQpO1xuICAgICAgZXhwZWN0KG1vY2tBbXBsaWZ5LmlucHV0VmFsaWRhdGlvbikudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0cnkgY2FsbGluZyBnZXRBbGxEZWZhdWx0cyBpZiB1cGRhdGluZ0F1dGggaXMgbm90IHByZXNlbnQgaW4gdGhlIGNvbnRleHQuJywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzID0gY29yZVF1ZXN0aW9ucy5wYXJzZUlucHV0cyhpbnB1dCwgbW9ja0FtcGxpZnksIGRlZmF1bHRGaWxlTmFtZSwgc3RyaW5nTWFwRmlsZU5hbWUsIGN1cnJlbnRBbnN3ZXJzLCBtb2NrQ29udGV4dCk7XG4gICAgICByZXMuZGVmYXVsdCgpO1xuICAgICAgZXhwZWN0KGRlZmF1bHRzLmdldEFsbERlZmF1bHRzKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIG5vdCBnZXRBbGxEZWZhdWx0cyBpZiB1cGRhdGluZ0F1dGggaXMgcHJlc2VudCBpbiB0aGUgY29udGV4dC4nLCAoKSA9PiB7XG4gICAgICBtb2NrQ29udGV4dC51cGRhdGluZ0F1dGggPSB7IFExOiAnbXkgb2xkIGFuc3dlcicgfTtcbiAgICAgIGNvbnN0IHJlcyA9IGNvcmVRdWVzdGlvbnMucGFyc2VJbnB1dHMoaW5wdXQsIG1vY2tBbXBsaWZ5LCBkZWZhdWx0RmlsZU5hbWUsIHN0cmluZ01hcEZpbGVOYW1lLCBjdXJyZW50QW5zd2VycywgbW9ja0NvbnRleHQpO1xuICAgICAgcmVzLmRlZmF1bHQoKTtcbiAgICAgIGV4cGVjdChkZWZhdWx0cy5nZXRBbGxEZWZhdWx0cykubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIHRoZSBhbnN3ZXIgZnJvbSBjb250ZXh0LnVwZGF0aW5nQXV0aCBpZiB1cGRhdGluZ0F1dGggaXMgcHJlc2VudC4nLCAoKSA9PiB7XG4gICAgICBtb2NrQ29udGV4dC51cGRhdGluZ0F1dGggPSB7IFExOiAnbXkgb2xkIGFuc3dlcicgfTtcbiAgICAgIGNvbnN0IHJlcyA9IGNvcmVRdWVzdGlvbnMucGFyc2VJbnB1dHMoaW5wdXQsIG1vY2tBbXBsaWZ5LCBkZWZhdWx0RmlsZU5hbWUsIHN0cmluZ01hcEZpbGVOYW1lLCBjdXJyZW50QW5zd2VycywgbW9ja0NvbnRleHQpO1xuICAgICAgY29uc3QgZGVmID0gcmVzLmRlZmF1bHQoKTtcbiAgICAgIGV4cGVjdChkZWYpLnRvRXF1YWwoJ215IG9sZCBhbnN3ZXInKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIHRoZSBjaG9pY2VzIGZyb20gdGhlIGlucHV0Lm9wdGlvbnMgaWYgZ2V0V2hlbiBpcyBmYWxzZScsICgpID0+IHtcbiAgICAgIG1vY2tBbXBsaWZ5LmdldFdoZW4ubW9ja1JldHVyblZhbHVlKCgpID0+IGZhbHNlKTtcbiAgICAgIGlucHV0LnR5cGUgPSAnbGlzdCc7XG4gICAgICBpbnB1dC5yZXF1aXJlZE9wdGlvbnMgPSBbeyBrZXk6ICdyZXF1aXJlZDEnIH1dO1xuICAgICAgaW5wdXQub3B0aW9ucyA9IFt7IGtleTogJ3Rlc3RrZXknLCB2YWw6ICd0ZXN0dmFsJyB9XTtcbiAgICAgIGNvbnN0IHJlcyA9IGNvcmVRdWVzdGlvbnMucGFyc2VJbnB1dHMoaW5wdXQsIG1vY2tBbXBsaWZ5LCBkZWZhdWx0RmlsZU5hbWUsIHN0cmluZ01hcEZpbGVOYW1lLCBjdXJyZW50QW5zd2VycywgbW9ja0NvbnRleHQpO1xuICAgICAgZXhwZWN0KHJlcy5jaG9pY2VzKS50b0VxdWFsKGlucHV0Lm9wdGlvbnMpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdGhlIGNob2ljZXMgZnJvbSB0aGUgaW5wdXQub3B0aW9ucyBpZiBnZXRXaGVuIGlzIGZhbHNlJywgKCkgPT4ge1xuICAgICAgbW9ja0FtcGxpZnkuZ2V0V2hlbi5tb2NrUmV0dXJuVmFsdWUoKCkgPT4gdHJ1ZSk7XG4gICAgICBpbnB1dC50eXBlID0gJ2xpc3QnO1xuICAgICAgaW5wdXQucmVxdWlyZWRPcHRpb25zID0gbnVsbDtcbiAgICAgIGlucHV0Lm9wdGlvbnMgPSBbeyBrZXk6ICd0ZXN0a2V5JywgdmFsOiAndGVzdHZhbCcgfV07XG4gICAgICBjb25zdCByZXMgPSBjb3JlUXVlc3Rpb25zLnBhcnNlSW5wdXRzKGlucHV0LCBtb2NrQW1wbGlmeSwgZGVmYXVsdEZpbGVOYW1lLCBzdHJpbmdNYXBGaWxlTmFtZSwgY3VycmVudEFuc3dlcnMsIG1vY2tDb250ZXh0KTtcbiAgICAgIGV4cGVjdChyZXMuY2hvaWNlcykudG9FcXVhbChpbnB1dC5vcHRpb25zKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVuZGVyIGlucHV0cyBvZiB0eXBlIFwibXVsdGlzZWxlY3RcIiBhcyB0eXBlIFwiY2hlY2tib3hcIicsICgpID0+IHtcbiAgICAgIGlucHV0LnR5cGUgPSAnbXVsdGlzZWxlY3QnO1xuICAgICAgY29uc3QgcmVzID0gY29yZVF1ZXN0aW9ucy5wYXJzZUlucHV0cyhpbnB1dCwgbW9ja0FtcGxpZnksIGRlZmF1bHRGaWxlTmFtZSwgc3RyaW5nTWFwRmlsZU5hbWUsIGN1cnJlbnRBbnN3ZXJzLCBtb2NrQ29udGV4dCk7XG4gICAgICBleHBlY3QocmVzLnR5cGUpLnRvRXF1YWwoJ2NoZWNrYm94Jyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlbmRlciBpbnB1dHMgb2YgdHlwZSBcImNvbmZpcm1cIiBhcyB0eXBlIFwiY29uZmlybVwiJywgKCkgPT4ge1xuICAgICAgaW5wdXQudHlwZSA9ICdjb25maXJtJztcbiAgICAgIGNvbnN0IHJlcyA9IGNvcmVRdWVzdGlvbnMucGFyc2VJbnB1dHMoaW5wdXQsIG1vY2tBbXBsaWZ5LCBkZWZhdWx0RmlsZU5hbWUsIHN0cmluZ01hcEZpbGVOYW1lLCBjdXJyZW50QW5zd2VycywgbW9ja0NvbnRleHQpO1xuICAgICAgZXhwZWN0KHJlcy50eXBlKS50b0VxdWFsKCdjb25maXJtJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlbmRlciBpbnB1dHMgb2YgdHlwZSBcImlucHV0XCIgYXMgdHlwZSBcImlucHV0XCInLCAoKSA9PiB7XG4gICAgICBpbnB1dC50eXBlID0gJ2lucHV0JztcbiAgICAgIGNvbnN0IHJlcyA9IGNvcmVRdWVzdGlvbnMucGFyc2VJbnB1dHMoaW5wdXQsIG1vY2tBbXBsaWZ5LCBkZWZhdWx0RmlsZU5hbWUsIHN0cmluZ01hcEZpbGVOYW1lLCBjdXJyZW50QW5zd2VycywgbW9ja0NvbnRleHQpO1xuICAgICAgZXhwZWN0KHJlcy50eXBlKS50b0VxdWFsKCdpbnB1dCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZW5kZXIgaW5wdXRzIHdpdGhvdXQgYSB0eXBlIGFzIHR5cGUgXCJpbnB1dFwiJywgKCkgPT4ge1xuICAgICAgaW5wdXQudHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IHJlcyA9IGNvcmVRdWVzdGlvbnMucGFyc2VJbnB1dHMoaW5wdXQsIG1vY2tBbXBsaWZ5LCBkZWZhdWx0RmlsZU5hbWUsIHN0cmluZ01hcEZpbGVOYW1lLCBjdXJyZW50QW5zd2VycywgbW9ja0NvbnRleHQpO1xuICAgICAgZXhwZWN0KHJlcy50eXBlKS50b0VxdWFsKCdpbnB1dCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnLi4uYW5kIHdoZW4gZ2VuZXJhdGluZyBjb21wbGV4IGlucHV0cycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGdldCBtYXBwZWQgb3B0aW9uIHZhbHVlcyBmb3IgbGlzdCBpbnB1dHMgd2l0aCBtYXAgdmFsdWVzIHdoZW4gZ2V0V2hlbiBpcyBmYWxzZSBidXQgcmVxdWlyZWRPcHRpb25zIGFyZSBwcmVzZW50JywgKCkgPT4ge1xuICAgICAgbW9ja0FtcGxpZnkuZ2V0V2hlbi5tb2NrUmV0dXJuVmFsdWUoKCkgPT4gZmFsc2UpO1xuICAgICAgaW5wdXQucmVxdWlyZWRPcHRpb25zID0gJ2tleW9uZSc7XG4gICAgICBpbnB1dC50eXBlID0gJ2xpc3QnO1xuICAgICAgaW5wdXQubWFwID0gJ21hcHBlZE9wdGlvbnMxJztcbiAgICAgIGNvbnN0IHJlcyA9IGNvcmVRdWVzdGlvbnMucGFyc2VJbnB1dHMoaW5wdXQsIG1vY2tBbXBsaWZ5LCBkZWZhdWx0RmlsZU5hbWUsIHN0cmluZ01hcEZpbGVOYW1lLCBjdXJyZW50QW5zd2VycywgbW9ja0NvbnRleHQpO1xuICAgICAgZXhwZWN0KHJlcy5jaG9pY2VzKS50b0VxdWFsKG1hcHBlZE9wdGlvbnMxKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZ2V0IG1hcHBlZCBvcHRpb24gdmFsdWVzIGZvciBsaXN0IGlucHV0cyB3aXRoIG1hcCB2YWx1ZXMgd2hlbiBnZXRXaGVuIGlzIHRydWUgYnV0IHJlcXVpcmVkT3B0aW9ucyBhcmUgbWlzc2luZyAnLCAoKSA9PiB7XG4gICAgICBtb2NrQW1wbGlmeS5nZXRXaGVuLm1vY2tSZXR1cm5WYWx1ZSgoKSA9PiB0cnVlKTtcbiAgICAgIGlucHV0LnJlcXVpcmVkT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgIGlucHV0LnR5cGUgPSAnbGlzdCc7XG4gICAgICBpbnB1dC5tYXAgPSAnbWFwcGVkT3B0aW9uczEnO1xuICAgICAgY29uc3QgcmVzID0gY29yZVF1ZXN0aW9ucy5wYXJzZUlucHV0cyhpbnB1dCwgbW9ja0FtcGxpZnksIGRlZmF1bHRGaWxlTmFtZSwgc3RyaW5nTWFwRmlsZU5hbWUsIGN1cnJlbnRBbnN3ZXJzLCBtb2NrQ29udGV4dCk7XG4gICAgICBleHBlY3QocmVzLmNob2ljZXMpLnRvRXF1YWwobWFwcGVkT3B0aW9uczEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBnZXQgbWFwcGVkIG9wdGlvbiB2YWx1ZXMgZm9yIGxpc3QgaW5wdXRzIHdpdGggbWFwIHZhbHVlIHdoZW4gZ2V0V2hlbiBpcyBmYWxzZSBhbmQgcmVxdWlyZWRPcHRpb25zIGFyZSBtaXNzaW5nICcsICgpID0+IHtcbiAgICAgIG1vY2tBbXBsaWZ5LmdldFdoZW4ubW9ja1JldHVyblZhbHVlKCgpID0+IGZhbHNlKTtcbiAgICAgIGlucHV0LnJlcXVpcmVkT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgIGlucHV0LnR5cGUgPSAnbGlzdCc7XG4gICAgICBpbnB1dC5tYXAgPSAnbWFwcGVkT3B0aW9uczEnO1xuICAgICAgY29uc3QgcmVzID0gY29yZVF1ZXN0aW9ucy5wYXJzZUlucHV0cyhpbnB1dCwgbW9ja0FtcGxpZnksIGRlZmF1bHRGaWxlTmFtZSwgc3RyaW5nTWFwRmlsZU5hbWUsIGN1cnJlbnRBbnN3ZXJzLCBtb2NrQ29udGV4dCk7XG4gICAgICBleHBlY3QocmVzLmNob2ljZXMpLnRvRXF1YWwobWFwcGVkT3B0aW9uczEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBhZGQgcmVxdWlyZWQgb3B0aW9ucyB0byB0aGUgaW5wdXRzIGFuc3dlcnMgdXNpbmcgdGhlIGZpbHRlciBtZXRob2QnLCAoKSA9PiB7XG4gICAgICBtb2NrQW1wbGlmeS5nZXRXaGVuLm1vY2tSZXR1cm5WYWx1ZSgoKSA9PiB0cnVlKTtcbiAgICAgIGlucHV0Lm1hcCA9ICdtYXBwZWRPcHRpb25zMSc7XG4gICAgICBpbnB1dC5yZXF1aXJlZE9wdGlvbnMgPSAnbWFwcGVkT3B0aW9uczInO1xuICAgICAgY3VycmVudEFuc3dlcnMubWFwcGVkT3B0aW9uczIgPSAndmFsdWVvbmUnO1xuICAgICAgaW5wdXQudHlwZSA9ICdsaXN0JztcbiAgICAgIGNvbnN0IHJlcyA9IGNvcmVRdWVzdGlvbnMucGFyc2VJbnB1dHMoaW5wdXQsIG1vY2tBbXBsaWZ5LCBkZWZhdWx0RmlsZU5hbWUsIHN0cmluZ01hcEZpbGVOYW1lLCBjdXJyZW50QW5zd2VycywgbW9ja0NvbnRleHQpO1xuICAgICAgZXhwZWN0KHJlcy5maWx0ZXIpLnRvQmVUcnV0aHkoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVtb3ZlIHJlcXVpcmVkIG9wdGlvbnMgZnJvbSB0aGUgY2hvaWNlcyBwcmVzZW50ZWQgdG8gdGhlIHVzZXIgKGN1cnJlbnRBbnN3ZXJzIHZhcmlhbnQpJywgKCkgPT4ge1xuICAgICAgbW9ja0FtcGxpZnkuZ2V0V2hlbi5tb2NrUmV0dXJuVmFsdWUoKCkgPT4gdHJ1ZSk7XG4gICAgICBpbnB1dC5tYXAgPSAnbWFwcGVkT3B0aW9uczMnO1xuICAgICAgaW5wdXQucmVxdWlyZWRPcHRpb25zID0gJ21hcHBlZE9wdGlvbnMyJztcbiAgICAgIGN1cnJlbnRBbnN3ZXJzLm1hcHBlZE9wdGlvbnMyID0gJ3ZhbHVlMic7XG4gICAgICBpbnB1dC50eXBlID0gJ2xpc3QnO1xuICAgICAgY29uc3QgcmVzID0gY29yZVF1ZXN0aW9ucy5wYXJzZUlucHV0cyhpbnB1dCwgbW9ja0FtcGxpZnksIGRlZmF1bHRGaWxlTmFtZSwgc3RyaW5nTWFwRmlsZU5hbWUsIGN1cnJlbnRBbnN3ZXJzLCBtb2NrQ29udGV4dCk7XG4gICAgICBjb25zdCByZXF1aXJlZFByZXNlbnQgPSByZXMuY2hvaWNlcy5maWx0ZXIoYSA9PiBhLm5hbWUgPT09ICduYW1lMicpLmxlbmd0aCA+IDA7XG4gICAgICBleHBlY3QocmVxdWlyZWRQcmVzZW50KS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVtb3ZlIHJlcXVpcmVkIG9wdGlvbnMgZnJvbSB0aGUgY2hvaWNlcyBwcmVzZW50ZWQgdG8gdGhlIHVzZXIgKHVwZGF0aW5nQXV0aCB2YXJpYW50KScsICgpID0+IHtcbiAgICAgIG1vY2tBbXBsaWZ5LmdldFdoZW4ubW9ja1JldHVyblZhbHVlKCgpID0+IHRydWUpO1xuICAgICAgaW5wdXQubWFwID0gJ21hcHBlZE9wdGlvbnMzJztcbiAgICAgIGlucHV0LnJlcXVpcmVkT3B0aW9ucyA9ICdtYXBwZWRPcHRpb25zMic7XG4gICAgICBPYmplY3QuYXNzaWduKG1vY2tDb250ZXh0LCB7IHVwZGF0aW5nQXV0aDogeyBtYXBwZWRPcHRpb25zMjogJ3ZhbHVlMicgfSB9KTtcbiAgICAgIGlucHV0LnR5cGUgPSAnbGlzdCc7XG4gICAgICBjb25zdCByZXMgPSBjb3JlUXVlc3Rpb25zLnBhcnNlSW5wdXRzKGlucHV0LCBtb2NrQW1wbGlmeSwgZGVmYXVsdEZpbGVOYW1lLCBzdHJpbmdNYXBGaWxlTmFtZSwgY3VycmVudEFuc3dlcnMsIG1vY2tDb250ZXh0KTtcbiAgICAgIGNvbnN0IHJlcXVpcmVkUHJlc2VudCA9IHJlcy5jaG9pY2VzLmZpbHRlcihhID0+IGEubmFtZSA9PT0gJ25hbWUyJykubGVuZ3RoID4gMDtcbiAgICAgIGV4cGVjdChyZXF1aXJlZFByZXNlbnQpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl19