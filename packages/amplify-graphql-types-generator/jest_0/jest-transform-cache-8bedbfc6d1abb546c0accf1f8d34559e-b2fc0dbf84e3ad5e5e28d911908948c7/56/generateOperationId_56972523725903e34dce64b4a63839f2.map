{"version":3,"sources":["generateOperationId.ts"],"names":[],"mappings":";;AACA,MAAA,+BAAA,QAAA,8BAAA,CAAA;AACA,MAAA,WAAA,QAAA,QAAA,CAAA;AAEA,SAAA,mBAAA,CACE,SADF,EAEE,SAFF,EAGE,mBAHF,EAGwC;AAEtC,QAAI,CAAC,mBAAL,EAA0B;AACxB,8BAAsB,6BAAA,0BAAA,CAA2B,UAAU,YAArC,EAAmD,SAAnD,CAAtB;AACD;AAED,UAAM,sBAAsB;AAC1B,cAAU,MADgB;AAE1B,OAAG,MAAM,IAAN,CAAW,mBAAX,EAAgC,GAAhC,CAAoC,gBAAe;AACpD,cAAM,WAAW,UAAU,YAAV,CAAjB;AACA,YAAI,CAAC,QAAL,EAAe;AACb,kBAAM,IAAI,KAAJ,CAAU,yBAAyB,YAAY,GAA/C,CAAN;AACD;AACD,eAAO,SAAS,MAAhB;AACD,KANE,CAFuB;AAS1B,QAT0B,CASrB,IATqB,CAA5B;AAWA,UAAM,OAAO,SAAA,UAAA,CAAW,QAAX,CAAb;AACA,SAAK,MAAL,CAAY,mBAAZ;AACA,UAAM,cAAc,KAAK,MAAL,CAAY,KAAZ,CAApB;AAEA,WAAO,EAAE,WAAF,EAAe,mBAAf,EAAP;AACD;AAzBD,QAAA,mBAAA,GAAA,mBAAA","sourcesContent":["import { Operation, Fragment } from '../';\nimport { collectFragmentsReferenced } from './collectFragmentsReferenced';\nimport { createHash } from 'crypto';\n\nexport function generateOperationId(\n  operation: Operation,\n  fragments: { [fragmentName: string]: Fragment },\n  fragmentsReferenced?: Iterable<string>\n) {\n  if (!fragmentsReferenced) {\n    fragmentsReferenced = collectFragmentsReferenced(operation.selectionSet, fragments);\n  }\n\n  const sourceWithFragments = [\n    operation.source,\n    ...Array.from(fragmentsReferenced).map(fragmentName => {\n      const fragment = fragments[fragmentName];\n      if (!fragment) {\n        throw new Error(`Cannot find fragment \"${fragmentName}\"`);\n      }\n      return fragment.source;\n    })\n  ].join('\\n');\n\n  const hash = createHash('sha256');\n  hash.update(sourceWithFragments);\n  const operationId = hash.digest('hex');\n\n  return { operationId, sourceWithFragments };\n}\n"],"sourceRoot":""}