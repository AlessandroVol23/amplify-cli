758310290022fb6df745c2c370d43e75
'use strict';require('ts-jest').install("/c/Users/Sandro/repo/amplify-cli/packages/amplify-graphql-types-generator/src/swift/helpers.ts", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst graphql_1 = require(\"graphql\");\nconst change_case_1 = require(\"change-case\");\nconst Inflector = require(\"inflected\");\nconst printing_1 = require(\"../utilities/printing\");\nconst graphql_2 = require(\"../utilities/graphql\");\nconst collectAndMergeFields_1 = require(\"../compiler/visitors/collectAndMergeFields\");\nconst aws_scalar_helper_1 = require(\"./aws-scalar-helper\");\nconst builtInScalarMap = {\n    [graphql_1.GraphQLString.name]: 'String',\n    [graphql_1.GraphQLInt.name]: 'Int',\n    [graphql_1.GraphQLFloat.name]: 'Double',\n    [graphql_1.GraphQLBoolean.name]: 'Bool',\n    [graphql_1.GraphQLID.name]: 'GraphQLID'\n};\nclass Helpers {\n    constructor(options) {\n        this.options = options;\n    }\n    typeNameFromGraphQLType(type, unmodifiedTypeName, isOptional) {\n        if (graphql_1.isNonNullType(type)) {\n            return this.typeNameFromGraphQLType(type.ofType, unmodifiedTypeName, false);\n        }\n        else if (isOptional === undefined) {\n            isOptional = true;\n        }\n        let typeName;\n        if (graphql_1.isListType(type)) {\n            typeName = '[' + this.typeNameFromGraphQLType(type.ofType, unmodifiedTypeName) + ']';\n        }\n        else if (type instanceof graphql_1.GraphQLScalarType) {\n            typeName = this.typeNameForScalarType(type);\n        }\n        else {\n            typeName = unmodifiedTypeName || type.name;\n        }\n        return isOptional ? typeName + '?' : typeName;\n    }\n    typeNameForScalarType(type) {\n        return (builtInScalarMap[type.name] ||\n            (this.options.passthroughCustomScalars\n                ? this.options.customScalarsPrefix + type.name\n                : aws_scalar_helper_1.getTypeForAWSScalar(type) ? aws_scalar_helper_1.getTypeForAWSScalar(type) : graphql_1.GraphQLString.name));\n    }\n    fieldTypeEnum(type, structName) {\n        if (graphql_1.isNonNullType(type)) {\n            return `.nonNull(${this.fieldTypeEnum(type.ofType, structName)})`;\n        }\n        else if (graphql_1.isListType(type)) {\n            return `.list(${this.fieldTypeEnum(type.ofType, structName)})`;\n        }\n        else if (type instanceof graphql_1.GraphQLScalarType) {\n            return `.scalar(${this.typeNameForScalarType(type)}.self)`;\n        }\n        else if (type instanceof graphql_1.GraphQLEnumType) {\n            return `.scalar(${type.name}.self)`;\n        }\n        else if (graphql_1.isCompositeType(type)) {\n            return `.object(${structName}.selections)`;\n        }\n        else {\n            throw new Error(`Unknown field type: ${type}`);\n        }\n    }\n    enumCaseName(name) {\n        return change_case_1.camelCase(name);\n    }\n    enumDotCaseName(name) {\n        return `.${change_case_1.camelCase(name)}`;\n    }\n    operationClassName(name) {\n        return change_case_1.pascalCase(name);\n    }\n    structNameForPropertyName(propertyName) {\n        return change_case_1.pascalCase(Inflector.singularize(propertyName));\n    }\n    structNameForFragmentName(fragmentName) {\n        return change_case_1.pascalCase(fragmentName);\n    }\n    structNameForVariant(variant) {\n        return 'As' + variant.possibleTypes.map(type => change_case_1.pascalCase(type.name)).join('Or');\n    }\n    propertyFromField(field, namespace) {\n        const { responseKey, isConditional } = field;\n        const propertyName = graphql_2.isMetaFieldName(responseKey) ? responseKey : change_case_1.camelCase(responseKey);\n        const structName = printing_1.join([namespace, this.structNameForPropertyName(responseKey)], '.');\n        let type = field.type;\n        if (isConditional && graphql_1.isNonNullType(type)) {\n            type = type.ofType;\n        }\n        const isOptional = !(type instanceof graphql_1.GraphQLNonNull);\n        const unmodifiedType = graphql_1.getNamedType(field.type);\n        const unmodifiedTypeName = graphql_1.isCompositeType(unmodifiedType) ? structName : unmodifiedType.name;\n        const typeName = this.typeNameFromGraphQLType(type, unmodifiedTypeName);\n        return Object.assign({}, field, {\n            responseKey,\n            propertyName,\n            typeName,\n            structName,\n            isOptional\n        });\n    }\n    propertyFromVariant(variant) {\n        const structName = this.structNameForVariant(variant);\n        return Object.assign(variant, {\n            propertyName: change_case_1.camelCase(structName),\n            typeName: structName + '?',\n            structName\n        });\n    }\n    propertyFromFragmentSpread(fragmentSpread, isConditional) {\n        const structName = this.structNameForFragmentName(fragmentSpread.fragmentName);\n        return Object.assign({}, fragmentSpread, {\n            propertyName: change_case_1.camelCase(fragmentSpread.fragmentName),\n            typeName: isConditional ? structName + '?' : structName,\n            structName,\n            isConditional\n        });\n    }\n    propertyFromInputField(field) {\n        return Object.assign({}, {\n            propertyName: change_case_1.camelCase(field.name),\n            typeName: this.typeNameFromGraphQLType(field.type),\n            isOptional: !(field.type instanceof graphql_1.GraphQLNonNull),\n            description: field.description || null,\n            name: field.name,\n        });\n    }\n    propertiesForSelectionSet(selectionSet, namespace) {\n        const properties = collectAndMergeFields_1.collectAndMergeFields(selectionSet, true)\n            .filter(field => field.name !== '__typename')\n            .map(field => this.propertyFromField(field, namespace));\n        if (selectionSet.selections.some(selection => selection.kind === 'FragmentSpread') &&\n            properties.some(property => graphql_1.isCompositeType(graphql_1.getNamedType(property.type)))) {\n            return undefined;\n        }\n        return properties;\n    }\n    dictionaryLiteralForFieldArguments(args) {\n        function expressionFromValue(value) {\n            if (value.kind === 'Variable') {\n                return `GraphQLVariable(\"${value.variableName}\")`;\n            }\n            else if (Array.isArray(value)) {\n                return printing_1.wrap('[', printing_1.join(value.map(expressionFromValue), ', '), ']');\n            }\n            else if (typeof value === 'object') {\n                return printing_1.wrap('[', printing_1.join(Object.entries(value).map(([key, value]) => {\n                    return `\"${key}\": ${expressionFromValue(value)}`;\n                }), ', ') || ':', ']');\n            }\n            else {\n                return JSON.stringify(value);\n            }\n        }\n        return printing_1.wrap('[', printing_1.join(args.map(arg => {\n            return `\"${arg.name}\": ${expressionFromValue(arg.value)}`;\n        }), ', ') || ':', ']');\n    }\n    mapExpressionForType(type, expression, identifier = '') {\n        let isOptional;\n        if (graphql_1.isNonNullType(type)) {\n            isOptional = false;\n            type = type.ofType;\n        }\n        else {\n            isOptional = true;\n        }\n        if (graphql_1.isListType(type)) {\n            if (isOptional) {\n                return `${identifier}.flatMap { $0.map { ${this.mapExpressionForType(type.ofType, expression, '$0')} } }`;\n            }\n            else {\n                return `${identifier}.map { ${this.mapExpressionForType(type.ofType, expression, '$0')} }`;\n            }\n        }\n        else if (isOptional) {\n            return `${identifier}.flatMap { ${expression('$0')} }`;\n        }\n        else {\n            return expression(identifier);\n        }\n    }\n}\nexports.Helpers = Helpers;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImhlbHBlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxxQ0FlaUI7QUFFakIsNkNBQW9EO0FBQ3BELHVDQUF1QztBQUN2QyxvREFBbUQ7QUFLbkQsa0RBQXVEO0FBRXZELHNGQUFtRjtBQUNuRiwyREFBMEQ7QUFFMUQsTUFBTSxnQkFBZ0IsR0FBRztJQUN2QixDQUFDLHVCQUFhLENBQUMsSUFBSSxDQUFDLEVBQUUsUUFBUTtJQUM5QixDQUFDLG9CQUFVLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSztJQUN4QixDQUFDLHNCQUFZLENBQUMsSUFBSSxDQUFDLEVBQUUsUUFBUTtJQUM3QixDQUFDLHdCQUFjLENBQUMsSUFBSSxDQUFDLEVBQUUsTUFBTTtJQUM3QixDQUFDLG1CQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsV0FBVztDQUM5QixDQUFDO0FBRUY7SUFDRSxZQUFtQixPQUF3QjtRQUF4QixZQUFPLEdBQVAsT0FBTyxDQUFpQjtJQUFHLENBQUM7SUFJL0MsdUJBQXVCLENBQUMsSUFBaUIsRUFBRSxrQkFBMkIsRUFBRSxVQUFvQjtRQUMxRixJQUFJLHVCQUFhLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDdkIsT0FBTyxJQUFJLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxrQkFBa0IsRUFBRSxLQUFLLENBQUMsQ0FBQztTQUM3RTthQUFNLElBQUksVUFBVSxLQUFLLFNBQVMsRUFBRTtZQUNuQyxVQUFVLEdBQUcsSUFBSSxDQUFDO1NBQ25CO1FBRUQsSUFBSSxRQUFRLENBQUM7UUFDYixJQUFJLG9CQUFVLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDcEIsUUFBUSxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxrQkFBa0IsQ0FBQyxHQUFHLEdBQUcsQ0FBQztTQUN0RjthQUFNLElBQUksSUFBSSxZQUFZ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bXBvcnQge1xuICBHcmFwaFFMVHlwZSxcbiAgR3JhcGhRTFN0cmluZyxcbiAgR3JhcGhRTEludCxcbiAgR3JhcGhRTEZsb2F0LFxuICBHcmFwaFFMQm9vbGVhbixcbiAgR3JhcGhRTElELFxuICBHcmFwaFFMTm9uTnVsbCxcbiAgR3JhcGhRTFNjYWxhclR5cGUsXG4gIEdyYXBoUUxFbnVtVHlwZSxcbiAgaXNDb21wb3NpdGVUeXBlLFxuICBnZXROYW1lZFR5cGUsXG4gIEdyYXBoUUxJbnB1dEZpZWxkLFxuICBpc05vbk51bGxUeXBlLFxuICBpc0xpc3RUeXBlXG59IGZyb20gJ2dyYXBocWwnO1xuXG5pbXBvcnQgeyBjYW1lbENhc2UsIHBhc2NhbENhc2UgfSBmcm9tICdjaGFuZ2UtY2FzZSc7XG5pbXBvcnQgKiBhcyBJbmZsZWN0b3IgZnJvbSAnaW5mbGVjdGVkJztcbmltcG9ydCB7IGpvaW4sIHdyYXAgfSBmcm9tICcuLi91dGlsaXRpZXMvcHJpbnRpbmcnO1xuXG5pbXBvcnQgeyBQcm9wZXJ0eSwgU3RydWN0IH0gZnJvbSAnLi9sYW5ndWFnZSc7XG5cbmltcG9ydCB7IENvbXBpbGVyT3B0aW9ucywgU2VsZWN0aW9uU2V0LCBGaWVsZCwgRnJhZ21lbnRTcHJlYWQsIEFyZ3VtZW50IH0gZnJvbSAnLi4vY29tcGlsZXInO1xuaW1wb3J0IHsgaXNNZXRhRmllbGROYW1lIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2dyYXBocWwnO1xuaW1wb3J0IHsgVmFyaWFudCB9IGZyb20gJy4uL2NvbXBpbGVyL3Zpc2l0b3JzL3R5cGVDYXNlJztcbmltcG9ydCB7IGNvbGxlY3RBbmRNZXJnZUZpZWxkcyB9IGZyb20gJy4uL2NvbXBpbGVyL3Zpc2l0b3JzL2NvbGxlY3RBbmRNZXJnZUZpZWxkcyc7XG5pbXBvcnQgeyBnZXRUeXBlRm9yQVdTU2NhbGFyIH0gZnJvbSAnLi9hd3Mtc2NhbGFyLWhlbHBlcic7XG5cbmNvbnN0IGJ1aWx0SW5TY2FsYXJNYXAgPSB7XG4gIFtHcmFwaFFMU3RyaW5nLm5hbWVdOiAnU3RyaW5nJyxcbiAgW0dyYXBoUUxJbnQubmFtZV06ICdJbnQnLFxuICBbR3JhcGhRTEZsb2F0Lm5hbWVdOiAnRG91YmxlJyxcbiAgW0dyYXBoUUxCb29sZWFuLm5hbWVdOiAnQm9vbCcsXG4gIFtHcmFwaFFMSUQubmFtZV06ICdHcmFwaFFMSUQnXG59O1xuXG5leHBvcnQgY2xhc3MgSGVscGVycyB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBvcHRpb25zOiBDb21waWxlck9wdGlvbnMpIHt9XG5cbiAgLy8gVHlwZXNcblxuICB0eXBlTmFtZUZyb21HcmFwaFFMVHlwZSh0eXBlOiBHcmFwaFFMVHlwZSwgdW5tb2RpZmllZFR5cGVOYW1lPzogc3RyaW5nLCBpc09wdGlvbmFsPzogYm9vbGVhbik6IHN0cmluZyB7XG4gICAgaWYgKGlzTm9uTnVsbFR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGVOYW1lRnJvbUdyYXBoUUxUeXBlKHR5cGUub2ZUeXBlLCB1bm1vZGlmaWVkVHlwZU5hbWUsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGlzT3B0aW9uYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaXNPcHRpb25hbCA9IHRydWU7XG4gICAgfVxuXG4gICAgbGV0IHR5cGVOYW1lO1xuICAgIGlmIChpc0xpc3RUeXBlKHR5cGUpKSB7XG4gICAgICB0eXBlTmFtZSA9ICdbJyArIHRoaXMudHlwZU5hbWVGcm9tR3JhcGhRTFR5cGUodHlwZS5vZlR5cGUsIHVubW9kaWZpZWRUeXBlTmFtZSkgKyAnXSc7XG4gICAgfSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgR3JhcGhRTFNjYWxhclR5cGUpIHtcbiAgICAgIHR5cGVOYW1lID0gdGhpcy50eXBlTmFtZUZvclNjYWxhclR5cGUodHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVOYW1lID0gdW5tb2RpZmllZFR5cGVOYW1lIHx8IHR5cGUubmFtZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNPcHRpb25hbCA/IHR5cGVOYW1lICsgJz8nIDogdHlwZU5hbWU7XG4gIH1cblxuICB0eXBlTmFtZUZvclNjYWxhclR5cGUodHlwZTogR3JhcGhRTFNjYWxhclR5cGUpOiBzdHJpbmcge1xuICAgIHJldHVybiAoXG4gICAgICBidWlsdEluU2NhbGFyTWFwW3R5cGUubmFtZV0gfHxcbiAgICAgICh0aGlzLm9wdGlvbnMucGFzc3Rocm91Z2hDdXN0b21TY2FsYXJzXG4gICAgICAgID8gdGhpcy5vcHRpb25zLmN1c3RvbVNjYWxhcnNQcmVmaXggKyB0eXBlLm5hbWVcbiAgICAgICAgOiBnZXRUeXBlRm9yQVdTU2NhbGFyKHR5cGUpID8gZ2V0VHlwZUZvckFXU1NjYWxhcih0eXBlKTogR3JhcGhRTFN0cmluZy5uYW1lKVxuICAgICk7XG4gIH1cblxuICBmaWVsZFR5cGVFbnVtKHR5cGU6IEdyYXBoUUxUeXBlLCBzdHJ1Y3ROYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmIChpc05vbk51bGxUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gYC5ub25OdWxsKCR7dGhpcy5maWVsZFR5cGVFbnVtKHR5cGUub2ZUeXBlLCBzdHJ1Y3ROYW1lKX0pYDtcbiAgICB9IGVsc2UgaWYgKGlzTGlzdFR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiBgLmxpc3QoJHt0aGlzLmZpZWxkVHlwZUVudW0odHlwZS5vZlR5cGUsIHN0cnVjdE5hbWUpfSlgO1xuICAgIH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIEdyYXBoUUxTY2FsYXJUeXBlKSB7XG4gICAgICByZXR1cm4gYC5zY2FsYXIoJHt0aGlzLnR5cGVOYW1lRm9yU2NhbGFyVHlwZSh0eXBlKX0uc2VsZilgO1xuICAgIH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIEdyYXBoUUxFbnVtVHlwZSkge1xuICAgICAgcmV0dXJuIGAuc2NhbGFyKCR7dHlwZS5uYW1lfS5zZWxmKWA7XG4gICAgfSBlbHNlIGlmIChpc0NvbXBvc2l0ZVR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiBgLm9iamVjdCgke3N0cnVjdE5hbWV9LnNlbGVjdGlvbnMpYDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGZpZWxkIHR5cGU6ICR7dHlwZX1gKTtcbiAgICB9XG4gIH1cblxuICAvLyBOYW1lc1xuXG4gIGVudW1DYXNlTmFtZShuYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gY2FtZWxDYXNlKG5hbWUpO1xuICB9XG5cbiAgZW51bURvdENhc2VOYW1lKG5hbWU6IHN0cmluZykge1xuICAgIHJldHVybiBgLiR7Y2FtZWxDYXNlKG5hbWUpfWA7XG4gIH1cblxuICBvcGVyYXRpb25DbGFzc05hbWUobmFtZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHBhc2NhbENhc2UobmFtZSk7XG4gIH1cblxuICBzdHJ1Y3ROYW1lRm9yUHJvcGVydHlOYW1lKHByb3BlcnR5TmFtZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHBhc2NhbENhc2UoSW5mbGVjdG9yLnNpbmd1bGFyaXplKHByb3BlcnR5TmFtZSkpO1xuICB9XG5cbiAgc3RydWN0TmFtZUZvckZyYWdtZW50TmFtZShmcmFnbWVudE5hbWU6IHN0cmluZykge1xuICAgIHJldHVybiBwYXNjYWxDYXNlKGZyYWdtZW50TmFtZSk7XG4gIH1cblxuICBzdHJ1Y3ROYW1lRm9yVmFyaWFudCh2YXJpYW50OiBTZWxlY3Rpb25TZXQpIHtcbiAgICByZXR1cm4gJ0FzJyArIHZhcmlhbnQucG9zc2libGVUeXBlcy5tYXAodHlwZSA9PiBwYXNjYWxDYXNlKHR5cGUubmFtZSkpLmpvaW4oJ09yJyk7XG4gIH1cblxuICAvLyBQcm9wZXJ0aWVzXG5cbiAgcHJvcGVydHlGcm9tRmllbGQoZmllbGQ6IEZpZWxkLCBuYW1lc3BhY2U/OiBzdHJpbmcpOiBGaWVsZCAmIFByb3BlcnR5ICYgU3RydWN0IHtcbiAgICBjb25zdCB7IHJlc3BvbnNlS2V5LCBpc0NvbmRpdGlvbmFsIH0gPSBmaWVsZDtcblxuICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IGlzTWV0YUZpZWxkTmFtZShyZXNwb25zZUtleSkgPyByZXNwb25zZUtleSA6IGNhbWVsQ2FzZShyZXNwb25zZUtleSk7XG5cbiAgICBjb25zdCBzdHJ1Y3ROYW1lID0gam9pbihbbmFtZXNwYWNlLCB0aGlzLnN0cnVjdE5hbWVGb3JQcm9wZXJ0eU5hbWUocmVzcG9uc2VLZXkpXSwgJy4nKTtcblxuICAgIGxldCB0eXBlID0gZmllbGQudHlwZTtcblxuICAgIGlmIChpc0NvbmRpdGlvbmFsICYmIGlzTm9uTnVsbFR5cGUodHlwZSkpIHtcbiAgICAgIHR5cGUgPSB0eXBlLm9mVHlwZTtcbiAgICB9XG5cbiAgICBjb25zdCBpc09wdGlvbmFsID0gISh0eXBlIGluc3RhbmNlb2YgR3JhcGhRTE5vbk51bGwpO1xuXG4gICAgY29uc3QgdW5tb2RpZmllZFR5cGUgPSBnZXROYW1lZFR5cGUoZmllbGQudHlwZSk7XG5cbiAgICBjb25zdCB1bm1vZGlmaWVkVHlwZU5hbWUgPSBpc0NvbXBvc2l0ZVR5cGUodW5tb2RpZmllZFR5cGUpID8gc3RydWN0TmFtZSA6IHVubW9kaWZpZWRUeXBlLm5hbWU7XG5cbiAgICBjb25zdCB0eXBlTmFtZSA9IHRoaXMudHlwZU5hbWVGcm9tR3JhcGhRTFR5cGUodHlwZSwgdW5tb2RpZmllZFR5cGVOYW1lKTtcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBmaWVsZCwge1xuICAgICAgcmVzcG9uc2VLZXksXG4gICAgICBwcm9wZXJ0eU5hbWUsXG4gICAgICB0eXBlTmFtZSxcbiAgICAgIHN0cnVjdE5hbWUsXG4gICAgICBpc09wdGlvbmFsXG4gICAgfSk7XG4gIH1cblxuICBwcm9wZXJ0eUZyb21WYXJpYW50KHZhcmlhbnQ6IFZhcmlhbnQpOiBWYXJpYW50ICYgUHJvcGVydHkgJiBTdHJ1Y3Qge1xuICAgIGNvbnN0IHN0cnVjdE5hbWUgPSB0aGlzLnN0cnVjdE5hbWVGb3JWYXJpYW50KHZhcmlhbnQpO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odmFyaWFudCwge1xuICAgICAgcHJvcGVydHlOYW1lOiBjYW1lbENhc2Uoc3RydWN0TmFtZSksXG4gICAgICB0eXBlTmFtZTogc3RydWN0TmFtZSArICc/JyxcbiAgICAgIHN0cnVjdE5hbWVcbiAgICB9KTtcbiAgfVxuXG4gIHByb3BlcnR5RnJvbUZyYWdtZW50U3ByZWFkKFxuICAgIGZyYWdtZW50U3ByZWFkOiBGcmFnbWVudFNwcmVhZCxcbiAgICBpc0NvbmRpdGlvbmFsOiBib29sZWFuXG4gICk6IEZyYWdtZW50U3ByZWFkICYgUHJvcGVydHkgJiBTdHJ1Y3Qge1xuICAgIGNvbnN0IHN0cnVjdE5hbWUgPSB0aGlzLnN0cnVjdE5hbWVGb3JGcmFnbWVudE5hbWUoZnJhZ21lbnRTcHJlYWQuZnJhZ21lbnROYW1lKTtcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBmcmFnbWVudFNwcmVhZCwge1xuICAgICAgcHJvcGVydHlOYW1lOiBjYW1lbENhc2UoZnJhZ21lbnRTcHJlYWQuZnJhZ21lbnROYW1lKSxcbiAgICAgIHR5cGVOYW1lOiBpc0NvbmRpdGlvbmFsID8gc3RydWN0TmFtZSArICc/JyA6IHN0cnVjdE5hbWUsXG4gICAgICBzdHJ1Y3ROYW1lLFxuICAgICAgaXNDb25kaXRpb25hbFxuICAgIH0pO1xuICB9XG5cbiAgcHJvcGVydHlGcm9tSW5wdXRGaWVsZChmaWVsZDogR3JhcGhRTElucHV0RmllbGQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgcHJvcGVydHlOYW1lOiBjYW1lbENhc2UoZmllbGQubmFtZSksXG4gICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZUZyb21HcmFwaFFMVHlwZShmaWVsZC50eXBlKSxcbiAgICAgIGlzT3B0aW9uYWw6ICEoZmllbGQudHlwZSBpbnN0YW5jZW9mIEdyYXBoUUxOb25OdWxsKSxcbiAgICAgIGRlc2NyaXB0aW9uOiBmaWVsZC5kZXNjcmlwdGlvbiB8fCBudWxsLFxuICAgICAgbmFtZTogZmllbGQubmFtZSxcbiAgICB9KTtcbiAgfVxuXG4gIHByb3BlcnRpZXNGb3JTZWxlY3Rpb25TZXQoXG4gICAgc2VsZWN0aW9uU2V0OiBTZWxlY3Rpb25TZXQsXG4gICAgbmFtZXNwYWNlPzogc3RyaW5nXG4gICk6IChGaWVsZCAmIFByb3BlcnR5KVtdIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gY29sbGVjdEFuZE1lcmdlRmllbGRzKHNlbGVjdGlvblNldCwgdHJ1ZSlcbiAgICAgIC5maWx0ZXIoZmllbGQgPT4gZmllbGQubmFtZSAhPT0gJ19fdHlwZW5hbWUnKVxuICAgICAgLm1hcChmaWVsZCA9PiB0aGlzLnByb3BlcnR5RnJvbUZpZWxkKGZpZWxkLCBuYW1lc3BhY2UpKTtcblxuICAgIC8vIElmIHdlJ3JlIG5vdCBtZXJnaW5nIGluIGZpZWxkcyBmcm9tIGZyYWdtZW50IHNwcmVhZHMsIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGVyZSB3aWxsIGEgZ2VuZXJhdGVkXG4gICAgLy8gdHlwZSBmb3IgYSBjb21wb3NpdGUgZmllbGQsIHNvIHRvIGF2b2lkIGNvbXBpbGVyIGVycm9ycyB3ZSBza2lwIHRoZSBpbml0aWFsaXplciBmb3Igbm93LlxuICAgIGlmIChcbiAgICAgIHNlbGVjdGlvblNldC5zZWxlY3Rpb25zLnNvbWUoc2VsZWN0aW9uID0+IHNlbGVjdGlvbi5raW5kID09PSAnRnJhZ21lbnRTcHJlYWQnKSAmJlxuICAgICAgcHJvcGVydGllcy5zb21lKHByb3BlcnR5ID0+IGlzQ29tcG9zaXRlVHlwZShnZXROYW1lZFR5cGUocHJvcGVydHkudHlwZSkpKVxuICAgICkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcGVydGllcztcbiAgfVxuXG4gIC8vIEV4cHJlc3Npb25zXG5cbiAgZGljdGlvbmFyeUxpdGVyYWxGb3JGaWVsZEFyZ3VtZW50cyhhcmdzOiBBcmd1bWVudFtdKSB7XG4gICAgZnVuY3Rpb24gZXhwcmVzc2lvbkZyb21WYWx1ZSh2YWx1ZTogYW55KTogc3RyaW5nIHtcbiAgICAgIGlmICh2YWx1ZS5raW5kID09PSAnVmFyaWFibGUnKSB7XG4gICAgICAgIHJldHVybiBgR3JhcGhRTFZhcmlhYmxlKFwiJHt2YWx1ZS52YXJpYWJsZU5hbWV9XCIpYDtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHdyYXAoJ1snLCBqb2luKHZhbHVlLm1hcChleHByZXNzaW9uRnJvbVZhbHVlKSwgJywgJyksICddJyk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHdyYXAoXG4gICAgICAgICAgJ1snLFxuICAgICAgICAgIGpvaW4oXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGBcIiR7a2V5fVwiOiAke2V4cHJlc3Npb25Gcm9tVmFsdWUodmFsdWUpfWA7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICcsICdcbiAgICAgICAgICApIHx8ICc6JyxcbiAgICAgICAgICAnXSdcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHdyYXAoXG4gICAgICAnWycsXG4gICAgICBqb2luKFxuICAgICAgICBhcmdzLm1hcChhcmcgPT4ge1xuICAgICAgICAgIHJldHVybiBgXCIke2FyZy5uYW1lfVwiOiAke2V4cHJlc3Npb25Gcm9tVmFsdWUoYXJnLnZhbHVlKX1gO1xuICAgICAgICB9KSxcbiAgICAgICAgJywgJ1xuICAgICAgKSB8fCAnOicsXG4gICAgICAnXSdcbiAgICApO1xuICB9XG5cbiAgbWFwRXhwcmVzc2lvbkZvclR5cGUoXG4gICAgdHlwZTogR3JhcGhRTFR5cGUsXG4gICAgZXhwcmVzc2lvbjogKGlkZW50aWZpZXI6IHN0cmluZykgPT4gc3RyaW5nLFxuICAgIGlkZW50aWZpZXIgPSAnJ1xuICApOiBzdHJpbmcge1xuICAgIGxldCBpc09wdGlvbmFsO1xuICAgIGlmIChpc05vbk51bGxUeXBlKHR5cGUpKSB7XG4gICAgICBpc09wdGlvbmFsID0gZmFsc2U7XG4gICAgICB0eXBlID0gdHlwZS5vZlR5cGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzT3B0aW9uYWwgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc0xpc3RUeXBlKHR5cGUpKSB7XG4gICAgICBpZiAoaXNPcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gYCR7aWRlbnRpZmllcn0uZmxhdE1hcCB7ICQwLm1hcCB7ICR7dGhpcy5tYXBFeHByZXNzaW9uRm9yVHlwZShcbiAgICAgICAgICB0eXBlLm9mVHlwZSxcbiAgICAgICAgICBleHByZXNzaW9uLFxuICAgICAgICAgICckMCdcbiAgICAgICAgKX0gfSB9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBgJHtpZGVudGlmaWVyfS5tYXAgeyAke3RoaXMubWFwRXhwcmVzc2lvbkZvclR5cGUodHlwZS5vZlR5cGUsIGV4cHJlc3Npb24sICckMCcpfSB9YDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICAgIHJldHVybiBgJHtpZGVudGlmaWVyfS5mbGF0TWFwIHsgJHtleHByZXNzaW9uKCckMCcpfSB9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGV4cHJlc3Npb24oaWRlbnRpZmllcik7XG4gICAgfVxuICB9XG59XG4iXX0=");"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const change_case_1 = require("change-case");
const Inflector = require("inflected");
const printing_1 = require("../utilities/printing");
const graphql_2 = require("../utilities/graphql");
const collectAndMergeFields_1 = require("../compiler/visitors/collectAndMergeFields");
const aws_scalar_helper_1 = require("./aws-scalar-helper");
const builtInScalarMap = {
    [graphql_1.GraphQLString.name]: 'String',
    [graphql_1.GraphQLInt.name]: 'Int',
    [graphql_1.GraphQLFloat.name]: 'Double',
    [graphql_1.GraphQLBoolean.name]: 'Bool',
    [graphql_1.GraphQLID.name]: 'GraphQLID' };

class Helpers {
    constructor(options) {
        this.options = options;
    }
    typeNameFromGraphQLType(type, unmodifiedTypeName, isOptional) {
        if (graphql_1.isNonNullType(type)) {
            return this.typeNameFromGraphQLType(type.ofType, unmodifiedTypeName, false);
        } else
        if (isOptional === undefined) {
            isOptional = true;
        }
        let typeName;
        if (graphql_1.isListType(type)) {
            typeName = '[' + this.typeNameFromGraphQLType(type.ofType, unmodifiedTypeName) + ']';
        } else
        if (type instanceof graphql_1.GraphQLScalarType) {
            typeName = this.typeNameForScalarType(type);
        } else
        {
            typeName = unmodifiedTypeName || type.name;
        }
        return isOptional ? typeName + '?' : typeName;
    }
    typeNameForScalarType(type) {
        return builtInScalarMap[type.name] || (
        this.options.passthroughCustomScalars ?
        this.options.customScalarsPrefix + type.name :
        aws_scalar_helper_1.getTypeForAWSScalar(type) ? aws_scalar_helper_1.getTypeForAWSScalar(type) : graphql_1.GraphQLString.name);
    }
    fieldTypeEnum(type, structName) {
        if (graphql_1.isNonNullType(type)) {
            return `.nonNull(${this.fieldTypeEnum(type.ofType, structName)})`;
        } else
        if (graphql_1.isListType(type)) {
            return `.list(${this.fieldTypeEnum(type.ofType, structName)})`;
        } else
        if (type instanceof graphql_1.GraphQLScalarType) {
            return `.scalar(${this.typeNameForScalarType(type)}.self)`;
        } else
        if (type instanceof graphql_1.GraphQLEnumType) {
            return `.scalar(${type.name}.self)`;
        } else
        if (graphql_1.isCompositeType(type)) {
            return `.object(${structName}.selections)`;
        } else
        {
            throw new Error(`Unknown field type: ${type}`);
        }
    }
    enumCaseName(name) {
        return change_case_1.camelCase(name);
    }
    enumDotCaseName(name) {
        return `.${change_case_1.camelCase(name)}`;
    }
    operationClassName(name) {
        return change_case_1.pascalCase(name);
    }
    structNameForPropertyName(propertyName) {
        return change_case_1.pascalCase(Inflector.singularize(propertyName));
    }
    structNameForFragmentName(fragmentName) {
        return change_case_1.pascalCase(fragmentName);
    }
    structNameForVariant(variant) {
        return 'As' + variant.possibleTypes.map(type => change_case_1.pascalCase(type.name)).join('Or');
    }
    propertyFromField(field, namespace) {
        const { responseKey, isConditional } = field;
        const propertyName = graphql_2.isMetaFieldName(responseKey) ? responseKey : change_case_1.camelCase(responseKey);
        const structName = printing_1.join([namespace, this.structNameForPropertyName(responseKey)], '.');
        let type = field.type;
        if (isConditional && graphql_1.isNonNullType(type)) {
            type = type.ofType;
        }
        const isOptional = !(type instanceof graphql_1.GraphQLNonNull);
        const unmodifiedType = graphql_1.getNamedType(field.type);
        const unmodifiedTypeName = graphql_1.isCompositeType(unmodifiedType) ? structName : unmodifiedType.name;
        const typeName = this.typeNameFromGraphQLType(type, unmodifiedTypeName);
        return Object.assign({}, field, {
            responseKey,
            propertyName,
            typeName,
            structName,
            isOptional });

    }
    propertyFromVariant(variant) {
        const structName = this.structNameForVariant(variant);
        return Object.assign(variant, {
            propertyName: change_case_1.camelCase(structName),
            typeName: structName + '?',
            structName });

    }
    propertyFromFragmentSpread(fragmentSpread, isConditional) {
        const structName = this.structNameForFragmentName(fragmentSpread.fragmentName);
        return Object.assign({}, fragmentSpread, {
            propertyName: change_case_1.camelCase(fragmentSpread.fragmentName),
            typeName: isConditional ? structName + '?' : structName,
            structName,
            isConditional });

    }
    propertyFromInputField(field) {
        return Object.assign({}, {
            propertyName: change_case_1.camelCase(field.name),
            typeName: this.typeNameFromGraphQLType(field.type),
            isOptional: !(field.type instanceof graphql_1.GraphQLNonNull),
            description: field.description || null,
            name: field.name });

    }
    propertiesForSelectionSet(selectionSet, namespace) {
        const properties = collectAndMergeFields_1.collectAndMergeFields(selectionSet, true).
        filter(field => field.name !== '__typename').
        map(field => this.propertyFromField(field, namespace));
        if (selectionSet.selections.some(selection => selection.kind === 'FragmentSpread') &&
        properties.some(property => graphql_1.isCompositeType(graphql_1.getNamedType(property.type)))) {
            return undefined;
        }
        return properties;
    }
    dictionaryLiteralForFieldArguments(args) {
        function expressionFromValue(value) {
            if (value.kind === 'Variable') {
                return `GraphQLVariable("${value.variableName}")`;
            } else
            if (Array.isArray(value)) {
                return printing_1.wrap('[', printing_1.join(value.map(expressionFromValue), ', '), ']');
            } else
            if (typeof value === 'object') {
                return printing_1.wrap('[', printing_1.join(Object.entries(value).map(([key, value]) => {
                    return `"${key}": ${expressionFromValue(value)}`;
                }), ', ') || ':', ']');
            } else
            {
                return JSON.stringify(value);
            }
        }
        return printing_1.wrap('[', printing_1.join(args.map(arg => {
            return `"${arg.name}": ${expressionFromValue(arg.value)}`;
        }), ', ') || ':', ']');
    }
    mapExpressionForType(type, expression, identifier = '') {
        let isOptional;
        if (graphql_1.isNonNullType(type)) {
            isOptional = false;
            type = type.ofType;
        } else
        {
            isOptional = true;
        }
        if (graphql_1.isListType(type)) {
            if (isOptional) {
                return `${identifier}.flatMap { $0.map { ${this.mapExpressionForType(type.ofType, expression, '$0')} } }`;
            } else
            {
                return `${identifier}.map { ${this.mapExpressionForType(type.ofType, expression, '$0')} }`;
            }
        } else
        if (isOptional) {
            return `${identifier}.flatMap { ${expression('$0')} }`;
        } else
        {
            return expression(identifier);
        }
    }}

exports.Helpers = Helpers;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImhlbHBlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxNQUFBLFlBQUEsUUFBQSxTQUFBLENBQUE7QUFpQkEsTUFBQSxnQkFBQSxRQUFBLGFBQUEsQ0FBQTtBQUNBLE1BQUEsWUFBQSxRQUFBLFdBQUEsQ0FBQTtBQUNBLE1BQUEsYUFBQSxRQUFBLHVCQUFBLENBQUE7QUFLQSxNQUFBLFlBQUEsUUFBQSxzQkFBQSxDQUFBO0FBRUEsTUFBQSwwQkFBQSxRQUFBLDRDQUFBLENBQUE7QUFDQSxNQUFBLHNCQUFBLFFBQUEscUJBQUEsQ0FBQTtBQUVBLE1BQU0sbUJBQW1CO0FBQ3ZCLEtBQUMsVUFBQSxhQUFBLENBQWMsSUFBZixHQUFzQixRQURDO0FBRXZCLEtBQUMsVUFBQSxVQUFBLENBQVcsSUFBWixHQUFtQixLQUZJO0FBR3ZCLEtBQUMsVUFBQSxZQUFBLENBQWEsSUFBZCxHQUFxQixRQUhFO0FBSXZCLEtBQUMsVUFBQSxjQUFBLENBQWUsSUFBaEIsR0FBdUIsTUFKQTtBQUt2QixLQUFDLFVBQUEsU0FBQSxDQUFVLElBQVgsR0FBa0IsV0FMSyxFQUF6Qjs7QUFRQSxNQUFBLE9BQUEsQ0FBQTtBQUNFLGdCQUFtQixPQUFuQixFQUEyQztBQUF4QixhQUFBLE9BQUEsR0FBQSxPQUFBO0FBQTRCO0FBSS9DLDRCQUF3QixJQUF4QixFQUEyQyxrQkFBM0MsRUFBd0UsVUFBeEUsRUFBNEY7QUFDMUYsWUFBSSxVQUFBLGFBQUEsQ0FBYyxJQUFkLENBQUosRUFBeUI7QUFDdkIsbUJBQU8sS0FBSyx1QkFBTCxDQUE2QixLQUFLLE1BQWxDLEVBQTBDLGtCQUExQyxFQUE4RCxLQUE5RCxDQUFQO0FBQ0QsU0FGRDtBQUVPLFlBQUksZUFBZSxTQUFuQixFQUE4QjtBQUNuQyx5QkFBYSxJQUFiO0FBQ0Q7QUFFRCxZQUFJLFFBQUo7QUFDQSxZQUFJLFVBQUEsVUFBQSxDQUFXLElBQVgsQ0FBSixFQUFzQjtBQUNwQix1QkFBVyxNQUFNLEtBQUssdUJBQUwsQ0FBNkIsS0FBSyxNQUFsQyxFQUEwQyxrQkFBMUMsQ0FBTixHQUFzRSxHQUFqRjtBQUNELFNBRkQ7QUFFTyxZQUFJLGdCQUFnQixVQUFBLGlCQUFwQixFQUF1QztBQUM1Qyx1QkFBVyxLQUFLLHFCQUFMLENBQTJCLElBQTNCLENBQVg7QUFDRCxTQUZNO0FBRUE7QUFDTCx1QkFBVyxzQkFBc0IsS0FBSyxJQUF0QztBQUNEO0FBRUQsZUFBTyxhQUFhLFdBQVcsR0FBeEIsR0FBOEIsUUFBckM7QUFDRDtBQUVELDBCQUFzQixJQUF0QixFQUE2QztBQUMzQyxlQUNFLGlCQUFpQixLQUFLLElBQXRCO0FBQ0MsYUFBSyxPQUFMLENBQWEsd0JBQWI7QUFDRyxhQUFLLE9BQUwsQ0FBYSxtQkFBYixHQUFtQyxLQUFLLElBRDNDO0FBRUcsNEJBQUEsbUJBQUEsQ0FBb0IsSUFBcEIsSUFBNEIsb0JBQUEsbUJBQUEsQ0FBb0IsSUFBcEIsQ0FBNUIsR0FBdUQsVUFBQSxhQUFBLENBQWMsSUFIekUsQ0FERjtBQU1EO0FBRUQsa0JBQWMsSUFBZCxFQUFpQyxVQUFqQyxFQUFtRDtBQUNqRCxZQUFJLFVBQUEsYUFBQSxDQUFjLElBQWQsQ0FBSixFQUF5QjtBQUN2QixtQkFBTyxZQUFZLEtBQUssYUFBTCxDQUFtQixLQUFLLE1BQXhCLEVBQWdDLFVBQWhDLENBQTJDLEdBQTlEO0FBQ0QsU0FGRDtBQUVPLFlBQUksVUFBQSxVQUFBLENBQVcsSUFBWCxDQUFKLEVBQXNCO0FBQzNCLG1CQUFPLFNBQVMsS0FBSyxhQUFMLENBQW1CLEtBQUssTUFBeEIsRUFBZ0MsVUFBaEMsQ0FBMkMsR0FBM0Q7QUFDRCxTQUZNO0FBRUEsWUFBSSxnQkFBZ0IsVUFBQSxpQkFBcEIsRUFBdUM7QUFDNUMsbUJBQU8sV0FBVyxLQUFLLHFCQUFMLENBQTJCLElBQTNCLENBQWdDLFFBQWxEO0FBQ0QsU0FGTTtBQUVBLFlBQUksZ0JBQWdCLFVBQUEsZUFBcEIsRUFBcUM7QUFDMUMsbUJBQU8sV0FBVyxLQUFLLElBQUksUUFBM0I7QUFDRCxTQUZNO0FBRUEsWUFBSSxVQUFBLGVBQUEsQ0FBZ0IsSUFBaEIsQ0FBSixFQUEyQjtBQUNoQyxtQkFBTyxXQUFXLFVBQVUsY0FBNUI7QUFDRCxTQUZNO0FBRUE7QUFDTCxrQkFBTSxJQUFJLEtBQUosQ0FBVSx1QkFBdUIsSUFBSSxFQUFyQyxDQUFOO0FBQ0Q7QUFDRjtBQUlELGlCQUFhLElBQWIsRUFBeUI7QUFDdkIsZUFBTyxjQUFBLFNBQUEsQ0FBVSxJQUFWLENBQVA7QUFDRDtBQUVELG9CQUFnQixJQUFoQixFQUE0QjtBQUMxQixlQUFPLElBQUksY0FBQSxTQUFBLENBQVUsSUFBVixDQUFlLEVBQTFCO0FBQ0Q7QUFFRCx1QkFBbUIsSUFBbkIsRUFBK0I7QUFDN0IsZUFBTyxjQUFBLFVBQUEsQ0FBVyxJQUFYLENBQVA7QUFDRDtBQUVELDhCQUEwQixZQUExQixFQUE4QztBQUM1QyxlQUFPLGNBQUEsVUFBQSxDQUFXLFVBQVUsV0FBVixDQUFzQixZQUF0QixDQUFYLENBQVA7QUFDRDtBQUVELDhCQUEwQixZQUExQixFQUE4QztBQUM1QyxlQUFPLGNBQUEsVUFBQSxDQUFXLFlBQVgsQ0FBUDtBQUNEO0FBRUQseUJBQXFCLE9BQXJCLEVBQTBDO0FBQ3hDLGVBQU8sT0FBTyxRQUFRLGFBQVIsQ0FBc0IsR0FBdEIsQ0FBMEIsUUFBUSxjQUFBLFVBQUEsQ0FBVyxLQUFLLElBQWhCLENBQWxDLEVBQXlELElBQXpELENBQThELElBQTlELENBQWQ7QUFDRDtBQUlELHNCQUFrQixLQUFsQixFQUFnQyxTQUFoQyxFQUFrRDtBQUNoRCxjQUFNLEVBQUUsV0FBRixFQUFlLGFBQWYsS0FBaUMsS0FBdkM7QUFFQSxjQUFNLGVBQWUsVUFBQSxlQUFBLENBQWdCLFdBQWhCLElBQStCLFdBQS9CLEdBQTZDLGNBQUEsU0FBQSxDQUFVLFdBQVYsQ0FBbEU7QUFFQSxjQUFNLGFBQWEsV0FBQSxJQUFBLENBQUssQ0FBQyxTQUFELEVBQVksS0FBSyx5QkFBTCxDQUErQixXQUEvQixDQUFaLENBQUwsRUFBK0QsR0FBL0QsQ0FBbkI7QUFFQSxZQUFJLE9BQU8sTUFBTSxJQUFqQjtBQUVBLFlBQUksaUJBQWlCLFVBQUEsYUFBQSxDQUFjLElBQWQsQ0FBckIsRUFBMEM7QUFDeEMsbUJBQU8sS0FBSyxNQUFaO0FBQ0Q7QUFFRCxjQUFNLGFBQWEsRUFBRSxnQkFBZ0IsVUFBQSxjQUFsQixDQUFuQjtBQUVBLGNBQU0saUJBQWlCLFVBQUEsWUFBQSxDQUFhLE1BQU0sSUFBbkIsQ0FBdkI7QUFFQSxjQUFNLHFCQUFxQixVQUFBLGVBQUEsQ0FBZ0IsY0FBaEIsSUFBa0MsVUFBbEMsR0FBK0MsZUFBZSxJQUF6RjtBQUVBLGNBQU0sV0FBVyxLQUFLLHVCQUFMLENBQTZCLElBQTdCLEVBQW1DLGtCQUFuQyxDQUFqQjtBQUVBLGVBQU8sT0FBTyxNQUFQLENBQWMsRUFBZCxFQUFrQixLQUFsQixFQUF5QjtBQUM5Qix1QkFEOEI7QUFFOUIsd0JBRjhCO0FBRzlCLG9CQUg4QjtBQUk5QixzQkFKOEI7QUFLOUIsc0JBTDhCLEVBQXpCLENBQVA7O0FBT0Q7QUFFRCx3QkFBb0IsT0FBcEIsRUFBb0M7QUFDbEMsY0FBTSxhQUFhLEtBQUssb0JBQUwsQ0FBMEIsT0FBMUIsQ0FBbkI7QUFFQSxlQUFPLE9BQU8sTUFBUCxDQUFjLE9BQWQsRUFBdUI7QUFDNUIsMEJBQWMsY0FBQSxTQUFBLENBQVUsVUFBVixDQURjO0FBRTVCLHNCQUFVLGFBQWEsR0FGSztBQUc1QixzQkFINEIsRUFBdkIsQ0FBUDs7QUFLRDtBQUVELCtCQUNFLGNBREYsRUFFRSxhQUZGLEVBRXdCO0FBRXRCLGNBQU0sYUFBYSxLQUFLLHlCQUFMLENBQStCLGVBQWUsWUFBOUMsQ0FBbkI7QUFFQSxlQUFPLE9BQU8sTUFBUCxDQUFjLEVBQWQsRUFBa0IsY0FBbEIsRUFBa0M7QUFDdkMsMEJBQWMsY0FBQSxTQUFBLENBQVUsZUFBZSxZQUF6QixDQUR5QjtBQUV2QyxzQkFBVSxnQkFBZ0IsYUFBYSxHQUE3QixHQUFtQyxVQUZOO0FBR3ZDLHNCQUh1QztBQUl2Qyx5QkFKdUMsRUFBbEMsQ0FBUDs7QUFNRDtBQUVELDJCQUF1QixLQUF2QixFQUErQztBQUM3QyxlQUFPLE9BQU8sTUFBUCxDQUFjLEVBQWQsRUFBa0I7QUFDdkIsMEJBQWMsY0FBQSxTQUFBLENBQVUsTUFBTSxJQUFoQixDQURTO0FBRXZCLHNCQUFVLEtBQUssdUJBQUwsQ0FBNkIsTUFBTSxJQUFuQyxDQUZhO0FBR3ZCLHdCQUFZLEVBQUUsTUFBTSxJQUFOLFlBQXNCLFVBQUEsY0FBeEIsQ0FIVztBQUl2Qix5QkFBYSxNQUFNLFdBQU4sSUFBcUIsSUFKWDtBQUt2QixrQkFBTSxNQUFNLElBTFcsRUFBbEIsQ0FBUDs7QUFPRDtBQUVELDhCQUNFLFlBREYsRUFFRSxTQUZGLEVBRW9CO0FBRWxCLGNBQU0sYUFBYSx3QkFBQSxxQkFBQSxDQUFzQixZQUF0QixFQUFvQyxJQUFwQztBQUNoQixjQURnQixDQUNULFNBQVMsTUFBTSxJQUFOLEtBQWUsWUFEZjtBQUVoQixXQUZnQixDQUVaLFNBQVMsS0FBSyxpQkFBTCxDQUF1QixLQUF2QixFQUE4QixTQUE5QixDQUZHLENBQW5CO0FBTUEsWUFDRSxhQUFhLFVBQWIsQ0FBd0IsSUFBeEIsQ0FBNkIsYUFBYSxVQUFVLElBQVYsS0FBbUIsZ0JBQTdEO0FBQ0EsbUJBQVcsSUFBWCxDQUFnQixZQUFZLFVBQUEsZUFBQSxDQUFnQixVQUFBLFlBQUEsQ0FBYSxTQUFTLElBQXRCLENBQWhCLENBQTVCLENBRkYsRUFHRTtBQUNBLG1CQUFPLFNBQVA7QUFDRDtBQUVELGVBQU8sVUFBUDtBQUNEO0FBSUQsdUNBQW1DLElBQW5DLEVBQW1EO0FBQ2pELGlCQUFBLG1CQUFBLENBQTZCLEtBQTdCLEVBQXVDO0FBQ3JDLGdCQUFJLE1BQU0sSUFBTixLQUFlLFVBQW5CLEVBQStCO0FBQzdCLHVCQUFPLG9CQUFvQixNQUFNLFlBQVksSUFBN0M7QUFDRCxhQUZEO0FBRU8sZ0JBQUksTUFBTSxPQUFOLENBQWMsS0FBZCxDQUFKLEVBQTBCO0FBQy9CLHVCQUFPLFdBQUEsSUFBQSxDQUFLLEdBQUwsRUFBVSxXQUFBLElBQUEsQ0FBSyxNQUFNLEdBQU4sQ0FBVSxtQkFBVixDQUFMLEVBQXFDLElBQXJDLENBQVYsRUFBc0QsR0FBdEQsQ0FBUDtBQUNELGFBRk07QUFFQSxnQkFBSSxPQUFPLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDcEMsdUJBQU8sV0FBQSxJQUFBLENBQ0wsR0FESyxFQUVMLFdBQUEsSUFBQSxDQUNFLE9BQU8sT0FBUCxDQUFlLEtBQWYsRUFBc0IsR0FBdEIsQ0FBMEIsQ0FBQyxDQUFDLEdBQUQsRUFBTSxLQUFOLENBQUQsS0FBaUI7QUFDekMsMkJBQU8sSUFBSSxHQUFHLE1BQU0sb0JBQW9CLEtBQXBCLENBQTBCLEVBQTlDO0FBQ0QsaUJBRkQsQ0FERixFQUlFLElBSkYsS0FLSyxHQVBBLEVBUUwsR0FSSyxDQUFQO0FBVUQsYUFYTTtBQVdBO0FBQ0wsdUJBQU8sS0FBSyxTQUFMLENBQWUsS0FBZixDQUFQO0FBQ0Q7QUFDRjtBQUVELGVBQU8sV0FBQSxJQUFBLENBQ0wsR0FESyxFQUVMLFdBQUEsSUFBQSxDQUNFLEtBQUssR0FBTCxDQUFTLE9BQU07QUFDYixtQkFBTyxJQUFJLElBQUksSUFBSSxNQUFNLG9CQUFvQixJQUFJLEtBQXhCLENBQThCLEVBQXZEO0FBQ0QsU0FGRCxDQURGLEVBSUUsSUFKRixLQUtLLEdBUEEsRUFRTCxHQVJLLENBQVA7QUFVRDtBQUVELHlCQUNFLElBREYsRUFFRSxVQUZGLEVBR0UsYUFBYSxFQUhmLEVBR2lCO0FBRWYsWUFBSSxVQUFKO0FBQ0EsWUFBSSxVQUFBLGFBQUEsQ0FBYyxJQUFkLENBQUosRUFBeUI7QUFDdkIseUJBQWEsS0FBYjtBQUNBLG1CQUFPLEtBQUssTUFBWjtBQUNELFNBSEQ7QUFHTztBQUNMLHlCQUFhLElBQWI7QUFDRDtBQUVELFlBQUksVUFBQSxVQUFBLENBQVcsSUFBWCxDQUFKLEVBQXNCO0FBQ3BCLGdCQUFJLFVBQUosRUFBZ0I7QUFDZCx1QkFBTyxHQUFHLFVBQVUsdUJBQXVCLEtBQUssb0JBQUwsQ0FDekMsS0FBSyxNQURvQyxFQUV6QyxVQUZ5QyxFQUd6QyxJQUh5QyxDQUkxQyxNQUpEO0FBS0QsYUFORDtBQU1PO0FBQ0wsdUJBQU8sR0FBRyxVQUFVLFVBQVUsS0FBSyxvQkFBTCxDQUEwQixLQUFLLE1BQS9CLEVBQXVDLFVBQXZDLEVBQW1ELElBQW5ELENBQXdELElBQXRGO0FBQ0Q7QUFDRixTQVZEO0FBVU8sWUFBSSxVQUFKLEVBQWdCO0FBQ3JCLG1CQUFPLEdBQUcsVUFBVSxjQUFjLFdBQVcsSUFBWCxDQUFnQixJQUFsRDtBQUNELFNBRk07QUFFQTtBQUNMLG1CQUFPLFdBQVcsVUFBWCxDQUFQO0FBQ0Q7QUFDRixLQWpPSDs7QUFBQSxRQUFBLE9BQUEsR0FBQSxPQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgR3JhcGhRTFR5cGUsXG4gIEdyYXBoUUxTdHJpbmcsXG4gIEdyYXBoUUxJbnQsXG4gIEdyYXBoUUxGbG9hdCxcbiAgR3JhcGhRTEJvb2xlYW4sXG4gIEdyYXBoUUxJRCxcbiAgR3JhcGhRTE5vbk51bGwsXG4gIEdyYXBoUUxTY2FsYXJUeXBlLFxuICBHcmFwaFFMRW51bVR5cGUsXG4gIGlzQ29tcG9zaXRlVHlwZSxcbiAgZ2V0TmFtZWRUeXBlLFxuICBHcmFwaFFMSW5wdXRGaWVsZCxcbiAgaXNOb25OdWxsVHlwZSxcbiAgaXNMaXN0VHlwZVxufSBmcm9tICdncmFwaHFsJztcblxuaW1wb3J0IHsgY2FtZWxDYXNlLCBwYXNjYWxDYXNlIH0gZnJvbSAnY2hhbmdlLWNhc2UnO1xuaW1wb3J0ICogYXMgSW5mbGVjdG9yIGZyb20gJ2luZmxlY3RlZCc7XG5pbXBvcnQgeyBqb2luLCB3cmFwIH0gZnJvbSAnLi4vdXRpbGl0aWVzL3ByaW50aW5nJztcblxuaW1wb3J0IHsgUHJvcGVydHksIFN0cnVjdCB9IGZyb20gJy4vbGFuZ3VhZ2UnO1xuXG5pbXBvcnQgeyBDb21waWxlck9wdGlvbnMsIFNlbGVjdGlvblNldCwgRmllbGQsIEZyYWdtZW50U3ByZWFkLCBBcmd1bWVudCB9IGZyb20gJy4uL2NvbXBpbGVyJztcbmltcG9ydCB7IGlzTWV0YUZpZWxkTmFtZSB9IGZyb20gJy4uL3V0aWxpdGllcy9ncmFwaHFsJztcbmltcG9ydCB7IFZhcmlhbnQgfSBmcm9tICcuLi9jb21waWxlci92aXNpdG9ycy90eXBlQ2FzZSc7XG5pbXBvcnQgeyBjb2xsZWN0QW5kTWVyZ2VGaWVsZHMgfSBmcm9tICcuLi9jb21waWxlci92aXNpdG9ycy9jb2xsZWN0QW5kTWVyZ2VGaWVsZHMnO1xuaW1wb3J0IHsgZ2V0VHlwZUZvckFXU1NjYWxhciB9IGZyb20gJy4vYXdzLXNjYWxhci1oZWxwZXInO1xuXG5jb25zdCBidWlsdEluU2NhbGFyTWFwID0ge1xuICBbR3JhcGhRTFN0cmluZy5uYW1lXTogJ1N0cmluZycsXG4gIFtHcmFwaFFMSW50Lm5hbWVdOiAnSW50JyxcbiAgW0dyYXBoUUxGbG9hdC5uYW1lXTogJ0RvdWJsZScsXG4gIFtHcmFwaFFMQm9vbGVhbi5uYW1lXTogJ0Jvb2wnLFxuICBbR3JhcGhRTElELm5hbWVdOiAnR3JhcGhRTElEJ1xufTtcblxuZXhwb3J0IGNsYXNzIEhlbHBlcnMge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgb3B0aW9uczogQ29tcGlsZXJPcHRpb25zKSB7fVxuXG4gIC8vIFR5cGVzXG5cbiAgdHlwZU5hbWVGcm9tR3JhcGhRTFR5cGUodHlwZTogR3JhcGhRTFR5cGUsIHVubW9kaWZpZWRUeXBlTmFtZT86IHN0cmluZywgaXNPcHRpb25hbD86IGJvb2xlYW4pOiBzdHJpbmcge1xuICAgIGlmIChpc05vbk51bGxUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlTmFtZUZyb21HcmFwaFFMVHlwZSh0eXBlLm9mVHlwZSwgdW5tb2RpZmllZFR5cGVOYW1lLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChpc09wdGlvbmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlzT3B0aW9uYWwgPSB0cnVlO1xuICAgIH1cblxuICAgIGxldCB0eXBlTmFtZTtcbiAgICBpZiAoaXNMaXN0VHlwZSh0eXBlKSkge1xuICAgICAgdHlwZU5hbWUgPSAnWycgKyB0aGlzLnR5cGVOYW1lRnJvbUdyYXBoUUxUeXBlKHR5cGUub2ZUeXBlLCB1bm1vZGlmaWVkVHlwZU5hbWUpICsgJ10nO1xuICAgIH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIEdyYXBoUUxTY2FsYXJUeXBlKSB7XG4gICAgICB0eXBlTmFtZSA9IHRoaXMudHlwZU5hbWVGb3JTY2FsYXJUeXBlKHR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlTmFtZSA9IHVubW9kaWZpZWRUeXBlTmFtZSB8fCB0eXBlLm5hbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzT3B0aW9uYWwgPyB0eXBlTmFtZSArICc/JyA6IHR5cGVOYW1lO1xuICB9XG5cbiAgdHlwZU5hbWVGb3JTY2FsYXJUeXBlKHR5cGU6IEdyYXBoUUxTY2FsYXJUeXBlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gKFxuICAgICAgYnVpbHRJblNjYWxhck1hcFt0eXBlLm5hbWVdIHx8XG4gICAgICAodGhpcy5vcHRpb25zLnBhc3N0aHJvdWdoQ3VzdG9tU2NhbGFyc1xuICAgICAgICA/IHRoaXMub3B0aW9ucy5jdXN0b21TY2FsYXJzUHJlZml4ICsgdHlwZS5uYW1lXG4gICAgICAgIDogZ2V0VHlwZUZvckFXU1NjYWxhcih0eXBlKSA/IGdldFR5cGVGb3JBV1NTY2FsYXIodHlwZSk6IEdyYXBoUUxTdHJpbmcubmFtZSlcbiAgICApO1xuICB9XG5cbiAgZmllbGRUeXBlRW51bSh0eXBlOiBHcmFwaFFMVHlwZSwgc3RydWN0TmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAoaXNOb25OdWxsVHlwZSh0eXBlKSkge1xuICAgICAgcmV0dXJuIGAubm9uTnVsbCgke3RoaXMuZmllbGRUeXBlRW51bSh0eXBlLm9mVHlwZSwgc3RydWN0TmFtZSl9KWA7XG4gICAgfSBlbHNlIGlmIChpc0xpc3RUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gYC5saXN0KCR7dGhpcy5maWVsZFR5cGVFbnVtKHR5cGUub2ZUeXBlLCBzdHJ1Y3ROYW1lKX0pYDtcbiAgICB9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBHcmFwaFFMU2NhbGFyVHlwZSkge1xuICAgICAgcmV0dXJuIGAuc2NhbGFyKCR7dGhpcy50eXBlTmFtZUZvclNjYWxhclR5cGUodHlwZSl9LnNlbGYpYDtcbiAgICB9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBHcmFwaFFMRW51bVR5cGUpIHtcbiAgICAgIHJldHVybiBgLnNjYWxhcigke3R5cGUubmFtZX0uc2VsZilgO1xuICAgIH0gZWxzZSBpZiAoaXNDb21wb3NpdGVUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gYC5vYmplY3QoJHtzdHJ1Y3ROYW1lfS5zZWxlY3Rpb25zKWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBmaWVsZCB0eXBlOiAke3R5cGV9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gTmFtZXNcblxuICBlbnVtQ2FzZU5hbWUobmFtZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGNhbWVsQ2FzZShuYW1lKTtcbiAgfVxuXG4gIGVudW1Eb3RDYXNlTmFtZShuYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gYC4ke2NhbWVsQ2FzZShuYW1lKX1gO1xuICB9XG5cbiAgb3BlcmF0aW9uQ2xhc3NOYW1lKG5hbWU6IHN0cmluZykge1xuICAgIHJldHVybiBwYXNjYWxDYXNlKG5hbWUpO1xuICB9XG5cbiAgc3RydWN0TmFtZUZvclByb3BlcnR5TmFtZShwcm9wZXJ0eU5hbWU6IHN0cmluZykge1xuICAgIHJldHVybiBwYXNjYWxDYXNlKEluZmxlY3Rvci5zaW5ndWxhcml6ZShwcm9wZXJ0eU5hbWUpKTtcbiAgfVxuXG4gIHN0cnVjdE5hbWVGb3JGcmFnbWVudE5hbWUoZnJhZ21lbnROYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gcGFzY2FsQ2FzZShmcmFnbWVudE5hbWUpO1xuICB9XG5cbiAgc3RydWN0TmFtZUZvclZhcmlhbnQodmFyaWFudDogU2VsZWN0aW9uU2V0KSB7XG4gICAgcmV0dXJuICdBcycgKyB2YXJpYW50LnBvc3NpYmxlVHlwZXMubWFwKHR5cGUgPT4gcGFzY2FsQ2FzZSh0eXBlLm5hbWUpKS5qb2luKCdPcicpO1xuICB9XG5cbiAgLy8gUHJvcGVydGllc1xuXG4gIHByb3BlcnR5RnJvbUZpZWxkKGZpZWxkOiBGaWVsZCwgbmFtZXNwYWNlPzogc3RyaW5nKTogRmllbGQgJiBQcm9wZXJ0eSAmIFN0cnVjdCB7XG4gICAgY29uc3QgeyByZXNwb25zZUtleSwgaXNDb25kaXRpb25hbCB9ID0gZmllbGQ7XG5cbiAgICBjb25zdCBwcm9wZXJ0eU5hbWUgPSBpc01ldGFGaWVsZE5hbWUocmVzcG9uc2VLZXkpID8gcmVzcG9uc2VLZXkgOiBjYW1lbENhc2UocmVzcG9uc2VLZXkpO1xuXG4gICAgY29uc3Qgc3RydWN0TmFtZSA9IGpvaW4oW25hbWVzcGFjZSwgdGhpcy5zdHJ1Y3ROYW1lRm9yUHJvcGVydHlOYW1lKHJlc3BvbnNlS2V5KV0sICcuJyk7XG5cbiAgICBsZXQgdHlwZSA9IGZpZWxkLnR5cGU7XG5cbiAgICBpZiAoaXNDb25kaXRpb25hbCAmJiBpc05vbk51bGxUeXBlKHR5cGUpKSB7XG4gICAgICB0eXBlID0gdHlwZS5vZlR5cGU7XG4gICAgfVxuXG4gICAgY29uc3QgaXNPcHRpb25hbCA9ICEodHlwZSBpbnN0YW5jZW9mIEdyYXBoUUxOb25OdWxsKTtcblxuICAgIGNvbnN0IHVubW9kaWZpZWRUeXBlID0gZ2V0TmFtZWRUeXBlKGZpZWxkLnR5cGUpO1xuXG4gICAgY29uc3QgdW5tb2RpZmllZFR5cGVOYW1lID0gaXNDb21wb3NpdGVUeXBlKHVubW9kaWZpZWRUeXBlKSA/IHN0cnVjdE5hbWUgOiB1bm1vZGlmaWVkVHlwZS5uYW1lO1xuXG4gICAgY29uc3QgdHlwZU5hbWUgPSB0aGlzLnR5cGVOYW1lRnJvbUdyYXBoUUxUeXBlKHR5cGUsIHVubW9kaWZpZWRUeXBlTmFtZSk7XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZmllbGQsIHtcbiAgICAgIHJlc3BvbnNlS2V5LFxuICAgICAgcHJvcGVydHlOYW1lLFxuICAgICAgdHlwZU5hbWUsXG4gICAgICBzdHJ1Y3ROYW1lLFxuICAgICAgaXNPcHRpb25hbFxuICAgIH0pO1xuICB9XG5cbiAgcHJvcGVydHlGcm9tVmFyaWFudCh2YXJpYW50OiBWYXJpYW50KTogVmFyaWFudCAmIFByb3BlcnR5ICYgU3RydWN0IHtcbiAgICBjb25zdCBzdHJ1Y3ROYW1lID0gdGhpcy5zdHJ1Y3ROYW1lRm9yVmFyaWFudCh2YXJpYW50KTtcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHZhcmlhbnQsIHtcbiAgICAgIHByb3BlcnR5TmFtZTogY2FtZWxDYXNlKHN0cnVjdE5hbWUpLFxuICAgICAgdHlwZU5hbWU6IHN0cnVjdE5hbWUgKyAnPycsXG4gICAgICBzdHJ1Y3ROYW1lXG4gICAgfSk7XG4gIH1cblxuICBwcm9wZXJ0eUZyb21GcmFnbWVudFNwcmVhZChcbiAgICBmcmFnbWVudFNwcmVhZDogRnJhZ21lbnRTcHJlYWQsXG4gICAgaXNDb25kaXRpb25hbDogYm9vbGVhblxuICApOiBGcmFnbWVudFNwcmVhZCAmIFByb3BlcnR5ICYgU3RydWN0IHtcbiAgICBjb25zdCBzdHJ1Y3ROYW1lID0gdGhpcy5zdHJ1Y3ROYW1lRm9yRnJhZ21lbnROYW1lKGZyYWdtZW50U3ByZWFkLmZyYWdtZW50TmFtZSk7XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZnJhZ21lbnRTcHJlYWQsIHtcbiAgICAgIHByb3BlcnR5TmFtZTogY2FtZWxDYXNlKGZyYWdtZW50U3ByZWFkLmZyYWdtZW50TmFtZSksXG4gICAgICB0eXBlTmFtZTogaXNDb25kaXRpb25hbCA/IHN0cnVjdE5hbWUgKyAnPycgOiBzdHJ1Y3ROYW1lLFxuICAgICAgc3RydWN0TmFtZSxcbiAgICAgIGlzQ29uZGl0aW9uYWxcbiAgICB9KTtcbiAgfVxuXG4gIHByb3BlcnR5RnJvbUlucHV0RmllbGQoZmllbGQ6IEdyYXBoUUxJbnB1dEZpZWxkKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgIHByb3BlcnR5TmFtZTogY2FtZWxDYXNlKGZpZWxkLm5hbWUpLFxuICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWVGcm9tR3JhcGhRTFR5cGUoZmllbGQudHlwZSksXG4gICAgICBpc09wdGlvbmFsOiAhKGZpZWxkLnR5cGUgaW5zdGFuY2VvZiBHcmFwaFFMTm9uTnVsbCksXG4gICAgICBkZXNjcmlwdGlvbjogZmllbGQuZGVzY3JpcHRpb24gfHwgbnVsbCxcbiAgICAgIG5hbWU6IGZpZWxkLm5hbWUsXG4gICAgfSk7XG4gIH1cblxuICBwcm9wZXJ0aWVzRm9yU2VsZWN0aW9uU2V0KFxuICAgIHNlbGVjdGlvblNldDogU2VsZWN0aW9uU2V0LFxuICAgIG5hbWVzcGFjZT86IHN0cmluZ1xuICApOiAoRmllbGQgJiBQcm9wZXJ0eSlbXSB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IGNvbGxlY3RBbmRNZXJnZUZpZWxkcyhzZWxlY3Rpb25TZXQsIHRydWUpXG4gICAgICAuZmlsdGVyKGZpZWxkID0+IGZpZWxkLm5hbWUgIT09ICdfX3R5cGVuYW1lJylcbiAgICAgIC5tYXAoZmllbGQgPT4gdGhpcy5wcm9wZXJ0eUZyb21GaWVsZChmaWVsZCwgbmFtZXNwYWNlKSk7XG5cbiAgICAvLyBJZiB3ZSdyZSBub3QgbWVyZ2luZyBpbiBmaWVsZHMgZnJvbSBmcmFnbWVudCBzcHJlYWRzLCB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhlcmUgd2lsbCBhIGdlbmVyYXRlZFxuICAgIC8vIHR5cGUgZm9yIGEgY29tcG9zaXRlIGZpZWxkLCBzbyB0byBhdm9pZCBjb21waWxlciBlcnJvcnMgd2Ugc2tpcCB0aGUgaW5pdGlhbGl6ZXIgZm9yIG5vdy5cbiAgICBpZiAoXG4gICAgICBzZWxlY3Rpb25TZXQuc2VsZWN0aW9ucy5zb21lKHNlbGVjdGlvbiA9PiBzZWxlY3Rpb24ua2luZCA9PT0gJ0ZyYWdtZW50U3ByZWFkJykgJiZcbiAgICAgIHByb3BlcnRpZXMuc29tZShwcm9wZXJ0eSA9PiBpc0NvbXBvc2l0ZVR5cGUoZ2V0TmFtZWRUeXBlKHByb3BlcnR5LnR5cGUpKSlcbiAgICApIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gIH1cblxuICAvLyBFeHByZXNzaW9uc1xuXG4gIGRpY3Rpb25hcnlMaXRlcmFsRm9yRmllbGRBcmd1bWVudHMoYXJnczogQXJndW1lbnRbXSkge1xuICAgIGZ1bmN0aW9uIGV4cHJlc3Npb25Gcm9tVmFsdWUodmFsdWU6IGFueSk6IHN0cmluZyB7XG4gICAgICBpZiAodmFsdWUua2luZCA9PT0gJ1ZhcmlhYmxlJykge1xuICAgICAgICByZXR1cm4gYEdyYXBoUUxWYXJpYWJsZShcIiR7dmFsdWUudmFyaWFibGVOYW1lfVwiKWA7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB3cmFwKCdbJywgam9pbih2YWx1ZS5tYXAoZXhwcmVzc2lvbkZyb21WYWx1ZSksICcsICcpLCAnXScpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiB3cmFwKFxuICAgICAgICAgICdbJyxcbiAgICAgICAgICBqb2luKFxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBgXCIke2tleX1cIjogJHtleHByZXNzaW9uRnJvbVZhbHVlKHZhbHVlKX1gO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAnLCAnXG4gICAgICAgICAgKSB8fCAnOicsXG4gICAgICAgICAgJ10nXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB3cmFwKFxuICAgICAgJ1snLFxuICAgICAgam9pbihcbiAgICAgICAgYXJncy5tYXAoYXJnID0+IHtcbiAgICAgICAgICByZXR1cm4gYFwiJHthcmcubmFtZX1cIjogJHtleHByZXNzaW9uRnJvbVZhbHVlKGFyZy52YWx1ZSl9YDtcbiAgICAgICAgfSksXG4gICAgICAgICcsICdcbiAgICAgICkgfHwgJzonLFxuICAgICAgJ10nXG4gICAgKTtcbiAgfVxuXG4gIG1hcEV4cHJlc3Npb25Gb3JUeXBlKFxuICAgIHR5cGU6IEdyYXBoUUxUeXBlLFxuICAgIGV4cHJlc3Npb246IChpZGVudGlmaWVyOiBzdHJpbmcpID0+IHN0cmluZyxcbiAgICBpZGVudGlmaWVyID0gJydcbiAgKTogc3RyaW5nIHtcbiAgICBsZXQgaXNPcHRpb25hbDtcbiAgICBpZiAoaXNOb25OdWxsVHlwZSh0eXBlKSkge1xuICAgICAgaXNPcHRpb25hbCA9IGZhbHNlO1xuICAgICAgdHlwZSA9IHR5cGUub2ZUeXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc09wdGlvbmFsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNMaXN0VHlwZSh0eXBlKSkge1xuICAgICAgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIGAke2lkZW50aWZpZXJ9LmZsYXRNYXAgeyAkMC5tYXAgeyAke3RoaXMubWFwRXhwcmVzc2lvbkZvclR5cGUoXG4gICAgICAgICAgdHlwZS5vZlR5cGUsXG4gICAgICAgICAgZXhwcmVzc2lvbixcbiAgICAgICAgICAnJDAnXG4gICAgICAgICl9IH0gfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYCR7aWRlbnRpZmllcn0ubWFwIHsgJHt0aGlzLm1hcEV4cHJlc3Npb25Gb3JUeXBlKHR5cGUub2ZUeXBlLCBleHByZXNzaW9uLCAnJDAnKX0gfWA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc09wdGlvbmFsKSB7XG4gICAgICByZXR1cm4gYCR7aWRlbnRpZmllcn0uZmxhdE1hcCB7ICR7ZXhwcmVzc2lvbignJDAnKX0gfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBleHByZXNzaW9uKGlkZW50aWZpZXIpO1xuICAgIH1cbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==