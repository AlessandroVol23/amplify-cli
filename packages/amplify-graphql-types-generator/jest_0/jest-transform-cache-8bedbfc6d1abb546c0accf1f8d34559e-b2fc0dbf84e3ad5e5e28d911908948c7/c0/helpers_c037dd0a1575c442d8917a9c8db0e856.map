{"version":3,"sources":["helpers.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  GraphQLType,\n  GraphQLString,\n  GraphQLInt,\n  GraphQLFloat,\n  GraphQLBoolean,\n  GraphQLID,\n  GraphQLNonNull,\n  GraphQLScalarType,\n  GraphQLEnumType,\n  isCompositeType,\n  getNamedType,\n  GraphQLInputField,\n  isNonNullType,\n  isListType\n} from 'graphql';\n\nimport { camelCase, pascalCase } from 'change-case';\nimport * as Inflector from 'inflected';\nimport { join, wrap } from '../utilities/printing';\n\nimport { Property, Struct } from './language';\n\nimport { CompilerOptions, SelectionSet, Field, FragmentSpread, Argument } from '../compiler';\nimport { isMetaFieldName } from '../utilities/graphql';\nimport { Variant } from '../compiler/visitors/typeCase';\nimport { collectAndMergeFields } from '../compiler/visitors/collectAndMergeFields';\nimport { getTypeForAWSScalar } from './aws-scalar-helper';\n\nconst builtInScalarMap = {\n  [GraphQLString.name]: 'String',\n  [GraphQLInt.name]: 'Int',\n  [GraphQLFloat.name]: 'Double',\n  [GraphQLBoolean.name]: 'Bool',\n  [GraphQLID.name]: 'GraphQLID'\n};\n\nexport class Helpers {\n  constructor(public options: CompilerOptions) {}\n\n  // Types\n\n  typeNameFromGraphQLType(type: GraphQLType, unmodifiedTypeName?: string, isOptional?: boolean): string {\n    if (isNonNullType(type)) {\n      return this.typeNameFromGraphQLType(type.ofType, unmodifiedTypeName, false);\n    } else if (isOptional === undefined) {\n      isOptional = true;\n    }\n\n    let typeName;\n    if (isListType(type)) {\n      typeName = '[' + this.typeNameFromGraphQLType(type.ofType, unmodifiedTypeName) + ']';\n    } else if (type instanceof GraphQLScalarType) {\n      typeName = this.typeNameForScalarType(type);\n    } else {\n      typeName = unmodifiedTypeName || type.name;\n    }\n\n    return isOptional ? typeName + '?' : typeName;\n  }\n\n  typeNameForScalarType(type: GraphQLScalarType): string {\n    return (\n      builtInScalarMap[type.name] ||\n      (this.options.passthroughCustomScalars\n        ? this.options.customScalarsPrefix + type.name\n        : getTypeForAWSScalar(type) ? getTypeForAWSScalar(type): GraphQLString.name)\n    );\n  }\n\n  fieldTypeEnum(type: GraphQLType, structName: string): string {\n    if (isNonNullType(type)) {\n      return `.nonNull(${this.fieldTypeEnum(type.ofType, structName)})`;\n    } else if (isListType(type)) {\n      return `.list(${this.fieldTypeEnum(type.ofType, structName)})`;\n    } else if (type instanceof GraphQLScalarType) {\n      return `.scalar(${this.typeNameForScalarType(type)}.self)`;\n    } else if (type instanceof GraphQLEnumType) {\n      return `.scalar(${type.name}.self)`;\n    } else if (isCompositeType(type)) {\n      return `.object(${structName}.selections)`;\n    } else {\n      throw new Error(`Unknown field type: ${type}`);\n    }\n  }\n\n  // Names\n\n  enumCaseName(name: string) {\n    return camelCase(name);\n  }\n\n  enumDotCaseName(name: string) {\n    return `.${camelCase(name)}`;\n  }\n\n  operationClassName(name: string) {\n    return pascalCase(name);\n  }\n\n  structNameForPropertyName(propertyName: string) {\n    return pascalCase(Inflector.singularize(propertyName));\n  }\n\n  structNameForFragmentName(fragmentName: string) {\n    return pascalCase(fragmentName);\n  }\n\n  structNameForVariant(variant: SelectionSet) {\n    return 'As' + variant.possibleTypes.map(type => pascalCase(type.name)).join('Or');\n  }\n\n  // Properties\n\n  propertyFromField(field: Field, namespace?: string): Field & Property & Struct {\n    const { responseKey, isConditional } = field;\n\n    const propertyName = isMetaFieldName(responseKey) ? responseKey : camelCase(responseKey);\n\n    const structName = join([namespace, this.structNameForPropertyName(responseKey)], '.');\n\n    let type = field.type;\n\n    if (isConditional && isNonNullType(type)) {\n      type = type.ofType;\n    }\n\n    const isOptional = !(type instanceof GraphQLNonNull);\n\n    const unmodifiedType = getNamedType(field.type);\n\n    const unmodifiedTypeName = isCompositeType(unmodifiedType) ? structName : unmodifiedType.name;\n\n    const typeName = this.typeNameFromGraphQLType(type, unmodifiedTypeName);\n\n    return Object.assign({}, field, {\n      responseKey,\n      propertyName,\n      typeName,\n      structName,\n      isOptional\n    });\n  }\n\n  propertyFromVariant(variant: Variant): Variant & Property & Struct {\n    const structName = this.structNameForVariant(variant);\n\n    return Object.assign(variant, {\n      propertyName: camelCase(structName),\n      typeName: structName + '?',\n      structName\n    });\n  }\n\n  propertyFromFragmentSpread(\n    fragmentSpread: FragmentSpread,\n    isConditional: boolean\n  ): FragmentSpread & Property & Struct {\n    const structName = this.structNameForFragmentName(fragmentSpread.fragmentName);\n\n    return Object.assign({}, fragmentSpread, {\n      propertyName: camelCase(fragmentSpread.fragmentName),\n      typeName: isConditional ? structName + '?' : structName,\n      structName,\n      isConditional\n    });\n  }\n\n  propertyFromInputField(field: GraphQLInputField) {\n    return Object.assign({}, {\n      propertyName: camelCase(field.name),\n      typeName: this.typeNameFromGraphQLType(field.type),\n      isOptional: !(field.type instanceof GraphQLNonNull),\n      description: field.description || null,\n      name: field.name,\n    });\n  }\n\n  propertiesForSelectionSet(\n    selectionSet: SelectionSet,\n    namespace?: string\n  ): (Field & Property)[] | undefined {\n    const properties = collectAndMergeFields(selectionSet, true)\n      .filter(field => field.name !== '__typename')\n      .map(field => this.propertyFromField(field, namespace));\n\n    // If we're not merging in fields from fragment spreads, there is no guarantee there will a generated\n    // type for a composite field, so to avoid compiler errors we skip the initializer for now.\n    if (\n      selectionSet.selections.some(selection => selection.kind === 'FragmentSpread') &&\n      properties.some(property => isCompositeType(getNamedType(property.type)))\n    ) {\n      return undefined;\n    }\n\n    return properties;\n  }\n\n  // Expressions\n\n  dictionaryLiteralForFieldArguments(args: Argument[]) {\n    function expressionFromValue(value: any): string {\n      if (value.kind === 'Variable') {\n        return `GraphQLVariable(\"${value.variableName}\")`;\n      } else if (Array.isArray(value)) {\n        return wrap('[', join(value.map(expressionFromValue), ', '), ']');\n      } else if (typeof value === 'object') {\n        return wrap(\n          '[',\n          join(\n            Object.entries(value).map(([key, value]) => {\n              return `\"${key}\": ${expressionFromValue(value)}`;\n            }),\n            ', '\n          ) || ':',\n          ']'\n        );\n      } else {\n        return JSON.stringify(value);\n      }\n    }\n\n    return wrap(\n      '[',\n      join(\n        args.map(arg => {\n          return `\"${arg.name}\": ${expressionFromValue(arg.value)}`;\n        }),\n        ', '\n      ) || ':',\n      ']'\n    );\n  }\n\n  mapExpressionForType(\n    type: GraphQLType,\n    expression: (identifier: string) => string,\n    identifier = ''\n  ): string {\n    let isOptional;\n    if (isNonNullType(type)) {\n      isOptional = false;\n      type = type.ofType;\n    } else {\n      isOptional = true;\n    }\n\n    if (isListType(type)) {\n      if (isOptional) {\n        return `${identifier}.flatMap { $0.map { ${this.mapExpressionForType(\n          type.ofType,\n          expression,\n          '$0'\n        )} } }`;\n      } else {\n        return `${identifier}.map { ${this.mapExpressionForType(type.ofType, expression, '$0')} }`;\n      }\n    } else if (isOptional) {\n      return `${identifier}.flatMap { ${expression('$0')} }`;\n    } else {\n      return expression(identifier);\n    }\n  }\n}\n"],"sourceRoot":""}