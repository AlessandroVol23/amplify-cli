{"version":3,"sources":["loading.ts"],"names":[],"mappings":";;AAAA,MAAA,KAAA,QAAA,IAAA,CAAA;AAEA,MAAA,YAAA,QAAA,SAAA,CAAA;AASA,MAAA,WAAA,QAAA,UAAA,CAAA;AAEA,SAAA,UAAA,CAA2B,UAA3B,EAA6C;AAC3C,QAAI,CAAC,GAAG,UAAH,CAAc,UAAd,CAAL,EAAgC;AAC9B,cAAM,IAAI,SAAA,SAAJ,CAAc,oCAAoC,UAAU,EAA5D,CAAN;AACD;AACD,UAAM,aAAa,QAAQ,UAAR,CAAnB;AAEA,QAAI,CAAC,WAAW,IAAZ,IAAoB,CAAC,WAAW,QAApC,EAA8C;AAC5C,cAAM,IAAI,SAAA,SAAJ,CAAc,+EAAd,CAAN;AACD;AACD,WAAO,UAAA,iBAAA,CAAmB,WAAW,IAAZ,GAAoB,WAAW,IAA/B,GAAsC,UAAxD,CAAP;AACD;AAVD,QAAA,UAAA,GAAA,UAAA;AAYA,SAAA,6BAAA,CAAuC,OAAvC,EAAwD,UAAkB,KAA1E,EAA+E;AAC7E,UAAM,KAAK,IAAI,MAAJ,CAAW,UAAU,gBAArB,EAAuC,GAAvC,CAAX;AAEA,QAAI,KAAJ;AACA,UAAM,UAAU,EAAhB;AAEA,WAAM,QAAQ,GAAG,IAAH,CAAQ,OAAR,CAAd,EAAgC;AAC9B,cAAM,MAAM,MAAM,CAAN;AACT,eADS,CACD,YADC,EACa,EADb,CAAZ;AAGA,gBAAQ,IAAR,CAAa,GAAb;AACD;AAED,UAAM,MAAM,QAAQ,IAAR,CAAa,IAAb,CAAZ;AACA,WAAO,IAAI,MAAJ,GAAa,GAAb,GAAmB,IAA1B;AACD;AAED,SAAA,0BAAA,CAA2C,UAA3C,EAAiE,UAAkB,KAAnF,EAAwF;AACtF,UAAM,UAAU,WAAW,GAAX,CAAe,aAAY;AACzC,cAAM,OAAO,GAAG,YAAH,CAAgB,SAAhB,EAA2B,MAA3B,CAAb;AACA,YAAI,CAAC,IAAL,EAAW;AACT,mBAAO,IAAP;AACD;AAED,YAAI,UAAU,QAAV,CAAmB,MAAnB,KAA8B,UAAU,QAAV,CAAmB,KAAnB,CAA9B;AACC,kBAAU,QAAV,CAAmB,MAAnB,CADD,IAC+B,UAAU,QAAV,CAAmB,KAAnB,CADnC,EAEE;AACA,kBAAM,MAAM,8BAA8B,KAAK,QAAL,EAA9B,EAA+C,OAA/C,CAAZ;AACA,mBAAO,MAAM,IAAI,UAAA,MAAJ,CAAW,GAAX,EAAgB,SAAhB,CAAN,GAAmC,IAA1C;AACD;AAED,eAAO,IAAI,UAAA,MAAJ,CAAW,IAAX,EAAiB,SAAjB,CAAP;AACD,KAde,EAcb,MAda,CAcN,UAAU,MAdJ,CAAhB;AAgBA,WAAO,UAAA,SAAA,CAAW,QAAqB,GAArB,CAAyB,UAAU,UAAA,KAAA,CAAM,MAAN,CAAnC,CAAX,CAAP;AACD;AAlBD,QAAA,0BAAA,GAAA,0BAAA","sourcesContent":["import * as fs from 'fs'\n\nimport {\n  buildClientSchema,\n  Source,\n  concatAST,\n  parse,\n  DocumentNode,\n  GraphQLSchema\n} from 'graphql';\n\nimport { ToolError } from './errors'\n\nexport function loadSchema(schemaPath: string): GraphQLSchema {\n  if (!fs.existsSync(schemaPath)) {\n    throw new ToolError(`Cannot find GraphQL schema file: ${schemaPath}`);\n  }\n  const schemaData = require(schemaPath);\n\n  if (!schemaData.data && !schemaData.__schema) {\n    throw new ToolError('GraphQL schema file should contain a valid GraphQL introspection query result');\n  }\n  return buildClientSchema((schemaData.data) ? schemaData.data : schemaData);\n}\n\nfunction extractDocumentFromJavascript(content: string, tagName: string = 'gql'): string | null {\n  const re = new RegExp(tagName + '\\\\s*`([^`/]*)`', 'g');\n\n  let match\n  const matches = []\n\n  while(match = re.exec(content)) {\n    const doc = match[1]\n      .replace(/\\${[^}]*}/g, '')\n\n    matches.push(doc)\n  }\n\n  const doc = matches.join('\\n')\n  return doc.length ? doc : null;\n}\n\nexport function loadAndMergeQueryDocuments(inputPaths: string[], tagName: string = 'gql'): DocumentNode {\n  const sources = inputPaths.map(inputPath => {\n    const body = fs.readFileSync(inputPath, 'utf8');\n    if (!body) {\n      return null;\n    }\n\n    if (inputPath.endsWith('.jsx') || inputPath.endsWith('.js')\n      || inputPath.endsWith('.tsx') || inputPath.endsWith('.ts')\n    ) {\n      const doc = extractDocumentFromJavascript(body.toString(), tagName);\n      return doc ? new Source(doc, inputPath) : null;\n    }\n\n    return new Source(body, inputPath);\n  }).filter(source => source);\n\n  return concatAST((sources as Source[]).map(source => parse(source)));\n}\n"],"sourceRoot":""}