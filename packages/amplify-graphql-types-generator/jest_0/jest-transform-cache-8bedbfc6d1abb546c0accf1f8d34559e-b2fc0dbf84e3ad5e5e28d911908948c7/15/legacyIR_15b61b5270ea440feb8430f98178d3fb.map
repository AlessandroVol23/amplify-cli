{"version":3,"sources":["legacyIR.js"],"names":[],"mappings":"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","sourcesContent":["import { stripIndent } from 'common-tags'\n\nimport {\n  parse,\n  isType,\n  GraphQLID,\n  GraphQLString,\n  GraphQLList,\n  GraphQLNonNull\n} from 'graphql';\n\nimport { loadSchema } from '../../src/loading'\n\nimport { compileToLegacyIR } from '../../src/compiler/legacyIR'\nimport { serializeAST } from '../../src/serializeToJSON'\n\nfunction withStringifiedTypes(ir) {\n  return JSON.parse(serializeAST(ir));\n}\n\nconst schema = loadSchema(require.resolve('../fixtures/starwars/schema.json'));\n\ndescribe('Compiling query documents to the legacy IR', () => {\n  it(`should include variables defined in operations`, () => {\n    const document = parse(`\n      query HeroName($episode: Episode) {\n        hero(episode: $episode) {\n          name\n        }\n      }\n\n      query Search($text: String!) {\n        search(text: $text) {\n          ... on Character {\n            name\n          }\n        }\n      }\n\n      mutation CreateReviewForEpisode($episode: Episode!, $review: ReviewInput!) {\n        createReview(episode: $episode, review: $review) {\n          stars\n          commentary\n        }\n      }\n    `);\n\n    const { operations } = withStringifiedTypes(compileToLegacyIR(schema, document));\n\n    expect(operations['HeroName'].variables).toEqual(\n      [\n        { name: 'episode', type: 'Episode' }\n      ]\n    );\n\n    expect(operations['Search'].variables).toEqual(\n      [\n        { name: 'text', type: 'String!' }\n      ]\n    );\n\n    expect(operations['CreateReviewForEpisode'].variables).toEqual(\n      [\n        { name: 'episode', type: 'Episode!' },\n        { name: 'review', type: 'ReviewInput!' }\n      ]\n    );\n  });\n\n  it(`should keep track of enums and input object types used in variables`, () => {\n    const document = parse(`\n      query HeroName($episode: Episode) {\n        hero(episode: $episode) {\n          name\n        }\n      }\n\n      query Search($text: String) {\n        search(text: $text) {\n          ... on Character {\n            name\n          }\n        }\n      }\n\n      mutation CreateReviewForEpisode($episode: Episode!, $review: ReviewInput!) {\n        createReview(episode: $episode, review: $review) {\n          stars\n          commentary\n        }\n      }\n    `);\n\n    const { typesUsed } = withStringifiedTypes(compileToLegacyIR(schema, document));\n\n    expect(typesUsed).toEqual(['Episode', 'ReviewInput', 'ColorInput']);\n  });\n\n  it(`should keep track of enums used in fields`, () => {\n    const document = parse(`\n      query Hero {\n        hero {\n          name\n          appearsIn\n        }\n\n        droid(id: \"2001\") {\n          appearsIn\n        }\n      }\n    `);\n\n    const { typesUsed } = withStringifiedTypes(compileToLegacyIR(schema, document));\n\n    expect(typesUsed).toEqual(['Episode']);\n  });\n\n  it(`should keep track of types used in fields of input objects`, () => {\n    const document = parse(`\n      mutation FieldArgumentsWithInputObjects($review: ReviewInput!) {\n        createReview(episode: JEDI, review: $review) {\n          commentary\n        }\n      }\n      `);\n\n    const { typesUsed } = withStringifiedTypes(compileToLegacyIR(schema, document));\n\n    expect(typesUsed).toContain('ReviewInput');\n    expect(typesUsed).toContain('ColorInput');\n  });\n\n  it(`should include the original field name for an aliased field`, () => {\n    const document = parse(`\n      query HeroName {\n        r2: hero {\n          name\n        }\n        luke: hero(episode: EMPIRE) {\n          name\n        }\n      }\n    `);\n\n    const { operations } = compileToLegacyIR(schema, document);\n\n    expect(operations['HeroName'].fields[0].fieldName).toBe(\"hero\");\n  });\n\n  it(`should include field arguments`, () => {\n    const document = parse(`\n      query HeroName {\n        hero(episode: EMPIRE) {\n          name\n        }\n      }\n    `);\n\n    const { operations } = compileToLegacyIR(schema, document);\n\n    expect(operations['HeroName'].fields[0].args)\n      .toEqual([{ name: \"episode\", value: \"EMPIRE\", type: schema.getType(\"Episode\") }]);\n  });\n\n  it(`should include isConditional if a field has skip or include directives with variables`, () => {\n    const document = parse(`\n      query HeroNameConditionalInclusion($includeName: Boolean!) {\n        hero {\n          name @include(if: $includeName)\n        }\n      }\n\n      query HeroNameConditionalExclusion($skipName: Boolean!) {\n        hero {\n          name @skip(if: $skipName)\n        }\n      }\n    `);\n\n    const { operations } = compileToLegacyIR(schema, document);\n\n    expect(operations['HeroNameConditionalInclusion'].fields[0].fields[0]).toMatchObject({\n      fieldName: 'name',\n      isConditional: true\n    });\n\n    expect(operations['HeroNameConditionalExclusion'].fields[0].fields[0]).toMatchObject({\n      fieldName: 'name',\n      isConditional: true\n    });\n  });\n\n  it(`should not include isConditional if a field has skip or include directives with a boolean literal that always passes`, () => {\n    const document = parse(`\n      query HeroNameConditionalInclusion {\n        hero {\n          name @include(if: true)\n        }\n      }\n\n      query HeroNameConditionalExclusion {\n        hero {\n          name @skip(if: false)\n        }\n      }\n    `);\n\n    const { operations } = compileToLegacyIR(schema, document);\n\n    expect(operations['HeroNameConditionalInclusion'].fields[0].fields[0]).toMatchObject({\n      fieldName: 'name',\n      isConditional: false\n    });\n\n    expect(operations['HeroNameConditionalExclusion'].fields[0].fields[0]).toMatchObject({\n      fieldName: 'name',\n      isConditional: false\n    });\n  });\n\n  it(`should not include field if it has skip or include directives with a boolean literal that always fails`, () => {\n    const document = parse(`\n      query HeroNameConditionalInclusion {\n        hero {\n          name @include(if: false)\n        }\n      }\n\n      query HeroNameConditionalExclusion {\n        hero {\n          name @skip(if: true)\n        }\n      }\n    `);\n\n    const { operations } = compileToLegacyIR(schema, document);\n\n    expect(operations['HeroNameConditionalInclusion'].fields[0].fields).toHaveLength(0);\n    expect(operations['HeroNameConditionalExclusion'].fields[0].fields).toHaveLength(0);\n  });\n\n    it(`should include isConditional if a field in inside an inline fragment with skip or include directives with variables`, () => {\n    const document = parse(`\n      query HeroNameConditionalInclusion($includeName: Boolean!) {\n        hero {\n          ... @include(if: $includeName) {\n            name\n          }\n        }\n      }\n\n      query HeroNameConditionalExclusion($skipName: Boolean!) {\n        hero {\n          ... @skip(if: $skipName) {\n            name\n          }\n        }\n      }\n    `);\n\n    const { operations } = compileToLegacyIR(schema, document);\n\n    expect(operations['HeroNameConditionalInclusion'].fields[0].fields[0]).toMatchObject({\n      fieldName: 'name',\n      isConditional: true\n    });\n\n    expect(operations['HeroNameConditionalExclusion'].fields[0].fields[0]).toMatchObject({\n      fieldName: 'name',\n      isConditional: true\n    });\n  });\n\n  it(`should include isConditional if a field in inside a fragment spread with skip or include directives with variables`, () => {\n    const document = parse(`\n      query HeroNameConditionalInclusion($includeName: Boolean!) {\n        hero {\n          ...HeroName @include(if: $includeName)\n        }\n      }\n\n      query HeroNameConditionalExclusion($skipName: Boolean!) {\n        hero {\n          ...HeroName @skip(if: $skipName)\n        }\n      }\n\n      fragment HeroName on Character {\n        name\n      }\n    `);\n\n    const { operations } = compileToLegacyIR(schema, document);\n\n    expect(operations['HeroNameConditionalInclusion'].fields[0].fields[0]).toMatchObject({\n      fieldName: 'name',\n      isConditional: true\n    });\n\n    expect(operations['HeroNameConditionalExclusion'].fields[0].fields[0]).toMatchObject({\n      fieldName: 'name',\n      isConditional: true\n    });\n\n    expect(operations['HeroNameConditionalInclusion'].fragmentsReferenced).toEqual(['HeroName']);\n    expect(operations['HeroNameConditionalInclusion'].fields[0].fragmentSpreads).toEqual(['HeroName']);\n\n    expect(operations['HeroNameConditionalExclusion'].fragmentsReferenced).toEqual(['HeroName']);\n    expect(operations['HeroNameConditionalExclusion'].fields[0].fragmentSpreads).toEqual(['HeroName']);\n  });\n\n  it(`should recursively flatten inline fragments with type conditions that match the parent type`, () => {\n    const document = parse(`\n      query Hero {\n        hero {\n          id\n          ... on Character {\n            name\n            ... on Character {\n              id\n              appearsIn\n            }\n            id\n          }\n        }\n      }\n    `);\n\n    const { operations } = compileToLegacyIR(schema, document);\n\n    expect(operations['Hero'].fields[0].fields.map(field => field.fieldName))\n      .toEqual(['id', 'name', 'appearsIn']);\n  });\n\n  it(`should recursively include fragment spreads with type conditions that match the parent type`, () => {\n    const document = parse(`\n      query Hero {\n        hero {\n          id\n          ...HeroDetails\n        }\n      }\n\n      fragment HeroDetails on Character {\n        name\n        ...MoreHeroDetails\n        id\n      }\n\n      fragment MoreHeroDetails on Character {\n        appearsIn\n      }\n    `);\n\n    const { operations, fragments } = compileToLegacyIR(schema, document);\n\n    expect(operations['Hero'].fields[0].fields.map(field => field.fieldName))\n      .toEqual(['id', 'name', 'appearsIn']);\n\n    expect(fragments['HeroDetails'].fields.map(field => field.fieldName))\n      .toEqual(['name', 'appearsIn', 'id']);\n\n    expect(fragments['MoreHeroDetails'].fields.map(field => field.fieldName))\n      .toEqual(['appearsIn']);\n\n    expect(operations['Hero'].fragmentsReferenced).toEqual(['HeroDetails', 'MoreHeroDetails']);\n    expect(operations['Hero'].fields[0].fragmentSpreads).toEqual(['HeroDetails']);\n    expect(fragments['HeroDetails'].fragmentSpreads).toEqual(['MoreHeroDetails']);\n  });\n\n  it(`should include fragment spreads from subselections`, () => {\n    const document = parse(`\n      query HeroAndFriends {\n        hero {\n          ...HeroDetails\n          appearsIn\n          id\n          friends {\n            id\n            ...HeroDetails\n          }\n        }\n      }\n\n      fragment HeroDetails on Character {\n      \tname\n        id\n      }\n    `);\n\n    const { operations, fragments } = compileToLegacyIR(schema, document);\n\n    expect(operations['HeroAndFriends'].fields[0].fields.map(field => field.fieldName))\n      .toEqual(['name', 'id', 'appearsIn', 'friends']);\n    expect(operations['HeroAndFriends'].fields[0].fields[3].fields.map(field => field.fieldName))\n      .toEqual(['id', 'name']);\n\n    expect(fragments['HeroDetails'].fields.map(field => field.fieldName))\n      .toEqual(['name', 'id']);\n\n    expect(operations['HeroAndFriends'].fragmentsReferenced).toEqual(['HeroDetails']);\n    expect(operations['HeroAndFriends'].fields[0].fragmentSpreads).toEqual(['HeroDetails']);\n  });\n\n  it(`should include type conditions with merged fields for inline fragments`, () => {\n    const document = parse(`\n      query Hero {\n        hero {\n          name\n          ... on Droid {\n            primaryFunction\n          }\n          ... on Human {\n            height\n          }\n        }\n      }\n    `);\n\n    const { operations } = compileToLegacyIR(schema, document);\n\n    expect(operations['Hero'].fields[0].fields.map(field => field.fieldName))\n      .toEqual(['name']);\n\n      return;\n\n    expect(operations['Hero'].fields[0].inlineFragments[\"Droid\"].typeCondition.toString()).toEqual('Droid');\n    expect(operations['Hero'].fields[0].inlineFragments[\"Droid\"].fields.map(field => field.fieldName))\n        .toEqual(['name', 'primaryFunction']);\n\n    expect(operations['Hero'].fields[0].inlineFragments[\"Human\"].typeCondition.toString()).toEqual('Human');\n    expect(operations['Hero'].fields[0].inlineFragments[\"Human\"].fields.map(field => field.fieldName))\n        .toEqual(['name', 'height']);\n  });\n\n  it(`should include fragment spreads with type conditions`, () => {\n    const document = parse(`\n      query Hero {\n        hero {\n          name\n          ...DroidDetails\n          ...HumanDetails\n        }\n      }\n\n      fragment DroidDetails on Droid {\n        primaryFunction\n      }\n\n      fragment HumanDetails on Human {\n        height\n      }\n    `);\n\n    const { operations, fragments } = compileToLegacyIR(schema, document);\n\n    expect(operations['Hero'].fields[0].fields.map(field => field.fieldName))\n      .toEqual(['name']);\n\n    expect(operations['Hero'].fields[0].inlineFragments[\"Droid\"].typeCondition.toString()).toEqual('Droid');\n    expect(operations['Hero'].fields[0].inlineFragments[\"Droid\"].fields.map(field => field.fieldName))\n        .toEqual(['name', 'primaryFunction']);\n\n    expect(operations['Hero'].fields[0].inlineFragments['Human'].typeCondition.toString()).toEqual('Human');\n    expect(operations['Hero'].fields[0].inlineFragments['Human'].fields.map(field => field.fieldName))\n        .toEqual(['name', 'height']);\n\n    expect(operations['Hero'].fragmentsReferenced).toEqual(['DroidDetails', 'HumanDetails']);\n    expect(operations['Hero'].fields[0].fragmentSpreads).toEqual(['DroidDetails', 'HumanDetails']);\n  });\n\n  it(`should not include type conditions for fragment spreads with type conditions that match the parent type`, () => {\n    const document = parse(`\n      query Hero {\n        hero {\n          name\n          ...HeroDetails\n        }\n      }\n\n      fragment HeroDetails on Character {\n        name\n      }\n    `);\n\n    const { operations } = compileToLegacyIR(schema, document);\n\n    expect(operations['Hero'].fields[0].fields.map(field => field.fieldName))\n    .toEqual(['name']);\n    expect(operations['Hero'].fields[0].inlineFragments).toEqual([]);\n  });\n\n  it(`should include type conditions for inline fragments in fragments`, () => {\n    const document = parse(`\n      query Hero {\n        hero {\n          ...HeroDetails\n        }\n      }\n\n      fragment HeroDetails on Character {\n        name\n        ... on Droid {\n          primaryFunction\n        }\n        ... on Human {\n          height\n        }\n      }\n    `);\n\n    const { operations, fragments } = compileToLegacyIR(schema, document);\n\n    expect(operations['Hero'].fields[0].fields.map(field => field.fieldName))\n      .toEqual(['name']);\n\n    expect(operations['Hero'].fields[0].inlineFragments['Droid'].typeCondition.toString()).toEqual('Droid');\n    expect(operations['Hero'].fields[0].inlineFragments['Droid'].fields.map(field => field.fieldName))\n        .toEqual(['name', 'primaryFunction']);\n\n    expect(operations['Hero'].fields[0].inlineFragments['Human'].typeCondition.toString()).toEqual('Human');\n    expect(operations['Hero'].fields[0].inlineFragments['Human'].fields.map(field => field.fieldName))\n        .toEqual(['name', 'height']);\n\n    expect(operations['Hero'].fragmentsReferenced).toEqual(['HeroDetails']);\n    expect(operations['Hero'].fields[0].fragmentSpreads).toEqual(['HeroDetails']);\n  });\n\n  it(`should inherit type condition when nesting an inline fragment in an inline fragment with a more specific type condition`, () => {\n    const document = parse(`\n      query HeroName {\n        hero {\n          ... on Droid {\n            ... on Character {\n              name\n            }\n          }\n        }\n      }\n    `);\n\n    const { operations } = compileToLegacyIR(schema, document);\n\n    expect(operations['HeroName'].fields[0].fields.map(field => field.fieldName))\n      .toEqual([]);\n    expect(operations['HeroName'].fields[0].inlineFragments['Droid'].typeCondition.toString()).toEqual('Droid');\n    expect(operations['HeroName'].fields[0].inlineFragments['Droid'].fields.map(field => field.fieldName))\n      .toEqual(['name']);\n  });\n\n  it(`should not inherit type condition when nesting an inline fragment in an inline fragment with a less specific type condition`, () => {\n    const document = parse(`\n      query HeroName {\n        hero {\n          ... on Character {\n            ... on Droid {\n              name\n            }\n          }\n        }\n      }\n    `);\n\n    const { operations } = compileToLegacyIR(schema, document);\n\n    expect(operations['HeroName'].fields[0].fields.map(field => field.fieldName))\n      .toEqual([]);\n    expect(operations['HeroName'].fields[0].inlineFragments['Droid'].typeCondition.toString()).toEqual('Droid');\n    expect(operations['HeroName'].fields[0].inlineFragments['Droid'].fields.map(field => field.fieldName))\n      .toEqual(['name']);\n  });\n\n  it(`should inherit type condition when nesting a fragment spread in an inline fragment with a more specific type condition`, () => {\n    const document = parse(`\n      query HeroName {\n        hero {\n          ... on Droid {\n            ...CharacterName\n          }\n        }\n      }\n\n      fragment CharacterName on Character {\n        name\n      }\n    `);\n\n    const { operations } = compileToLegacyIR(schema, document);\n\n    expect(operations['HeroName'].fields[0].fields.map(field => field.fieldName))\n      .toEqual([]);\n    expect(operations['HeroName'].fields[0].inlineFragments[\"Droid\"].typeCondition.toString()).toEqual('Droid');\n    expect(operations['HeroName'].fields[0].inlineFragments[\"Droid\"].fields.map(field => field.fieldName))\n      .toEqual(['name']);\n    expect(operations['HeroName'].fields[0].inlineFragments[\"Droid\"].fragmentSpreads).toEqual(['CharacterName']);\n\n    expect(operations['HeroName'].fragmentsReferenced).toEqual(['CharacterName']);\n    expect(operations['HeroName'].fields[0].fragmentSpreads).toEqual([]);\n  });\n\n  it(`should not inherit type condition when nesting a fragment spread in an inline fragment with a less specific type condition`, () => {\n    const document = parse(`\n      query HeroName {\n        hero {\n          ... on Character {\n            ...DroidName\n          }\n        }\n      }\n\n      fragment DroidName on Droid {\n        name\n      }\n    `);\n\n    const { operations } = compileToLegacyIR(schema, document);\n\n    expect(operations['HeroName'].fields[0].fields.map(field => field.fieldName))\n      .toEqual([]);\n    expect(operations['HeroName'].fields[0].inlineFragments[\"Droid\"].typeCondition.toString()).toEqual('Droid');\n    expect(operations['HeroName'].fields[0].inlineFragments[\"Droid\"].fields.map(field => field.fieldName))\n      .toEqual(['name']);\n    expect(operations['HeroName'].fields[0].inlineFragments[\"Droid\"].fragmentSpreads).toEqual(['DroidName']);\n    expect(operations['HeroName'].fragmentsReferenced).toEqual(['DroidName']);\n    expect(operations['HeroName'].fields[0].fragmentSpreads).toEqual(['DroidName']);\n  });\n\n  it(`should ignore inline fragment when the type condition does not overlap with the currently effective type`, () => {\n    const document = parse(`\n      fragment CharacterDetails on Character {\n        ... on Droid {\n          primaryFunction\n        }\n        ... on Human {\n          height\n        }\n      }\n\n      query HumanAndDroid {\n        human(id: \"human\") {\n          ...CharacterDetails\n        }\n        droid(id: \"droid\") {\n          ...CharacterDetails\n        }\n      }\n    `);\n\n    const { operations } = compileToLegacyIR(schema, document);\n\n    expect(operations['HumanAndDroid'].fields.map(field => field.fieldName))\n      .toEqual(['human', 'droid']);\n    expect(operations['HumanAndDroid'].fields[0].fields.map(field => field.fieldName))\n      .toEqual(['height']);\n    expect(operations['HumanAndDroid'].fields[0].inlineFragments).toEqual([]);\n    expect(operations['HumanAndDroid'].fields[1].fields.map(field => field.fieldName))\n      .toEqual(['primaryFunction']);\n    expect(operations['HumanAndDroid'].fields[1].inlineFragments).toEqual([]);\n  });\n\n  it(`should ignore fragment spread when the type condition does not overlap with the currently effective type`, () => {\n    const document = parse(`\n      fragment DroidPrimaryFunction on Droid {\n        primaryFunction\n      }\n\n      fragment HumanHeight on Human {\n        height\n      }\n\n      fragment CharacterDetails on Character {\n        ...DroidPrimaryFunction\n        ...HumanHeight\n      }\n\n      query HumanAndDroid {\n        human(id: \"human\") {\n          ...CharacterDetails\n        }\n        droid(id: \"droid\") {\n          ...CharacterDetails\n        }\n      }\n    `);\n\n    const { operations } = compileToLegacyIR(schema, document);\n\n    expect(operations['HumanAndDroid'].fields.map(field => field.fieldName))\n      .toEqual(['human', 'droid']);\n    expect(operations['HumanAndDroid'].fields[0].fields.map(field => field.fieldName))\n      .toEqual(['height']);\n    expect(operations['HumanAndDroid'].fields[0].inlineFragments).toEqual([]);\n    expect(operations['HumanAndDroid'].fields[1].fields.map(field => field.fieldName))\n      .toEqual(['primaryFunction']);\n    expect(operations['HumanAndDroid'].fields[1].inlineFragments).toEqual([]);\n  });\n\n  it(`should include type conditions for inline fragments on a union type`, () => {\n    const document = parse(`\n      query Search {\n        search(text: \"an\") {\n          ... on Character {\n            name\n          }\n          ... on Droid {\n            primaryFunction\n          }\n          ... on Human {\n            height\n          }\n        }\n      }\n    `);\n\n    const { operations } = compileToLegacyIR(schema, document);\n\n    expect(operations['Search'].fields[0].fields.map(field => field.fieldName))\n      .toEqual([]);\n\n    expect(operations['Search'].fields[0].inlineFragments[\"Droid\"].typeCondition.toString()).toEqual('Droid');\n    expect(operations['Search'].fields[0].inlineFragments[\"Droid\"].fields.map(field => field.fieldName))\n      .toEqual(['name', 'primaryFunction']);\n\n    expect(operations['Search'].fields[0].inlineFragments[\"Human\"].typeCondition.toString()).toEqual('Human');\n    expect(operations['Search'].fields[0].inlineFragments[\"Human\"].fields.map(field => field.fieldName))\n      .toEqual(['name', 'height']);\n  });\n\n  it(`should keep correct field ordering even if fragment is visited multiple times`, () => {\n    const document = parse(`\n      query Hero {\n        hero {\n          ...HeroName\n          appearsIn\n          ...HeroName\n        }\n      }\n\n      fragment HeroName on Character {\n        name\n      }\n    `);\n\n    const { operations } = compileToLegacyIR(schema, document);\n\n    expect(operations['Hero'].fields[0].fields.map(field => field.fieldName))\n      .toEqual(['name', 'appearsIn']);\n  });\n\n  it(`should keep correct field ordering even if field has been visited before for other type condition`, () => {\n    const document = parse(`\n      fragment HeroDetails on Character {\n        ... on Human {\n          appearsIn\n        }\n\n        ... on Droid {\n          name\n          appearsIn\n        }\n      }\n    `);\n\n    const { fragments } = compileToLegacyIR(schema, document);\n\n    expect(fragments['HeroDetails'].inlineFragments['Droid'].typeCondition.toString()).toEqual('Droid');\n    expect(fragments['HeroDetails'].inlineFragments['Droid'].fields.map(field => field.fieldName))\n      .toEqual(['name', 'appearsIn']);\n  });\n\n  it(`should keep track of fragments referenced in a subselection`, () => {\n    const document = parse(`\n      query HeroAndFriends {\n        hero {\n          name\n          friends {\n            ...HeroDetails\n          }\n        }\n      }\n\n      fragment HeroDetails on Character {\n        name\n      }\n    `);\n\n    const { operations } = compileToLegacyIR(schema, document);\n\n    expect(operations['HeroAndFriends'].fragmentsReferenced).toEqual(['HeroDetails']);\n  });\n\n  it(`should keep track of fragments referenced in a fragment within a subselection`, () => {\n    const document = parse(`\n      query HeroAndFriends {\n        hero {\n          ...HeroDetails\n        }\n      }\n\n      fragment HeroDetails on Character {\n        friends {\n          ...HeroName\n        }\n      }\n\n      fragment HeroName on Character {\n        name\n      }\n    `);\n\n    const { operations } = compileToLegacyIR(schema, document);\n\n    expect(operations['HeroAndFriends'].fragmentsReferenced).toEqual(['HeroDetails', 'HeroName']);\n  });\n\n  it(`should keep track of fragments referenced in a subselection nested in an inline fragment`, () => {\n    const document = parse(`\n      query HeroAndFriends {\n        hero {\n          name\n          ... on Droid {\n            friends {\n              ...HeroDetails\n            }\n          }\n        }\n      }\n\n      fragment HeroDetails on Character {\n        name\n      }\n    `);\n\n    const { operations } = compileToLegacyIR(schema, document);\n\n    expect(operations['HeroAndFriends'].fragmentsReferenced).toEqual(['HeroDetails']);\n  });\n\n  describe(\"with mergeInFieldsFromFragmentSpreads set to false\", () => {\n    it(`should not morge fields from recursively included fragment spreads with type conditions that match the parent type`, () => {\n      const document = parse(`\n        query Hero {\n          hero {\n            id\n            ...HeroDetails\n          }\n        }\n\n        fragment HeroDetails on Character {\n          name\n          ...MoreHeroDetails\n          id\n        }\n\n        fragment MoreHeroDetails on Character {\n          appearsIn\n        }\n      `);\n\n      const { operations, fragments } = compileToLegacyIR(schema, document, { mergeInFieldsFromFragmentSpreads: false });\n\n      expect(operations['Hero'].fields[0].fields.map(field => field.fieldName))\n        .toEqual(['id']);\n\n      expect(fragments['HeroDetails'].fields.map(field => field.fieldName))\n        .toEqual(['name', 'id']);\n\n      expect(fragments['MoreHeroDetails'].fields.map(field => field.fieldName))\n        .toEqual(['appearsIn']);\n\n      expect(operations['Hero'].fragmentsReferenced).toEqual(['HeroDetails', 'MoreHeroDetails']);\n      expect(operations['Hero'].fields[0].fragmentSpreads).toEqual(['HeroDetails']);\n      expect(fragments['HeroDetails'].fragmentSpreads).toEqual(['MoreHeroDetails']);\n    });\n\n    it(`should not merge fields from fragment spreads from subselections`, () => {\n      const document = parse(`\n        query HeroAndFriends {\n          hero {\n            ...HeroDetails\n            appearsIn\n            id\n            friends {\n              id\n              ...HeroDetails\n            }\n          }\n        }\n\n        fragment HeroDetails on Character {\n          name\n          id\n        }\n      `);\n\n      const { operations, fragments } = compileToLegacyIR(schema, document, { mergeInFieldsFromFragmentSpreads: false });\n\n      expect(operations['HeroAndFriends'].fields[0].fields.map(field => field.fieldName))\n        .toEqual(['appearsIn', 'id','friends']);\n      expect(operations['HeroAndFriends'].fields[0].fields[2].fields.map(field => field.fieldName))\n        .toEqual(['id']);\n\n      expect(fragments['HeroDetails'].fields.map(field => field.fieldName))\n        .toEqual(['name', 'id']);\n\n      expect(operations['HeroAndFriends'].fragmentsReferenced).toEqual(['HeroDetails']);\n      expect(operations['HeroAndFriends'].fields[0].fragmentSpreads).toEqual(['HeroDetails']);\n    });\n\n    it(`should not merge fields from fragment spreads with type conditions`, () => {\n      const document = parse(`\n        query Hero {\n          hero {\n            name\n            ...DroidDetails\n            ...HumanDetails\n          }\n        }\n\n        fragment DroidDetails on Droid {\n          primaryFunction\n        }\n\n        fragment HumanDetails on Human {\n          height\n        }\n      `);\n\n      const { operations, fragments } = compileToLegacyIR(schema, document, { mergeInFieldsFromFragmentSpreads: false });\n\n      expect(operations['Hero'].fields[0].fields.map(field => field.fieldName))\n        .toEqual(['name']);\n\n      expect(operations['Hero'].fields[0].inlineFragment).toBeUndefined();\n\n      expect(operations['Hero'].fragmentsReferenced).toEqual(['DroidDetails', 'HumanDetails']);\n      expect(operations['Hero'].fields[0].fragmentSpreads).toEqual(['DroidDetails', 'HumanDetails']);\n    });\n  });\n\n  it(`should include the source of operations`, () => {\n    const source = stripIndent`\n      query HeroName {\n        hero {\n          name\n        }\n      }\n    `\n    const document = parse(source);\n\n    const { operations } = compileToLegacyIR(schema, document);\n\n    expect(operations['HeroName'].source).toBe(source);\n  });\n\n  it(`should include the source of fragments`, () => {\n    const source = stripIndent`\n      fragment HeroDetails on Character {\n        name\n      }\n    `\n    const document = parse(source);\n\n    const { fragments } = compileToLegacyIR(schema, document);\n\n    expect(fragments['HeroDetails'].source).toBe(source);\n  });\n\n  it(`should include the source of operations with __typename added when addTypename is true`, () => {\n    const source = stripIndent`\n      query HeroName {\n        hero {\n          name\n        }\n      }\n    `\n    const document = parse(source);\n\n    const { operations } = compileToLegacyIR(schema, document, { addTypename: true });\n\n    expect(operations['HeroName'].source).toBe(stripIndent`\n      query HeroName {\n        hero {\n          __typename\n          name\n        }\n      }\n    `);\n  });\n\n  it(`should include the source of fragments with __typename added when addTypename is true`, () => {\n    const source = stripIndent`\n      fragment HeroDetails on Character {\n        name\n      }\n    `\n    const document = parse(source);\n\n    const { fragments } = compileToLegacyIR(schema, document, { addTypename: true });\n\n    expect(fragments['HeroDetails'].source).toBe(stripIndent`\n      fragment HeroDetails on Character {\n        __typename\n        name\n      }\n    `);\n  });\n\n  it(`should include the operationType for a query`, () => {\n    const source = stripIndent`\n      query HeroName {\n        hero {\n          name\n        }\n      }\n    `\n    const document = parse(source);\n\n    const { operations } = compileToLegacyIR(schema, document);\n\n    expect(operations['HeroName'].operationType).toBe('query');\n  });\n\n  it(`should include the operationType for a mutation`, () => {\n    const source = stripIndent`\n      mutation CreateReview {\n        createReview {\n          stars\n          commentary\n        }\n      }\n    `\n    const document = parse(source);\n\n    const { operations } = compileToLegacyIR(schema, document);\n\n    expect(operations['CreateReview'].operationType).toBe('mutation');\n  });\n});\n"],"sourceRoot":""}