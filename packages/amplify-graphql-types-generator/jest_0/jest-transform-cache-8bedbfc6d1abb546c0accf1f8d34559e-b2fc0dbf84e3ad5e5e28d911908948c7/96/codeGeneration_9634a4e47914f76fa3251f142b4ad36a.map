{"version":3,"sources":["codeGeneration.js"],"names":[],"mappings":"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","sourcesContent":["import {\n  GraphQLError,\n  getNamedType,\n  isCompositeType,\n  isAbstractType,\n  isEqualType,\n  GraphQLScalarType,\n  GraphQLEnumType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLID,\n  GraphQLInputObjectType,\n  GraphQLObjectType,\n  GraphQLUnionType\n} from 'graphql'\n\nimport  { isTypeProperSuperTypeOf } from '../utilities/graphql';\n\nimport * as Inflector from 'inflected';\n\nimport {\n  join,\n  wrap,\n} from '../utilities/printing';\n\nimport CodeGenerator from '../utilities/CodeGenerator';\n\nimport {\n  typeDeclaration,\n  propertyDeclaration,\n  propertySetsDeclaration\n} from './language';\n\nimport {\n  typeNameFromGraphQLType,\n} from './types';\n\nexport function generateSource(context) {\n  const generator = new CodeGenerator(context);\n\n  generator.printOnNewline('/* @flow */');\n  generator.printOnNewline('/* eslint-disable */');\n  generator.printOnNewline('//  This file was automatically generated and should not be edited.');\n  typeDeclarationForGraphQLType(context.typesUsed.forEach(type =>\n    typeDeclarationForGraphQLType(generator, type)\n  ));\n  Object.values(context.operations).forEach(operation => {\n    interfaceVariablesDeclarationForOperation(generator, operation);\n    typeDeclarationForOperation(generator, operation);\n  });\n  Object.values(context.fragments).forEach(fragment => {\n    typeDeclarationForFragment(generator, fragment)\n  });\n\n  return generator.output;\n}\n\nexport function typeDeclarationForGraphQLType(generator, type) {\n  if (type instanceof GraphQLEnumType) {\n    enumerationDeclaration(generator, type);\n  } else if (type instanceof GraphQLInputObjectType) {\n    structDeclarationForInputObjectType(generator, type);\n  }\n}\n\nfunction enumerationDeclaration(generator, type) {\n  const { name, description } = type;\n  const values = type.getValues();\n\n  generator.printNewlineIfNeeded();\n  if (description) {\n    description.split('\\n')\n      .forEach(line => {\n        generator.printOnNewline(`// ${line.trim()}`);\n      })\n  }\n  generator.printOnNewline(`export type ${name} =`);\n  const nValues = values.length;\n  values.forEach((value, i) => {\n    if (!value.description || value.description.indexOf('\\n') === -1) {\n      generator.printOnNewline(`  \"${value.value}\"${i === nValues - 1 ? ';' : ' |'}${wrap(' // ', value.description)}`)\n    } else {\n      if (value.description) {\n        value.description.split('\\n')\n          .forEach(line => {\n            generator.printOnNewline(`  // ${line.trim()}`);\n          })\n      }\n      generator.printOnNewline(`  \"${value.value}\"${i === nValues - 1 ? ';' : ' |'}`)\n    }\n  });\n  generator.printNewline();\n}\n\nfunction structDeclarationForInputObjectType(\n  generator,\n  type\n) {\n  const interfaceName = type.name;\n  typeDeclaration(generator, {\n    interfaceName,\n  }, () => {\n    const properties = propertiesFromFields(generator.context, Object.values(type.getFields()));\n    propertyDeclarations(generator, properties, true);\n  });\n}\n\nfunction interfaceNameFromOperation({operationName, operationType}) {\n  switch (operationType) {\n    case 'query':\n      return `${operationName}Query`;\n      break;\n    case 'mutation':\n      return `${operationName}Mutation`;\n      break;\n    case 'subscription':\n      return `${operationName}Subscription`;\n      break;\n    default:\n      throw new GraphQLError(`Unsupported operation type \"${operationType}\"`);\n  }\n}\n\nexport function interfaceVariablesDeclarationForOperation(\n  generator,\n  {\n    operationName,\n    operationType,\n    variables,\n    fields,\n    fragmentsReferenced,\n    source,\n  }\n) {\n  if (!variables || variables.length < 1) {\n    return null;\n  }\n  const interfaceName = `${interfaceNameFromOperation({operationName, operationType})}Variables`;\n\n  typeDeclaration(generator, {\n    interfaceName,\n  }, () => {\n    const properties = propertiesFromFields(generator.context, variables);\n    propertyDeclarations(generator, properties, true);\n  });\n}\n\nfunction getObjectTypeName(type) {\n  if (type instanceof GraphQLList) {\n    return getObjectTypeName(type.ofType);\n  }\n  if (type instanceof GraphQLNonNull) {\n    return getObjectTypeName(type.ofType);\n  }\n  if (type instanceof GraphQLObjectType) {\n    return `\"${type.name}\"`;\n  }\n  if (type instanceof GraphQLUnionType) {\n    return type.getTypes().map(type => getObjectTypeName(type)).join(\" | \");\n  }\n  return `\"${type.name}\"`;\n}\n\nexport function typeDeclarationForOperation(\n  generator,\n  {\n    operationName,\n    operationType,\n    variables,\n    fields,\n    fragmentSpreads,\n    fragmentsReferenced,\n    source,\n  }\n) {\n  const interfaceName = interfaceNameFromOperation({operationName, operationType});\n  fields = fields.map(rootField => {\n    const fields = rootField.fields && rootField.fields.map(field => {\n      if (field.fieldName === '__typename') {\n        const objectTypeName = getObjectTypeName(rootField.type);\n        return {\n          ...field,\n          typeName: objectTypeName,\n          type: { name: objectTypeName },\n        };\n      }\n      return field;\n    });\n    return {\n      ...rootField,\n      fields,\n    };\n  });\n  const properties = propertiesFromFields(generator.context, fields);\n  typeDeclaration(generator, {\n    interfaceName,\n  }, () => {\n    propertyDeclarations(generator, properties);\n  });\n}\n\nexport function typeDeclarationForFragment(\n  generator,\n  fragment\n) {\n  const {\n    fragmentName,\n    typeCondition,\n    fields,\n    inlineFragments,\n    fragmentSpreads,\n    source,\n  } = fragment;\n\n  const interfaceName = `${fragmentName}Fragment`;\n\n  typeDeclaration(generator, {\n    interfaceName,\n    noBrackets: isAbstractType(typeCondition)\n  }, () => {\n    if (isAbstractType(typeCondition)) {\n      const propertySets = fragment.possibleTypes\n        .map(type => {\n          // NOTE: inlineFragment currently consists of the merged fields\n          // from both inline fragments and fragment spreads.\n          // TODO: Rename inlineFragments in the IR.\n          const inlineFragment = inlineFragments.find(inlineFragment => {\n            return inlineFragment.typeCondition.toString() == type\n          });\n\n          if (inlineFragment) {\n            const fields = inlineFragment.fields.map(field => {\n              if (field.fieldName === '__typename') {\n                return {\n                  ...field,\n                  typeName: `\"${inlineFragment.typeCondition}\"`,\n                  type: { name: `\"${inlineFragment.typeCondition}\"` }\n                }\n              } else {\n                return field;\n              }\n            });\n\n            return propertiesFromFields(generator, fields);\n          } else {\n            const fragmentFields = fields.map(field => {\n              if (field.fieldName === '__typename') {\n                return {\n                  ...field,\n                  typeName: `\"${type}\"`,\n                  type: { name: `\"${type}\"` }\n                }\n              } else {\n                return field;\n              }\n            });\n\n            return propertiesFromFields(generator, fragmentFields);\n          }\n        });\n\n      propertySetsDeclaration(generator, fragment, propertySets, true);\n    } else {\n      const fragmentFields = fields.map(field => {\n        if (field.fieldName === '__typename') {\n          return {\n            ...field,\n            typeName: `\"${fragment.typeCondition}\"`,\n            type: { name: `\"${fragment.typeCondition}\"` }\n          }\n        } else {\n          return field;\n        }\n      });\n      const properties = propertiesFromFields(generator.context, fragmentFields)\n      propertyDeclarations(generator, properties);\n    }\n  });\n}\n\nexport function propertiesFromFields(context, fields) {\n  return fields.map(field => propertyFromField(context, field));\n}\n\nexport function propertyFromField(context, field) {\n  let { name: fieldName, type: fieldType, description, fragmentSpreads, inlineFragments } = field;\n  fieldName = fieldName || field.responseName;\n\n  const propertyName = fieldName;\n\n  let property = { fieldName, fieldType, propertyName, description };\n\n  let isNullable = true;\n  if (fieldType instanceof GraphQLNonNull) {\n    isNullable = false;\n  }\n  const namedType = getNamedType(fieldType);\n  if (isCompositeType(namedType)) {\n    const typeName = typeNameFromGraphQLType(context, fieldType);\n    let isArray = false;\n    let isArrayElementNullable = null;\n    if (fieldType instanceof GraphQLList) {\n      isArray = true;\n      isArrayElementNullable = !(fieldType.ofType instanceof GraphQLNonNull);\n    } else if (fieldType instanceof GraphQLNonNull && fieldType.ofType instanceof GraphQLList) {\n      isArray = true;\n      isArrayElementNullable = !(fieldType.ofType.ofType instanceof GraphQLNonNull);\n    }\n    return {\n      ...property,\n      typeName, fields: field.fields, isComposite: true, fragmentSpreads, inlineFragments, fieldType,\n      isArray, isNullable, isArrayElementNullable,\n    };\n  } else {\n    if (field.fieldName === '__typename') {\n      const typeName = typeNameFromGraphQLType(context, fieldType, null, false);\n      return { ...property, typeName, isComposite: false, fieldType, isNullable: false };\n    } else {\n      const typeName = typeNameFromGraphQLType(context, fieldType, null, isNullable);\n      return { ...property, typeName, isComposite: false, fieldType, isNullable };\n    }\n  }\n}\n\nexport function propertyDeclarations(generator, properties, isInput) {\n  if (!properties) return;\n  properties.forEach(property => {\n    if (isAbstractType(getNamedType(property.type || property.fieldType))) {\n      const propertySets = getPossibleTypeNames(generator, property)\n        .map(type => {\n          const inlineFragment = property.inlineFragments.find(inlineFragment => {\n            return inlineFragment.typeCondition.toString() == type\n          });\n\n          if (inlineFragment) {\n            const fields = inlineFragment.fields.map(field => {\n              if (field.fieldName === '__typename') {\n                return {\n                  ...field,\n                  typeName: `\"${inlineFragment.typeCondition}\"`,\n                  type: { name: `\"${inlineFragment.typeCondition}\"` }\n                }\n              } else {\n                return field;\n              }\n            });\n\n            return propertiesFromFields(generator, fields);\n          } else {\n            const fields = property.fields.map(field => {\n              if (field.fieldName === '__typename') {\n                return {\n                  ...field,\n                  typeName: `\"${type}\"`,\n                  type: { name: `\"${type}\"` }\n                }\n              } else {\n                return field;\n              }\n            });\n\n            return propertiesFromFields(generator, fields);\n          }\n        });\n\n      propertySetsDeclaration(generator, property, propertySets);\n    } else {\n      if (property.fields && property.fields.length > 0\n        || property.inlineFragments && property.inlineFragments.length > 0\n        || property.fragmentSpreads && property.fragmentSpreads.length > 0\n      ) {\n        propertyDeclaration(generator, property, () => {\n          const properties = propertiesFromFields(generator.context, property.fields);\n          propertyDeclarations(generator, properties, isInput);\n        });\n      } else {\n        propertyDeclaration(generator, {...property, isInput});\n      }\n    }\n  });\n}\n\n/**\n * This exists only to properly generate types for union/interface typed fields that\n * do not have inline fragments. This currently can happen and the IR does give us\n * a set of fields per type condition unless fragments are used within the selection set.\n */\nfunction getPossibleTypeNames(generator, property) {\n  return generator.context.schema.getPossibleTypes(getNamedType(property.fieldType || property.type)).map(type => type.name);\n}\n"],"sourceRoot":""}