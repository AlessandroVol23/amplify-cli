{"version":3,"sources":["codeGeneration.ts"],"names":[],"mappings":"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","sourcesContent":["import { LegacyCompilerContext, LegacyInlineFragment, LegacyFragment, LegacyField, LegacyOperation } from '../compiler/legacyIR';\nimport {\n  GraphQLError,\n  getNamedType,\n  isCompositeType,\n  isAbstractType,\n  GraphQLEnumType,\n  GraphQLNonNull,\n  GraphQLInputObjectType,\n  GraphQLType,\n  GraphQLUnionType,\n  GraphQLInterfaceType,\n  GraphQLObjectType,\n  isListType,\n  isNonNullType\n} from 'graphql'\n\nimport {\n  wrap\n} from '../utilities/printing';\n\nimport CodeGenerator from '../utilities/CodeGenerator';\n\nimport {\n  interfaceDeclaration,\n  propertyDeclaration,\n  propertySetsDeclaration,\n  Property\n} from './language';\n\nimport {\n  typeNameFromGraphQLType,\n} from './types';\nimport Maybe from 'graphql/tsutils/Maybe';\n\nexport function generateSource(context: LegacyCompilerContext) {\n  const generator = new CodeGenerator<LegacyCompilerContext>(context);\n\n  generator.printOnNewline('/* tslint:disable */');\n  generator.printOnNewline('//  This file was automatically generated and should not be edited.');\n\n  context.typesUsed.forEach(type =>\n    typeDeclarationForGraphQLType(generator, type)\n  );\n  Object.values(context.operations).forEach(operation => {\n    interfaceVariablesDeclarationForOperation(generator, operation);\n    interfaceDeclarationForOperation(generator, operation);\n  });\n  Object.values(context.fragments).forEach(operation =>\n    interfaceDeclarationForFragment(generator, operation)\n  );\n\n  generator.printNewline();\n\n  return generator.output;\n}\n\nexport function typeDeclarationForGraphQLType(generator: CodeGenerator, type: GraphQLType) {\n  if (type instanceof GraphQLEnumType) {\n    enumerationDeclaration(generator, type);\n  } else if (type instanceof GraphQLInputObjectType) {\n    structDeclarationForInputObjectType(generator, type);\n  }\n}\n\nfunction enumerationDeclaration(generator: CodeGenerator, type: GraphQLEnumType) {\n  const { name, description } = type;\n  const values = type.getValues();\n\n  generator.printNewlineIfNeeded();\n  if (description) {\n    description.split('\\n')\n      .forEach(line => {\n        generator.printOnNewline(`// ${line.trim()}`);\n      })\n  }\n  generator.printOnNewline(`export enum ${name} {`);\n  values.forEach((value) => {\n    if (!value.description || value.description.indexOf('\\n') === -1) {\n      generator.printOnNewline(`  ${value.value} = \"${value.value}\",${wrap(' // ', value.description || '')}`)\n    } else {\n      if (value.description) {\n        value.description.split('\\n')\n          .forEach(line => {\n            generator.printOnNewline(`  // ${line.trim()}`);\n          })\n      }\n      generator.printOnNewline(`  ${value.value} = \"${value.value}\",`)\n    }\n  });\n  generator.printOnNewline(`}`);\n  generator.printNewline();\n}\n\nfunction structDeclarationForInputObjectType(\n  generator: CodeGenerator,\n  type: GraphQLInputObjectType\n) {\n  const interfaceName = type.name;\n  interfaceDeclaration(generator, {\n    interfaceName,\n  }, () => {\n    const properties = propertiesFromFields(generator.context, Object.values(type.getFields()));\n    propertyDeclarations(generator, properties, true);\n  });\n}\n\nexport function interfaceNameFromOperation({ operationName, operationType }: { operationName: string, operationType: string }) {\n  switch (operationType) {\n    case 'query':\n      return `${operationName}Query`;\n      break;\n    case 'mutation':\n      return `${operationName}Mutation`;\n      break;\n    case 'subscription':\n      return `${operationName}Subscription`;\n      break;\n    default:\n      throw new GraphQLError(`Unsupported operation type \"${operationType}\"`);\n  }\n}\n\nexport function interfaceVariablesDeclarationForOperation(\n  generator: CodeGenerator,\n  {\n    operationName,\n    operationType,\n    variables\n  }: LegacyOperation\n) {\n  if (!variables || variables.length < 1) {\n    return;\n  }\n  const interfaceName = `${interfaceNameFromOperation({ operationName, operationType })}Variables`;\n\n  interfaceDeclaration(generator, {\n    interfaceName,\n  }, () => {\n    const properties = propertiesFromFields(generator.context, variables);\n    propertyDeclarations(generator, properties, true);\n  });\n}\n\nfunction getObjectTypeName(type: GraphQLType): string {\n  if (isListType(type)) {\n    return getObjectTypeName(type.ofType);\n  }\n  if (isNonNullType(type)) {\n    return getObjectTypeName(type.ofType);\n  }\n  if (type instanceof GraphQLObjectType) {\n    return `\"${type.name}\"`;\n  }\n  if (type instanceof GraphQLUnionType) {\n    return type.getTypes().map(type => getObjectTypeName(type)).join(\" | \");\n  }\n  return `\"${type.name}\"`;\n}\n\nexport function updateTypeNameField(rootField: LegacyField): LegacyField {\n  const fields = rootField.fields && rootField.fields.map(field => {\n    if (field.fieldName === '__typename') {\n      const objectTypeName = getObjectTypeName(rootField.type);\n      return {\n        ...field,\n        typeName: objectTypeName,\n        type: { name: objectTypeName },\n      };\n    }\n\n    if (field.fields) {\n      return updateTypeNameField(field);\n    }\n\n    return field;\n  });\n  return {\n    ...rootField,\n    fields,\n  } as LegacyField;\n}\n\nexport function interfaceDeclarationForOperation(\n  generator: CodeGenerator,\n  {\n    operationName,\n    operationType,\n    fields\n  }: LegacyOperation\n) {\n  const interfaceName = interfaceNameFromOperation({ operationName, operationType });\n  fields = fields.map(field => updateTypeNameField(field));\n  const properties = propertiesFromFields(generator.context, fields);\n  interfaceDeclaration(generator, {\n    interfaceName,\n  }, () => {\n    propertyDeclarations(generator, properties);\n  });\n}\n\nexport function interfaceDeclarationForFragment(\n  generator: CodeGenerator,\n  fragment: LegacyFragment\n) {\n  const {\n    fragmentName,\n    typeCondition,\n    fields,\n    inlineFragments\n  } = fragment;\n\n  const interfaceName = `${fragmentName}Fragment`;\n\n  interfaceDeclaration(generator, {\n    interfaceName,\n    noBrackets: isAbstractType(typeCondition)\n  }, () => {\n    if (isAbstractType(typeCondition)) {\n      const propertySets = fragment.possibleTypes\n        .map(type => {\n          // NOTE: inlineFragment currently consists of the merged fields\n          // from both inline fragments and fragment spreads.\n          // TODO: Rename inlineFragments in the IR.\n          const inlineFragment = inlineFragments.find(inlineFragment => {\n            return inlineFragment.typeCondition.toString() == type.toString()\n          });\n\n          if (inlineFragment) {\n            const fields = inlineFragment.fields.map(field => {\n              if (field.fieldName === '__typename') {\n                return {\n                  ...field,\n                  typeName: `\"${inlineFragment.typeCondition}\"`,\n                  type: { name: `\"${inlineFragment.typeCondition}\"` } as GraphQLType\n                }\n              } else {\n                return field;\n              }\n            });\n\n            return propertiesFromFields(generator.context, fields);\n          } else {\n            const fragmentFields = fields.map(field => {\n              if (field.fieldName === '__typename') {\n                return {\n                  ...field,\n                  typeName: `\"${type}\"`,\n                  type: { name: `\"${type}\"` } as GraphQLType\n                }\n              } else {\n                return field;\n              }\n            });\n\n            return propertiesFromFields(generator.context, fragmentFields);\n          }\n        });\n\n      propertySetsDeclaration(generator, fragment, propertySets, true);\n    } else {\n      const fragmentFields = fields.map(field => {\n        if (field.fieldName === '__typename') {\n          return {\n            ...field,\n            typeName: `\"${fragment.typeCondition}\"`,\n            type: { name: `\"${fragment.typeCondition}\"` } as GraphQLType\n          }\n        } else {\n          return field;\n        }\n      });\n\n      const properties = propertiesFromFields(generator.context, fragmentFields)\n      propertyDeclarations(generator, properties);\n    }\n  });\n}\n\nexport function propertiesFromFields(context: LegacyCompilerContext, fields: {\n  name?: string,\n  type: GraphQLType,\n  responseName?: string,\n  description?: Maybe<string>,\n  fragmentSpreads?: any,\n  inlineFragments?: LegacyInlineFragment[],\n  fieldName?: string\n}[]) {\n  return fields.map(field => propertyFromField(context, field));\n}\n\nexport function propertyFromField(context: LegacyCompilerContext, field: {\n  name?: string,\n  type: GraphQLType,\n  fields?: any[],\n  responseName?: string,\n  description?: Maybe<string>,\n  fragmentSpreads?: any,\n  inlineFragments?: LegacyInlineFragment[],\n  fieldName?: string\n}): Property {\n  let { name: fieldName, type: fieldType, description, fragmentSpreads, inlineFragments } = field;\n  fieldName = fieldName || field.responseName;\n\n  const propertyName = fieldName;\n\n  let property = { fieldName, fieldType, propertyName, description };\n\n  const namedType = getNamedType(fieldType);\n\n  let isNullable = true;\n  if (fieldType instanceof GraphQLNonNull) {\n    isNullable = false;\n  }\n\n  if (isCompositeType(namedType)) {\n    const typeName = typeNameFromGraphQLType(context, fieldType);\n    let isArray = false;\n    let isArrayElementNullable = null;\n    if (isListType(fieldType)) {\n      isArray = true;\n      isArrayElementNullable = !(fieldType.ofType instanceof GraphQLNonNull);\n    } else if (isNonNullType(fieldType)  && isListType(fieldType.ofType)) {\n      isArray = true\n      isArrayElementNullable = !(fieldType.ofType.ofType instanceof GraphQLNonNull);\n    }\n\n    return {\n      ...property,\n      typeName,\n      fields: field.fields,\n      isComposite: true,\n      fragmentSpreads, inlineFragments, fieldType,\n      isArray, isNullable, isArrayElementNullable,\n    };\n  } else {\n    if (field.fieldName === '__typename') {\n      const typeName = typeNameFromGraphQLType(context, fieldType, null, false);\n      return { ...property, typeName, isComposite: false, fieldType, isNullable: false };\n    } else {\n      const typeName = typeNameFromGraphQLType(context, fieldType, null, isNullable);\n      return { ...property, typeName, isComposite: false, fieldType, isNullable };\n    }\n  }\n}\n\nexport function propertyDeclarations(generator: CodeGenerator, properties: Property[], isInput = false) {\n\n  if (!properties) return;\n  properties.forEach(property => {\n    if (isAbstractType(getNamedType(property.type || property.fieldType!))) {\n      const propertySets = getPossibleTypeNames(generator, property)\n        .map(type => {\n          const inlineFragment = property.inlineFragments && property.inlineFragments.find(inlineFragment => {\n            return inlineFragment.typeCondition.toString() == type\n          });\n\n          if (inlineFragment) {\n            const fields = inlineFragment.fields.map(field => {\n              if (field.fieldName === '__typename') {\n                return {\n                  ...field,\n                  typeName: `\"${inlineFragment.typeCondition}\"`,\n                  type: { name: `\"${inlineFragment.typeCondition}\"` } as GraphQLType\n                }\n              } else {\n                return field;\n              }\n            });\n\n            return propertiesFromFields(generator.context, fields);\n          } else {\n            const fields = property.fields!.map(field => {\n              if (field.fieldName === '__typename') {\n                return {\n                  ...field,\n                  typeName: `\"${type}\"`,\n                  type: { name: `\"${type}\"` } as GraphQLType\n                }\n              } else {\n                return field;\n              }\n            });\n\n            return propertiesFromFields(generator.context, fields);\n          }\n        });\n\n      propertySetsDeclaration(generator, property, propertySets);\n    } else {\n      if (property.fields && property.fields.length > 0\n        || property.inlineFragments && property.inlineFragments.length > 0\n        || property.fragmentSpreads && property.fragmentSpreads.length > 0\n      ) {\n        propertyDeclaration(generator, property, () => {\n          const properties = propertiesFromFields(generator.context, property.fields!);\n          propertyDeclarations(generator, properties, isInput);\n        });\n      } else {\n        propertyDeclaration(generator, { ...property, isInput });\n      }\n    }\n  });\n}\n\n/**\n * This exists only to properly generate types for union/interface typed fields that\n * do not have inline fragments. This currently can happen and the IR does give us\n * a set of fields per type condition unless fragments are used within the selection set.\n */\nfunction getPossibleTypeNames(generator: CodeGenerator<LegacyCompilerContext>, property: Property) {\n  const type = getNamedType(property.fieldType || property.type!);\n\n  if (type instanceof GraphQLUnionType || type instanceof GraphQLInterfaceType) {\n    return generator.context.schema.getPossibleTypes(type).map(type => type.name);\n  }\n\n  return [];\n}\n"],"sourceRoot":""}