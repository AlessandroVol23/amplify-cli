{"version":3,"sources":["collectAndMergeFields.ts"],"names":[],"mappings":";;AAWA,SAAA,qBAAA,CACE,YADF,EAEE,yBAAkC,IAFpC,EAEwC;AAEtC,UAAM,gBAAsC,IAAI,GAAJ,EAA5C;AAEA,aAAA,iBAAA,CACE,UADF,EAEE,aAFF,EAGE,aAAiC,EAHnC,EAGqC;AAEnC,YAAI,cAAc,MAAd,GAAuB,CAA3B;AAA8B;AAE9B,aAAK,MAAM,SAAX,IAAwB,UAAxB,EAAoC;AAClC,oBAAQ,UAAU,IAAlB;AACE,qBAAK,OAAL;AACE,wBAAI,sBAAsB,cAAc,GAAd,CAAkB,UAAU,WAA5B,CAA1B;AACA,wBAAI,CAAC,mBAAL,EAA0B;AACxB,8CAAsB,EAAtB;AACA,sCAAc,GAAd,CAAkB,UAAU,WAA5B,EAAyC,mBAAzC;AACD;AAGD,wCAAoB,IAApB,CAAwB,OAAA,MAAA,CAAA,EAAA,EACnB,SADmB,EACV,EACZ,eAAe,WAAW,MAAX,GAAoB,CADvB,EAEZ,UAFY,EAGZ,cAAc,UAAU,YAAV;AACV;AACE,2CAAe,UAAU,YAAV,CAAuB,aADxC;AAEE,wCAAY,CAAC,GAAG,UAAU,YAAV,CAAuB,UAA3B,CAFd,EADU;;AAKV,iCARQ,EADU,CAAxB;AAWA;AACF,qBAAK,gBAAL;AACA,qBAAK,eAAL;AACE,wBAAI,UAAU,IAAV,KAAmB,gBAAnB,IAAuC,CAAC,sBAA5C;AAAoE;AAGpE,wBAAI,CAAC,cAAc,KAAd,CAAoB,QAAQ,UAAU,YAAV,CAAuB,aAAvB,CAAqC,QAArC,CAA8C,IAA9C,CAA5B,CAAL;AAAuF;AAEvF,sCAAkB,UAAU,YAAV,CAAuB,UAAzC,EAAqD,aAArD,EAAoE,UAApE;AACA;AACF,qBAAK,kBAAL;AACE,sCAAkB,UAAU,YAAV,CAAuB,UAAzC,EAAqD,aAArD,EAAoE,CAAC,GAAG,UAAJ,EAAgB,SAAhB,CAApE;AACA,0BAhCJ;;AAkCD;AACF;AAED,sBAAkB,aAAa,UAA/B,EAA2C,aAAa,aAAxD;AAIA,UAAM,SAAS,MAAM,IAAN,CAAW,cAAc,MAAd,EAAX,EAAmC,GAAnC,CAAuC,UAAS;AAC7D,cAAM,iCAAiC,OAAO,IAAP,CAAY,SAAS,CAAC,MAAM,aAA5B,CAAvC;AAEA,eAAO;AACJ,WADI,CACA,SAAQ;AACX,gBAAI,kCAAkC,MAAM,aAAxC,IAAyD,MAAM,YAAnE,EAAiF;AAC/E,sBAAM,YAAN,CAAmB,UAAnB,GAAgC,gCAC9B,MAAM,YAAN,CAAmB,UADW,EAE9B,MAAM,UAFwB,CAAhC;AAID;AACD,mBAAO,KAAP;AACD,SATI;AAUJ,cAVI,CAUG,CAAC,KAAD,EAAQ,UAAR,KAAsB;AAC5B,kBAAM,aAAN,GAAsB,MAAM,aAAN,IAAuB,WAAW,aAAxD;AAKA,gBAAI,MAAM,UAAN,IAAoB,WAAW,UAAnC,EAA+C;AAC7C,sBAAM,UAAN,GAAmB,CAAC,GAAG,MAAM,UAAV,EAAsB,GAAG,WAAW,UAApC,CAAnB;AACD,aAFD;AAEO;AACL,sBAAM,UAAN,GAAmB,SAAnB;AACD;AAED,gBAAI,MAAM,YAAN,IAAsB,WAAW,YAArC,EAAmD;AACjD,sBAAM,YAAN,CAAmB,UAAnB,CAA8B,IAA9B,CAAmC,GAAG,WAAW,YAAX,CAAwB,UAA9D;AACD;AAED,mBAAO,KAAP;AACD,SA3BI,CAAP;AA4BD,KA/Bc,CAAf;AAkCA,QAAI,aAAa,aAAb,CAA2B,MAA3B,IAAqC,CAAzC,EAA4C;AAC1C,cAAM,OAAO,aAAa,aAAb,CAA2B,CAA3B,CAAb;AACA,cAAM,cAAc,KAAK,SAAL,EAApB;AAEA,aAAK,MAAM,KAAX,IAAoB,MAApB,EAA4B;AAC1B,kBAAM,WAAW,YAAY,MAAM,IAAlB,CAAjB;AAEA,gBAAI,YAAY,SAAS,WAAzB,EAAsC;AACpC,sBAAM,WAAN,GAAoB,SAAS,WAA7B;AACD;AACF;AACF;AAED,WAAO,MAAP;AACD;AAvGD,QAAA,qBAAA,GAAA,qBAAA;AAyGA,SAAA,+BAAA,CACE,UADF,EAEE,UAFF,EAEiC;AAE/B,QAAI,CAAC,UAAD,IAAe,WAAW,MAAX,IAAqB,CAAxC;AAA2C,WAAO,UAAP;AAE3C,UAAM,CAAC,SAAD,EAAY,GAAG,IAAf,IAAuB,UAA7B;AACA,WAAO;sBAEA,S,EAAS,EACZ,cAAc;AACZ,2BAAe,UAAU,YAAV,CAAuB,aAD1B;AAEZ,wBAAY,gCAAgC,UAAhC,EAA4C,IAA5C,CAFA,EADF,E,CAFT,CAAP;;;AASD;AAhBD,QAAA,+BAAA,GAAA,+BAAA","sourcesContent":["import { SelectionSet, Selection, Field, BooleanCondition } from '../';\nimport { GraphQLObjectType } from 'graphql';\n\n// This is a temporary workaround to keep track of conditions on fields in the fields themselves.\n// It is only added here because we want to expose it to the Android target, which relies on the legacy IR.\ndeclare module '../' {\n  interface Field {\n    conditions?: BooleanCondition[];\n  }\n}\n\nexport function collectAndMergeFields(\n  selectionSet: SelectionSet,\n  mergeInFragmentSpreads: Boolean = true\n): Field[] {\n  const groupedFields: Map<string, Field[]> = new Map();\n\n  function visitSelectionSet(\n    selections: Selection[],\n    possibleTypes: GraphQLObjectType[],\n    conditions: BooleanCondition[] = []\n  ) {\n    if (possibleTypes.length < 1) return;\n\n    for (const selection of selections) {\n      switch (selection.kind) {\n        case 'Field':\n          let groupForResponseKey = groupedFields.get(selection.responseKey);\n          if (!groupForResponseKey) {\n            groupForResponseKey = [];\n            groupedFields.set(selection.responseKey, groupForResponseKey);\n          }\n          // Make sure to deep clone selections to avoid modifying the original field\n          // TODO: Should we use an object freezing / immutability solution?\n          groupForResponseKey.push({\n            ...selection,\n            isConditional: conditions.length > 0,\n            conditions,\n            selectionSet: selection.selectionSet\n              ? {\n                  possibleTypes: selection.selectionSet.possibleTypes,\n                  selections: [...selection.selectionSet.selections]\n                }\n              : undefined\n          });\n          break;\n        case 'FragmentSpread':\n        case 'TypeCondition':\n          if (selection.kind === 'FragmentSpread' && !mergeInFragmentSpreads) continue;\n\n          // Only merge fragment spreads and type conditions if they match all possible types.\n          if (!possibleTypes.every(type => selection.selectionSet.possibleTypes.includes(type))) continue;\n\n          visitSelectionSet(selection.selectionSet.selections, possibleTypes, conditions);\n          break;\n        case 'BooleanCondition':\n          visitSelectionSet(selection.selectionSet.selections, possibleTypes, [...conditions, selection]);\n          break;\n      }\n    }\n  }\n\n  visitSelectionSet(selectionSet.selections, selectionSet.possibleTypes);\n\n  // Merge selection sets\n\n  const fields = Array.from(groupedFields.values()).map(fields => {\n    const isFieldIncludedUnconditionally = fields.some(field => !field.isConditional);\n\n    return fields\n      .map(field => {\n        if (isFieldIncludedUnconditionally && field.isConditional && field.selectionSet) {\n          field.selectionSet.selections = wrapInBooleanConditionsIfNeeded(\n            field.selectionSet.selections,\n            field.conditions\n          );\n        }\n        return field;\n      })\n      .reduce((field, otherField) => {\n        field.isConditional = field.isConditional && otherField.isConditional;\n\n        // FIXME: This is strictly taken incorrect, because the conditions should be ORed\n        // These conditions are only used in Android target however,\n        // and there is now way to express this in the legacy IR.\n        if (field.conditions && otherField.conditions) {\n          field.conditions = [...field.conditions, ...otherField.conditions];\n        } else {\n          field.conditions = undefined;\n        }\n\n        if (field.selectionSet && otherField.selectionSet) {\n          field.selectionSet.selections.push(...otherField.selectionSet.selections);\n        }\n\n        return field;\n      });\n  });\n\n  // Replace field descriptions with type-specific descriptions if possible\n  if (selectionSet.possibleTypes.length == 1) {\n    const type = selectionSet.possibleTypes[0];\n    const fieldDefMap = type.getFields();\n\n    for (const field of fields) {\n      const fieldDef = fieldDefMap[field.name];\n\n      if (fieldDef && fieldDef.description) {\n        field.description = fieldDef.description;\n      }\n    }\n  }\n\n  return fields;\n}\n\nexport function wrapInBooleanConditionsIfNeeded(\n  selections: Selection[],\n  conditions?: BooleanCondition[]\n): Selection[] {\n  if (!conditions || conditions.length == 0) return selections;\n\n  const [condition, ...rest] = conditions;\n  return [\n    {\n      ...condition,\n      selectionSet: {\n        possibleTypes: condition.selectionSet.possibleTypes,\n        selections: wrapInBooleanConditionsIfNeeded(selections, rest)\n      }\n    }\n  ];\n}\n"],"sourceRoot":""}