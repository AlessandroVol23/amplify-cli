{"version":3,"sources":["typeCase.ts"],"names":[],"mappings":"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","sourcesContent":["import { inspect } from 'util';\n\nimport { GraphQLObjectType } from 'graphql';\n\nimport { SelectionSet, Selection, Field, FragmentSpread } from '../';\nimport { collectAndMergeFields } from './collectAndMergeFields';\n\nexport class Variant implements SelectionSet {\n  constructor(\n    public possibleTypes: GraphQLObjectType[],\n    public selections: Selection[] = [],\n    public fragmentSpreads: FragmentSpread[] = []\n  ) {}\n\n  get fields(): Field[] {\n    return collectAndMergeFields(this);\n  }\n\n  inspect() {\n    return `${inspect(this.possibleTypes)} -> ${inspect(\n      collectAndMergeFields(this, false).map(field => field.responseKey)\n    )} ${inspect(this.fragmentSpreads.map(fragmentSpread => fragmentSpread.fragmentName))}\\n`;\n  }\n}\n\nexport function typeCaseForSelectionSet(\n  selectionSet: SelectionSet,\n  mergeInFragmentSpreads: boolean = true\n): TypeCase {\n  const typeCase = new TypeCase(selectionSet.possibleTypes);\n\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case 'Field':\n        for (const variant of typeCase.disjointVariantsFor(selectionSet.possibleTypes)) {\n          variant.selections.push(selection);\n        }\n        break;\n      case 'FragmentSpread':\n        if (\n          typeCase.default.fragmentSpreads.some(\n            fragmentSpread => fragmentSpread.fragmentName === selection.fragmentName\n          )\n        )\n          continue;\n\n        for (const variant of typeCase.disjointVariantsFor(selectionSet.possibleTypes)) {\n          variant.fragmentSpreads.push(selection);\n\n          if (!mergeInFragmentSpreads) {\n            variant.selections.push(selection);\n          }\n        }\n        if (mergeInFragmentSpreads) {\n          typeCase.merge(\n            typeCaseForSelectionSet(\n              {\n                possibleTypes: selectionSet.possibleTypes.filter(type =>\n                  selection.selectionSet.possibleTypes.includes(type)\n                ),\n                selections: selection.selectionSet.selections\n              },\n              mergeInFragmentSpreads\n            )\n          );\n        }\n        break;\n      case 'TypeCondition':\n        typeCase.merge(\n          typeCaseForSelectionSet(\n            {\n              possibleTypes: selectionSet.possibleTypes.filter(type =>\n                selection.selectionSet.possibleTypes.includes(type)\n              ),\n              selections: selection.selectionSet.selections\n            },\n            mergeInFragmentSpreads\n          )\n        );\n        break;\n      case 'BooleanCondition':\n        typeCase.merge(\n          typeCaseForSelectionSet(selection.selectionSet, mergeInFragmentSpreads),\n          selectionSet => [\n            {\n              ...selection,\n              selectionSet\n            }\n          ]\n        );\n        break;\n    }\n  }\n\n  return typeCase;\n}\n\nexport class TypeCase {\n  default: Variant;\n  private variantsByType: Map<GraphQLObjectType, Variant>;\n\n  get variants(): Variant[] {\n    // Unique the variants before returning them.\n    return Array.from(new Set(this.variantsByType.values()));\n  }\n\n  get defaultAndVariants(): Variant[] {\n    return [this.default, ...this.variants];\n  }\n\n  get remainder(): Variant | undefined {\n    if (this.default.possibleTypes.some(type => !this.variantsByType.has(type))) {\n      return new Variant(\n        this.default.possibleTypes.filter(type => !this.variantsByType.has(type)),\n        this.default.selections,\n        this.default.fragmentSpreads\n      );\n    } else {\n      return undefined;\n    }\n  }\n\n  get exhaustiveVariants(): Variant[] {\n    const remainder = this.remainder;\n    if (remainder) {\n      return [remainder, ...this.variants];\n    } else {\n      return this.variants;\n    }\n  }\n\n  constructor(possibleTypes: GraphQLObjectType[]) {\n    // We start out with a single default variant that represents all possible types of the selection set.\n    this.default = new Variant(possibleTypes);\n\n    this.variantsByType = new Map();\n  }\n\n  // Returns records representing a set of possible types, making sure they are disjoint with other possible types.\n  // That may involve refining the existing partition (https://en.wikipedia.org/wiki/Partition_refinement)\n  // with the passed in set of possible types.\n  disjointVariantsFor(possibleTypes: GraphQLObjectType[]): Variant[] {\n    const variants: Variant[] = [];\n\n    const matchesDefault = this.default.possibleTypes.every(type => possibleTypes.includes(type));\n\n    if (matchesDefault) {\n      variants.push(this.default);\n    }\n\n    // We keep a map from original records to split records. We'll then remove possible types from the\n    // original record and move them to the split record.\n    // This means the original record will be modified to represent the set theoretical difference between\n    // the original set of possible types and the refinement set, and the split record will represent the\n    // intersection.\n    const splits: Map<Variant, Variant> = new Map();\n\n    for (const type of possibleTypes) {\n      let original = this.variantsByType.get(type);\n\n      if (!original) {\n        if (matchesDefault) continue;\n        original = this.default;\n      }\n\n      let split = splits.get(original);\n      if (!split) {\n        split = new Variant([], [...original.selections], [...original.fragmentSpreads]);\n        splits.set(original, split);\n        variants.push(split);\n      }\n\n      if (original !== this.default) {\n        original.possibleTypes.splice(original.possibleTypes.indexOf(type), 1);\n      }\n\n      this.variantsByType.set(type, split);\n      split.possibleTypes.push(type);\n    }\n\n    return variants;\n  }\n\n  merge(otherTypeCase: TypeCase, transform?: (selectionSet: SelectionSet) => Selection[]) {\n    for (const otherVariant of otherTypeCase.defaultAndVariants) {\n      if (otherVariant.selections.length < 1) continue;\n      for (const variant of this.disjointVariantsFor(otherVariant.possibleTypes)) {\n        if (otherVariant.fragmentSpreads.length > 0) {\n          // Union of variant.fragmentSpreads and otherVariant.fragmentSpreads\n          variant.fragmentSpreads = [...variant.fragmentSpreads, ...otherVariant.fragmentSpreads].filter(\n            (a, index, array) => array.findIndex(b => b.fragmentName == a.fragmentName) == index\n          );\n        }\n        variant.selections.push(...(transform ? transform(otherVariant) : otherVariant.selections));\n      }\n    }\n  }\n\n  inspect() {\n    return (\n      `TypeCase\\n` +\n      `  default -> ${inspect(this.default)}\\n` +\n      this.variants.map(variant => `  ${inspect(variant)}\\n`).join('')\n    );\n  }\n}\n"],"sourceRoot":""}