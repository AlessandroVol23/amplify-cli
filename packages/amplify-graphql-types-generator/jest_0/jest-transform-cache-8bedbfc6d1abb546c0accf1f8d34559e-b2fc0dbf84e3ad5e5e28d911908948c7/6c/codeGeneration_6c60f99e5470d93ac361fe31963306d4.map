{"version":3,"sources":["codeGeneration.ts"],"names":[],"mappings":";;AAAA,MAAA,YAAA,QAAA,SAAA,CAAA;AAEA,MAAA,YAAA,QAAA,eAAA,CAAA;AACA,MAAM,SAAS,UAAA,UAAA,CAAW,QAAQ,OAAR,CAAgB,6CAAhB,CAAX,CAAf;AAEA,MAAA,aAAA,QAAA,gBAAA,CAAA;AAMA,MAAA,mBAAA,QAAA,mBAAA,CAAA;AAEA,SAAA,OAAA,CACE,MADF,EAEE,UAA2B;AACzB,oCAAkC,IADT;AAEzB,eAAa,IAFY,EAF7B;AAKG;AAED,QAAM,WAAW,UAAA,KAAA,CAAM,MAAN,CAAjB;AACA,SAAO,WAAA,WAAA,CAAY,MAAZ,EAAoB,QAApB,EAA8B,OAA9B,CAAP;AACD;AAED,SAAS,qBAAT,EAAgC,MAAK;AACnC,OAAK,gBAAL,EAAuB,MAAK;AAC1B,UAAM,UAAU,QAAQ;;;;;;;;;;;;;;;;;;;;;;;;;KAAR,CAAhB;AA0BA,YAAQ,UAAR,CAAmB,UAAnB,EAA+B,QAA/B,GAA0C,0BAA1C;AACA,YAAQ,UAAR,CAAmB,WAAnB,EAAgC,QAAhC,GAA2C,0BAA3C;AACA,YAAQ,SAAR,CAAkB,cAAlB,EAAkC,QAAlC,GAA6C,0BAA7C;AACA,UAAM,SAAS,iBAAA,cAAA,CAAe,OAAf,CAAf;AACA,WAAO,MAAP,EAAe,cAAf,CAA8B,MAA9B;AACA,WAAO,IAAP,CAAY,MAAZ;AACG,WADH,CACY,QAAD,IAAa;AACpB,aAAO,QAAP,EAAiB,eAAjB;AACA,aAAO,OAAO,QAAP,CAAP,EAAyB,eAAzB;AACD,KAJH;AAKD,GArCD;AAuCA,OAAK,mBAAL,EAA0B,MAAK;AAC7B,UAAM,UAAU,QAAQ;;;;;;;KAAR,CAAhB;AASA,UAAM,SAAS,iBAAA,cAAA,CAAe,OAAf,CAAf;AACA,WAAO,MAAP,EAAe,eAAf;AACD,GAZD;AAcA,OAAK,iBAAL,EAAwB,MAAK;AAC3B,UAAM,UAAU,QAAQ;;;;;;;KAAR,CAAhB;AASA,UAAM,SAAS,iBAAA,cAAA,CAAe,OAAf,CAAf;AACA,WAAO,MAAP,EAAe,eAAf;AACD,GAZD;AAcA,OAAK,iBAAL,EAAwB,MAAK;AAC3B,UAAM,UAAU,QAAQ;;;;KAAR,CAAhB;AAMA,UAAM,SAAS,iBAAA,cAAA,CAAe,OAAf,CAAf;AACA,WAAO,MAAP,EAAe,eAAf;AACD,GATD;AAWA,OAAK,gCAAL,EAAuC,MAAK;AAC1C,UAAM,UAAU,QAAQ;;;;;;;;;KAAR,CAAhB;AAWA,UAAM,SAAS,iBAAA,cAAA,CAAe,OAAf,CAAf;AACA,WAAO,MAAP,EAAe,eAAf;AACD,GAdD;AAgBA,OAAK,qDAAL,EAA4D,MAAK;AAC/D,UAAM,UAAU,QAAQ;;;;;;;;;;;;;KAAR,CAAhB;AAeA,UAAM,SAAS,iBAAA,cAAA,CAAe,OAAf,CAAf;AACA,WAAO,MAAP,EAAe,eAAf;AACD,GAlBD;AAoBA,OAAK,6BAAL,EAAoC,MAAK;AACvC,UAAM,UAAU,QAAQ;;;;;;;;;;;KAAR,CAAhB;AAaA,UAAM,SAAS,iBAAA,cAAA,CAAe,OAAf,CAAf;AACA,WAAO,MAAP,EAAe,eAAf;AACD,GAhBD;AAkBA,OAAK,iBAAL,EAAwB,MAAK;AAC3B,UAAM,UAAU,QAAQ;;;;;;;;;KAAR,CAAhB;AAWA,UAAM,SAAS,iBAAA,cAAA,CAAe,OAAf,CAAf;AACA,WAAO,MAAP,EAAe,eAAf;AACD,GAdD;AAgBA,OAAK,oCAAL,EAA2C,MAAK;AAC9C,UAAM,UAAU,QAAQ;;;;;;;;;;;;;;;;;;KAAR,CAAhB;AAmBA,UAAM,SAAS,iBAAA,cAAA,CAAe,OAAf,CAAf;AACA,WAAO,MAAP,EAAe,eAAf;AACD,GAtBD;AAwBA,OAAK,gEAAL,EAAuE,MAAK;AAC1E,UAAM,UAAU,QAAQ;;;;;;;;;;;;;;;;;;;;;KAAR,CAAhB;AAuBA,UAAM,SAAS,iBAAA,cAAA,CAAe,OAAf,CAAf;AACA,WAAO,MAAP,EAAe,eAAf;AACD,GA1BD;AA4BA,OAAK,wCAAL,EAA+C,MAAK;AAClD,UAAM,UAAU,QAAQ;;;;;;;;;;;;;;;;;;;;;;;;;;KAAR,CAAhB;AA2BA,UAAM,SAAS,iBAAA,cAAA,CAAe,OAAf,CAAf;AACA,WAAO,MAAP,EAAe,eAAf;AACD,GA9BD;AA+BD,CAxOD","sourcesContent":["import { parse } from 'graphql';\n\nimport { loadSchema } from '../../loading';\nconst schema = loadSchema(require.resolve('../../../test/fixtures/starwars/schema.json'));\n\nimport {\n  compileToIR,\n  CompilerOptions,\n  CompilerContext,\n} from '../../compiler';\n\nimport { generateSource } from '../codeGeneration';\n\nfunction compile(\n  source: string,\n  options: CompilerOptions = {\n    mergeInFieldsFromFragmentSpreads: true,\n    addTypename: true\n  }\n): CompilerContext {\n  const document = parse(source);\n  return compileToIR(schema, document, options);\n}\n\ndescribe('Flow codeGeneration', () => {\n  test('multiple files', () => {\n    const context = compile(`\n      query HeroName($episode: Episode) {\n        hero(episode: $episode) {\n          name\n          id\n        }\n      }\n\n      query SomeOther($episode: Episode) {\n        hero(episode: $episode) {\n          name\n          ...someFragment\n        }\n      }\n\n      fragment someFragment on Character {\n        appearsIn\n      }\n\n      mutation ReviewMovie($episode: Episode, $review: ReviewInput) {\n        createReview(episode: $episode, review: $review) {\n          stars\n          commentary\n        }\n      }\n    `);\n    context.operations[\"HeroName\"].filePath = '/some/file/ComponentA.js';\n    context.operations[\"SomeOther\"].filePath = '/some/file/ComponentB.js';\n    context.fragments['someFragment'].filePath = '/some/file/ComponentB.js';\n    const output = generateSource(context);\n    expect(output).toBeInstanceOf(Object);\n    Object.keys(output)\n      .forEach((filePath) => {\n        expect(filePath).toMatchSnapshot();\n        expect(output[filePath]).toMatchSnapshot();\n      });\n  });\n\n  test('simple hero query', () => {\n    const context = compile(`\n      query HeroName($episode: Episode) {\n        hero(episode: $episode) {\n          name\n          id\n        }\n      }\n    `);\n\n    const output = generateSource(context);\n    expect(output).toMatchSnapshot();\n  });\n\n  test('simple mutation', () => {\n    const context = compile(`\n      mutation ReviewMovie($episode: Episode, $review: ReviewInput) {\n        createReview(episode: $episode, review: $review) {\n          stars\n          commentary\n        }\n      }\n    `);\n\n    const output = generateSource(context);\n    expect(output).toMatchSnapshot();\n  });\n\n  test('simple fragment', () => {\n    const context = compile(`\n      fragment SimpleFragment on Character{\n        name\n      }\n    `);\n\n    const output = generateSource(context);\n    expect(output).toMatchSnapshot();\n  });\n\n  test('fragment with fragment spreads', () => {\n    const context = compile(`\n      fragment simpleFragment on Character {\n        name\n      }\n\n      fragment anotherFragment on Character {\n        id\n        ...simpleFragment\n      }\n    `);\n\n    const output = generateSource(context);\n    expect(output).toMatchSnapshot();\n  });\n\n  test('fragment with fragment spreads with inline fragment', () => {\n    const context = compile(`\n      fragment simpleFragment on Character {\n        name\n      }\n\n      fragment anotherFragment on Character {\n        id\n        ...simpleFragment\n\n        ... on Human {\n          appearsIn\n        }\n      }\n    `);\n\n    const output = generateSource(context);\n    expect(output).toMatchSnapshot();\n  });\n\n  test('query with fragment spreads', () => {\n    const context = compile(`\n      fragment simpleFragment on Character {\n        name\n      }\n\n      query HeroFragment($episode: Episode) {\n        hero(episode: $episode) {\n          ...simpleFragment\n          id\n        }\n      }\n    `);\n\n    const output = generateSource(context);\n    expect(output).toMatchSnapshot();\n  });\n\n  test('inline fragment', () => {\n    const context = compile(`\n      query HeroInlineFragment($episode: Episode) {\n        hero(episode: $episode) {\n          ... on Character {\n            name\n          }\n          id\n        }\n      }\n    `);\n\n    const output = generateSource(context);\n    expect(output).toMatchSnapshot();\n  })\n\n  test('inline fragment on type conditions', () => {\n    const context = compile(`\n      query HeroName($episode: Episode) {\n        hero(episode: $episode) {\n          name\n          id\n\n          ... on Human {\n            homePlanet\n            friends {\n              name\n            }\n          }\n\n          ... on Droid {\n            appearsIn\n          }\n        }\n      }\n    `);\n    const output = generateSource(context);\n    expect(output).toMatchSnapshot();\n  });\n\n  test('inline fragment on type conditions with differing inner fields', () => {\n    const context = compile(`\n      query HeroName($episode: Episode) {\n        hero(episode: $episode) {\n          name\n          id\n\n          ... on Human {\n            homePlanet\n            friends {\n              name\n            }\n          }\n\n          ... on Droid {\n            appearsIn\n            friends {\n              id\n            }\n          }\n        }\n      }\n    `);\n\n    const output = generateSource(context);\n    expect(output).toMatchSnapshot();\n  });\n\n  test('fragment spreads with inline fragments', () => {\n    const context = compile(`\n      query HeroName($episode: Episode) {\n        hero(episode: $episode) {\n          name\n          id\n          ...humanFragment\n          ...droidFragment\n        }\n      }\n\n      fragment humanFragment on Human {\n        homePlanet\n        friends {\n          ... on Human {\n            name\n          }\n\n          ... on Droid {\n            id\n          }\n        }\n      }\n\n      fragment droidFragment on Droid {\n        appearsIn\n      }\n    `);\n    const output = generateSource(context);\n    expect(output).toMatchSnapshot();\n  });\n});\n"],"sourceRoot":""}