{"version":3,"sources":["generateOperationId.ts"],"names":[],"mappings":";;AAAA,MAAA,wBAAA,QAAA,oDAAA,CAAA;AACA,MAAA,gBAAA,QAAA,aAAA,CAAA;AAEA,MAAA,YAAA,QAAA,0BAAA,CAAA;AAEA,SAAS,uBAAT,EAAkC,MAAK;AACrC,KAAG,kEAAH,EAAuE,MAAK;AAC1E,UAAM,WAAW,UAAA,OAAA,CAAQ;;;;;;;;;KAAR,CAAjB;AAWA,UAAM,EAAE,aAAa,GAAf,KAAuB,sBAAA,mBAAA,CAAoB,SAAS,UAAT,CAAoB,MAApB,CAApB,EAAiD,SAAS,SAA1D,CAA7B;AAEA,UAAM,WAAW,UAAA,OAAA,CAAQ;;;;;;;;;KAAR,CAAjB;AAWA,UAAM,EAAE,aAAa,GAAf,KAAuB,sBAAA,mBAAA,CAAoB,SAAS,UAAT,CAAoB,MAApB,CAApB,EAAiD,SAAS,SAA1D,CAA7B;AAEA,WAAO,GAAP,EAAY,GAAZ,CAAgB,IAAhB,CAAqB,GAArB;AACD,GA5BD;AA8BA,KAAG,qFAAH,EAA0F,MAAK;AAC7F,UAAM,WAAW,UAAA,OAAA,CAAQ;;;;;;KAAR,CAAjB;AAQA,UAAM,EAAE,aAAa,GAAf,KAAuB,sBAAA,mBAAA,CAAoB,SAAS,UAAT,CAAoB,UAApB,CAApB,EAAqD,SAAS,SAA9D,CAA7B;AAEA,UAAM,WAAW,UAAA,OAAA,CAAQ;;;;KAAR,CAAjB;AAMA,UAAM,EAAE,aAAa,GAAf,KAAuB,sBAAA,mBAAA,CAAoB,SAAS,UAAT,CAAoB,UAApB,CAApB,EAAqD,SAAS,SAA9D,CAA7B;AAEA,WAAO,GAAP,EAAY,IAAZ,CAAiB,GAAjB;AACD,GApBD;AAsBA,KAAG,oEAAH,EAAyE,MAAK;AAC5E,UAAM,WAAW,UAAA,OAAA,CAAQ;;;;;;;;;;;;;KAAR,CAAjB;AAeA,UAAM,EAAE,aAAa,GAAf,KAAuB,sBAAA,mBAAA,CAAoB,SAAS,UAAT,CAAoB,MAApB,CAApB,EAAiD,SAAS,SAA1D,CAA7B;AAEA,UAAM,WAAW,UAAA,OAAA,CAAQ;;;;;;;;;;;;;KAAR,CAAjB;AAeA,UAAM,EAAE,aAAa,GAAf,KAAuB,sBAAA,mBAAA,CAAoB,SAAS,UAAT,CAAoB,MAApB,CAApB,EAAiD,SAAS,SAA1D,CAA7B;AAEA,WAAO,GAAP,EAAY,IAAZ,CAAiB,GAAjB;AACD,GApCD;AAsCA,KAAG,mGAAH,EAAwG,MAAK;AAC3G,UAAM,UAAU,UAAA,OAAA,CAAQ;;;;;;;;;;;;;KAAR,CAAhB;AAeA,UAAM,EAAE,mBAAF,KAA0B,sBAAA,mBAAA,CAAoB,QAAQ,UAAR,CAAmB,MAAnB,CAApB,EAAgD,QAAQ,SAAxD,CAAhC;AAEA,WAAO,mBAAP,EAA4B,IAA5B,CAAiC,cAAA,WAAW;;;;;;;;;;;;;KAA5C;AAcD,GAhCD;AAiCD,CA5HD","sourcesContent":["import { generateOperationId } from '../../../src/compiler/visitors/generateOperationId';\nimport { stripIndent } from 'common-tags';\n\nimport { compile } from '../../test-utils/helpers';\n\ndescribe(`generateOperationId()`, () => {\n  it(`should generate different operation IDs for different operations`, () => {\n    const context1 = compile(`\n      query Hero {\n        hero {\n          ...HeroDetails\n        }\n      }\n      fragment HeroDetails on Character {\n        name\n      }\n    `);\n\n    const { operationId: id1 } = generateOperationId(context1.operations['Hero'], context1.fragments);\n\n    const context2 = compile(`\n      query Hero {\n        hero {\n          ...HeroDetails\n        }\n      }\n      fragment HeroDetails on Character {\n        appearsIn\n      }\n    `);\n\n    const { operationId: id2 } = generateOperationId(context2.operations['Hero'], context2.fragments);\n\n    expect(id1).not.toBe(id2);\n  });\n\n  it(`should generate the same operation ID regardless of operation formatting/commenting`, () => {\n    const context1 = compile(`\n      query HeroName($episode: Episode) {\n        hero(episode: $episode) {\n          name\n        }\n      }\n    `);\n\n    const { operationId: id1 } = generateOperationId(context1.operations['HeroName'], context1.fragments);\n\n    const context2 = compile(`\n      # Profound comment\n      query HeroName($episode:Episode) { hero(episode: $episode) { name } }\n      # Deeply meaningful comment\n    `);\n\n    const { operationId: id2 } = generateOperationId(context2.operations['HeroName'], context2.fragments);\n\n    expect(id1).toBe(id2);\n  });\n\n  it(`should generate the same operation ID regardless of fragment order`, () => {\n    const context1 = compile(`\n      query Hero {\n        hero {\n          ...HeroName\n          ...HeroAppearsIn\n        }\n      }\n      fragment HeroName on Character {\n        name\n      }\n      fragment HeroAppearsIn on Character {\n        appearsIn\n      }\n    `);\n\n    const { operationId: id1 } = generateOperationId(context1.operations['Hero'], context1.fragments);\n\n    const context2 = compile(`\n      query Hero {\n        hero {\n          ...HeroName\n          ...HeroAppearsIn\n        }\n      }\n      fragment HeroAppearsIn on Character {\n        appearsIn\n      }\n      fragment HeroName on Character {\n        name\n      }\n    `);\n\n    const { operationId: id2 } = generateOperationId(context2.operations['Hero'], context2.fragments);\n\n    expect(id1).toBe(id2);\n  });\n\n  it(`should generate appropriate operation ID mapping source when there are nested fragment references`, () => {\n    const context = compile(`\n      query Hero {\n        hero {\n          ...HeroDetails\n        }\n      }\n      fragment HeroName on Character {\n        name\n      }\n      fragment HeroDetails on Character {\n        ...HeroName\n        appearsIn\n      }\n    `);\n\n    const { sourceWithFragments } = generateOperationId(context.operations['Hero'], context.fragments);\n\n    expect(sourceWithFragments).toBe(stripIndent`\n      query Hero {\n        hero {\n          ...HeroDetails\n        }\n      }\n      fragment HeroDetails on Character {\n        ...HeroName\n        appearsIn\n      }\n      fragment HeroName on Character {\n        name\n      }\n    `);\n  });\n});\n"],"sourceRoot":""}