{"version":3,"sources":["legacyIR.ts"],"names":[],"mappings":"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","sourcesContent":["import { GraphQLSchema, GraphQLType, GraphQLObjectType, GraphQLCompositeType, DocumentNode } from 'graphql';\n\nimport { compileToIR, CompilerContext, SelectionSet, Field, FragmentSpread } from './';\n\nimport { collectFragmentsReferenced } from './visitors/collectFragmentsReferenced';\nimport { generateOperationId } from './visitors/generateOperationId';\nimport { typeCaseForSelectionSet } from './visitors/typeCase';\nimport { collectAndMergeFields } from './visitors/collectAndMergeFields';\n\nimport '../utilities/array';\nimport Maybe from 'graphql/tsutils/Maybe';\n\nexport interface CompilerOptions {\n  addTypename?: boolean;\n  mergeInFieldsFromFragmentSpreads?: boolean;\n  passthroughCustomScalars?: boolean;\n  customScalarsPrefix?: string;\n  namespace?: string;\n  generateOperationIds?: boolean;\n}\n\nexport interface LegacyCompilerContext {\n  schema: GraphQLSchema;\n  operations: { [operationName: string]: LegacyOperation };\n  fragments: { [fragmentName: string]: LegacyFragment };\n  typesUsed: GraphQLType[];\n  options: CompilerOptions;\n}\n\nexport interface LegacyOperation {\n  filePath?: string;\n  operationName: string;\n  operationId?: string;\n  operationType: string;\n  rootType: GraphQLObjectType;\n  variables: {\n    name: string;\n    type: GraphQLType;\n  }[];\n  source: string;\n  sourceWithFragments?: string;\n  fields: LegacyField[];\n  fragmentSpreads?: string[];\n  inlineFragments?: LegacyInlineFragment[];\n  fragmentsReferenced: string[];\n}\n\nexport interface LegacyFragment {\n  filePath?: string;\n  fragmentName: string;\n  source: string;\n  typeCondition: GraphQLCompositeType;\n  possibleTypes: GraphQLObjectType[];\n  fields: LegacyField[];\n  fragmentSpreads: string[];\n  inlineFragments: LegacyInlineFragment[];\n}\n\nexport interface LegacyInlineFragment {\n  typeCondition: GraphQLObjectType;\n  possibleTypes: GraphQLObjectType[];\n  fields: LegacyField[];\n  fragmentSpreads: string[];\n}\n\nexport interface LegacyField {\n  responseName: string;\n  fieldName: string;\n  args?: Argument[];\n  type: GraphQLType;\n  description?: Maybe<string>;\n  isConditional?: boolean;\n  conditions?: BooleanCondition[];\n  isDeprecated?: boolean;\n  deprecationReason?: string;\n  fields?: LegacyField[];\n  fragmentSpreads?: string[];\n  inlineFragments?: LegacyInlineFragment[];\n}\n\nexport interface BooleanCondition {\n  variableName: string;\n  inverted: boolean;\n}\n\nexport interface Argument {\n  name: string;\n  value: any;\n}\n\nexport function compileToLegacyIR(\n  schema: GraphQLSchema,\n  document: DocumentNode,\n  options: CompilerOptions = { mergeInFieldsFromFragmentSpreads: true }\n): LegacyCompilerContext {\n  const context = compileToIR(schema, document, options);\n  const transformer = new LegacyIRTransformer(context, options);\n  return transformer.transformIR();\n}\n\nclass LegacyIRTransformer {\n  constructor(\n    public context: CompilerContext,\n    public options: CompilerOptions = { mergeInFieldsFromFragmentSpreads: true }\n  ) {}\n\n  transformIR(): LegacyCompilerContext {\n    const operations: { [operationName: string]: LegacyOperation } = Object.create({});\n\n    for (const [operationName, operation] of Object.entries(this.context.operations)) {\n      const { filePath, operationType, rootType, variables, source, selectionSet } = operation;\n      const fragmentsReferenced = collectFragmentsReferenced(selectionSet, this.context.fragments);\n\n      const { sourceWithFragments, operationId } = generateOperationId(\n        operation,\n        this.context.fragments,\n        fragmentsReferenced\n      );\n\n      operations[operationName] = {\n        filePath,\n        operationName,\n        operationType,\n        rootType,\n        variables,\n        source,\n        ...this.transformSelectionSetToLegacyIR(selectionSet),\n        fragmentsReferenced: Array.from(fragmentsReferenced),\n        sourceWithFragments,\n        operationId\n      };\n    }\n\n    const fragments: { [fragmentName: string]: LegacyFragment } = Object.create({});\n\n    for (const [fragmentName, fragment] of Object.entries(this.context.fragments)) {\n      const { selectionSet, type, ...fragmentWithoutSelectionSet } = fragment;\n      fragments[fragmentName] = {\n        typeCondition: type,\n        possibleTypes: selectionSet.possibleTypes,\n        ...fragmentWithoutSelectionSet,\n        ...this.transformSelectionSetToLegacyIR(selectionSet)\n      };\n    }\n\n    const legacyContext: LegacyCompilerContext = {\n      schema: this.context.schema,\n      operations,\n      fragments,\n      typesUsed: this.context.typesUsed,\n      options: this.options\n    };\n\n    return legacyContext;\n  }\n\n  transformSelectionSetToLegacyIR(selectionSet: SelectionSet) {\n    const typeCase = typeCaseForSelectionSet(selectionSet, this.options.mergeInFieldsFromFragmentSpreads);\n\n    const fields: LegacyField[] = this.transformFieldsToLegacyIR(collectAndMergeFields(typeCase.default, false));\n\n    const inlineFragments: LegacyInlineFragment[] = typeCase.variants.flatMap(variant => {\n      const fields = this.transformFieldsToLegacyIR(collectAndMergeFields(variant, false));\n\n      if (\n        // Filter out records that represent the same possible types as the default record.\n        selectionSet.possibleTypes.every(type => variant.possibleTypes.includes(type)) &&\n        // Filter out empty records for consistency with legacy compiler.\n        fields.length < 1\n      )\n        return undefined;\n\n      const fragmentSpreads: string[] = this.collectFragmentSpreads(selectionSet, variant.possibleTypes).map(\n        (fragmentSpread: FragmentSpread) => fragmentSpread.fragmentName\n      );\n      return variant.possibleTypes.map(possibleType => {\n        return {\n          typeCondition: possibleType,\n          possibleTypes: [possibleType],\n          fields,\n          fragmentSpreads\n        } as LegacyInlineFragment;\n      });\n    });\n\n    for (const inlineFragment of inlineFragments) {\n      inlineFragments[inlineFragment.typeCondition.name as any] = inlineFragment;\n    }\n\n    const fragmentSpreads: string[] = this.collectFragmentSpreads(selectionSet).map(\n      (fragmentSpread: FragmentSpread) => fragmentSpread.fragmentName\n    );\n\n    return {\n      fields,\n      fragmentSpreads,\n      inlineFragments\n    };\n  }\n\n  transformFieldsToLegacyIR(fields: Field[]) {\n    return fields.map(field => {\n      const { args, type, isConditional, description, isDeprecated, deprecationReason, selectionSet } = field;\n      const conditions =\n        field.conditions && field.conditions.length > 0\n          ? field.conditions.map(({ kind, variableName, inverted }) => {\n              return {\n                kind,\n                variableName,\n                inverted\n              };\n            })\n          : undefined;\n      return {\n        responseName: field.alias || field.name,\n        fieldName: field.name,\n        type,\n        args,\n        isConditional,\n        conditions,\n        description,\n        isDeprecated,\n        deprecationReason,\n        ...selectionSet ? this.transformSelectionSetToLegacyIR(selectionSet) : {}\n      } as LegacyField;\n    });\n  }\n\n  collectFragmentSpreads(\n    selectionSet: SelectionSet,\n    possibleTypes: GraphQLObjectType[] = selectionSet.possibleTypes\n  ): FragmentSpread[] {\n    const fragmentSpreads: FragmentSpread[] = [];\n\n    for (const selection of selectionSet.selections) {\n      switch (selection.kind) {\n        case 'FragmentSpread':\n          fragmentSpreads.push(selection);\n          break;\n        case 'TypeCondition':\n          if (possibleTypes.every(type => selection.selectionSet.possibleTypes.includes(type))) {\n            fragmentSpreads.push(...this.collectFragmentSpreads(selection.selectionSet, possibleTypes));\n          }\n          break;\n        case 'BooleanCondition':\n          fragmentSpreads.push(...this.collectFragmentSpreads(selection.selectionSet, possibleTypes));\n          break;\n      }\n    }\n\n    // Unique the fragment spreads before returning them.\n    return Array.from(new Set(fragmentSpreads));\n  }\n}\n"],"sourceRoot":""}