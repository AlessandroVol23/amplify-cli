{"version":3,"sources":["index.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  print,\n  typeFromAST,\n  getNamedType,\n  isAbstractType,\n  Kind,\n  isCompositeType,\n  GraphQLOutputType,\n  GraphQLInputType,\n  GraphQLScalarType,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLObjectType,\n  GraphQLError,\n  GraphQLSchema,\n  GraphQLType,\n  GraphQLCompositeType,\n  DocumentNode,\n  OperationDefinitionNode,\n  FragmentDefinitionNode,\n  SelectionSetNode,\n  SelectionNode,\n  isSpecifiedScalarType,\n  NonNullTypeNode,\n  GraphQLNonNull\n} from \"graphql\";\n\nimport {\n  getOperationRootType,\n  getFieldDef,\n  valueFromValueNode,\n  filePathForNode,\n  withTypenameFieldAddedWhereNeeded,\n  isMetaFieldName\n} from \"../utilities/graphql\";\n\nexport interface CompilerOptions {\n  addTypename?: boolean;\n  mergeInFieldsFromFragmentSpreads?: boolean;\n  passthroughCustomScalars?: boolean;\n  customScalarsPrefix?: string;\n  namespace?: string;\n  generateOperationIds?: boolean;\n  operationIdsPath?: string;\n  addS3Wrapper?: boolean;\n}\n\nexport interface CompilerContext {\n  schema: GraphQLSchema;\n  typesUsed: GraphQLType[];\n  operations: { [operationName: string]: Operation };\n  fragments: { [fragmentName: string]: Fragment };\n  options: CompilerOptions;\n}\n\nexport interface Operation {\n  operationId?: string;\n  operationName: string;\n  operationType: string;\n  variables: {\n    name: string;\n    type: GraphQLType;\n  }[];\n  filePath: string;\n  source: string;\n  rootType: GraphQLObjectType;\n  selectionSet: SelectionSet;\n}\n\nexport interface Fragment {\n  filePath: string;\n  fragmentName: string;\n  source: string;\n  type: GraphQLCompositeType;\n  selectionSet: SelectionSet;\n}\n\nexport interface SelectionSet {\n  possibleTypes: GraphQLObjectType[];\n  selections: Selection[];\n}\n\nexport interface Argument {\n  name: string;\n  value: any;\n  type?: GraphQLInputType;\n}\n\nexport type Selection =\n  | Field\n  | TypeCondition\n  | BooleanCondition\n  | FragmentSpread;\n\nexport interface Field {\n  kind: \"Field\";\n  responseKey: string;\n  name: string;\n  alias?: string;\n  args?: Argument[];\n  type: GraphQLOutputType;\n  description?: string;\n  isDeprecated?: boolean;\n  deprecationReason?: string;\n  isConditional?: boolean;\n  selectionSet?: SelectionSet;\n}\n\nexport interface TypeCondition {\n  kind: \"TypeCondition\";\n  type: GraphQLCompositeType;\n  selectionSet: SelectionSet;\n}\n\nexport interface BooleanCondition {\n  kind: \"BooleanCondition\";\n  variableName: string;\n  inverted: boolean;\n  selectionSet: SelectionSet;\n}\n\nexport interface FragmentSpread {\n  kind: \"FragmentSpread\";\n  fragmentName: string;\n  isConditional?: boolean;\n  selectionSet: SelectionSet;\n}\n\nexport function compileToIR(\n  schema: GraphQLSchema,\n  document: DocumentNode,\n  options: CompilerOptions = {}\n): CompilerContext {\n  if (options.addTypename) {\n    document = withTypenameFieldAddedWhereNeeded(document);\n  }\n\n  const compiler = new Compiler(schema, options);\n\n  const operations: { [operationName: string]: Operation } = Object.create(\n    null\n  );\n  const fragments: { [fragmentName: string]: Fragment } = Object.create(null);\n\n  for (const definition of document.definitions) {\n    switch (definition.kind) {\n      case Kind.OPERATION_DEFINITION:\n        const operation = compiler.compileOperation(definition);\n        operations[operation.operationName] = operation;\n        break;\n      case Kind.FRAGMENT_DEFINITION:\n        const fragment = compiler.compileFragment(definition);\n        fragments[fragment.fragmentName] = fragment;\n        break;\n    }\n  }\n\n  for (const fragmentSpread of compiler.unresolvedFragmentSpreads) {\n    const fragment = fragments[fragmentSpread.fragmentName];\n    if (!fragment) {\n      throw new Error(`Cannot find fragment \"${fragmentSpread.fragmentName}\"`);\n    }\n\n    // Compute the intersection between the possiblew types of the fragment spread and the fragment.\n    const possibleTypes = fragment.selectionSet.possibleTypes.filter(type =>\n      fragmentSpread.selectionSet.possibleTypes.includes(type)\n    );\n\n    fragmentSpread.isConditional = fragment.selectionSet.possibleTypes.some(\n      type => !fragmentSpread.selectionSet.possibleTypes.includes(type)\n    );\n\n    fragmentSpread.selectionSet = {\n      possibleTypes,\n      selections: fragment.selectionSet.selections\n    };\n  }\n\n  const typesUsed = compiler.typesUsed;\n\n  return { schema, typesUsed, operations, fragments, options };\n}\n\nclass Compiler {\n  options: CompilerOptions;\n  schema: GraphQLSchema;\n  typesUsedSet: Set<GraphQLType>;\n\n  unresolvedFragmentSpreads: FragmentSpread[] = [];\n\n  constructor(schema: GraphQLSchema, options: CompilerOptions) {\n    this.schema = schema;\n    this.options = options;\n\n    this.typesUsedSet = new Set();\n  }\n\n  addTypeUsed(type: GraphQLType) {\n    if (this.typesUsedSet.has(type)) return;\n\n    if (\n      type instanceof GraphQLEnumType ||\n      type instanceof GraphQLInputObjectType ||\n      (type instanceof GraphQLScalarType && !isSpecifiedScalarType(type))\n    ) {\n      this.typesUsedSet.add(type);\n    }\n    if (type instanceof GraphQLInputObjectType) {\n      for (const field of Object.values(type.getFields())) {\n        this.addTypeUsed(getNamedType(field.type));\n      }\n    }\n  }\n\n  get typesUsed(): GraphQLType[] {\n    return Array.from(this.typesUsedSet);\n  }\n\n  compileOperation(operationDefinition: OperationDefinitionNode): Operation {\n    if (!operationDefinition.name) {\n      throw new Error(\"Operations should be named\");\n    }\n\n    const filePath = filePathForNode(operationDefinition);\n    const operationName = operationDefinition.name.value;\n    const operationType = operationDefinition.operation;\n\n    const variables = (operationDefinition.variableDefinitions || []).map(\n      node => {\n        const name = node.variable.name.value;\n        const type = typeFromAST(this.schema, node.type as NonNullTypeNode);\n        this.addTypeUsed(getNamedType(type as GraphQLType));\n        return { name, type: type as GraphQLNonNull<any> };\n      }\n    );\n\n    const source = print(operationDefinition);\n    const rootType = getOperationRootType(\n      this.schema,\n      operationDefinition\n    ) as GraphQLObjectType;\n\n    return {\n      filePath,\n      operationName,\n      operationType,\n      variables,\n      source,\n      rootType,\n      selectionSet: this.compileSelectionSet(\n        operationDefinition.selectionSet,\n        rootType\n      )\n    };\n  }\n\n  compileFragment(fragmentDefinition: FragmentDefinitionNode): Fragment {\n    const fragmentName = fragmentDefinition.name.value;\n\n    const filePath = filePathForNode(fragmentDefinition);\n    const source = print(fragmentDefinition);\n\n    const type = typeFromAST(\n      this.schema,\n      fragmentDefinition.typeCondition\n    ) as GraphQLCompositeType;\n\n    return {\n      fragmentName,\n      filePath,\n      source,\n      type,\n      selectionSet: this.compileSelectionSet(\n        fragmentDefinition.selectionSet,\n        type\n      )\n    };\n  }\n\n  compileSelectionSet(\n    selectionSetNode: SelectionSetNode,\n    parentType: GraphQLCompositeType,\n    possibleTypes: GraphQLObjectType[] = this.possibleTypesForType(parentType),\n    visitedFragments: Set<string> = new Set()\n  ): SelectionSet {\n    return {\n      possibleTypes,\n      selections: selectionSetNode.selections\n        .map(selectionNode =>\n          wrapInBooleanConditionsIfNeeded(\n            this.compileSelection(\n              selectionNode,\n              parentType,\n              possibleTypes,\n              visitedFragments\n            ),\n            selectionNode,\n            possibleTypes\n          )\n        )\n        .filter(x => x) as Selection[]\n    };\n  }\n\n  compileSelection(\n    selectionNode: SelectionNode,\n    parentType: GraphQLCompositeType,\n    possibleTypes: GraphQLObjectType[],\n    visitedFragments: Set<string>\n  ): Selection | null {\n    switch (selectionNode.kind) {\n      case Kind.FIELD: {\n        const name = selectionNode.name.value;\n        const alias = selectionNode.alias\n          ? selectionNode.alias.value\n          : undefined;\n\n        const fieldDef = getFieldDef(this.schema, parentType, selectionNode);\n        if (!fieldDef) {\n          throw new GraphQLError(\n            `Cannot query field \"${name}\" on type \"${String(parentType)}\"`,\n            [selectionNode]\n          );\n        }\n\n        const fieldType = fieldDef.type;\n        const unmodifiedFieldType = getNamedType(fieldType);\n\n        this.addTypeUsed(unmodifiedFieldType);\n\n        const { description, isDeprecated, deprecationReason } = fieldDef;\n\n        const responseKey = alias || name;\n\n        const args =\n          selectionNode.arguments && selectionNode.arguments.length > 0\n            ? selectionNode.arguments.map(arg => {\n                const name = arg.name.value;\n                const argDef = fieldDef.args.find(\n                  argDef => argDef.name === arg.name.value\n                );\n                return {\n                  name,\n                  value: valueFromValueNode(arg.value),\n                  type: (argDef && argDef.type) || undefined\n                };\n              })\n            : undefined;\n\n        let field: Field = {\n          kind: \"Field\",\n          responseKey,\n          name,\n          alias,\n          args,\n          type: fieldType,\n          description:\n            !isMetaFieldName(name) && description ? description : undefined,\n          isDeprecated,\n          deprecationReason: deprecationReason || undefined\n        };\n\n        if (isCompositeType(unmodifiedFieldType)) {\n          const selectionSetNode = selectionNode.selectionSet;\n          if (!selectionSetNode) {\n            throw new GraphQLError(\n              `Composite field \"${name}\" on type \"${String(\n                parentType\n              )}\" requires selection set`,\n              [selectionNode]\n            );\n          }\n\n          field.selectionSet = this.compileSelectionSet(\n            selectionNode.selectionSet as SelectionSetNode,\n            unmodifiedFieldType\n          );\n        }\n        return field;\n      }\n      case Kind.INLINE_FRAGMENT: {\n        const typeNode = selectionNode.typeCondition;\n        const type = typeNode\n          ? (typeFromAST(this.schema, typeNode) as GraphQLCompositeType)\n          : parentType;\n        const possibleTypesForTypeCondition = this.possibleTypesForType(\n          type\n        ).filter(type => possibleTypes.includes(type));\n        return {\n          kind: \"TypeCondition\",\n          type,\n          selectionSet: this.compileSelectionSet(\n            selectionNode.selectionSet,\n            type,\n            possibleTypesForTypeCondition\n          )\n        };\n      }\n      case Kind.FRAGMENT_SPREAD: {\n        const fragmentName = selectionNode.name.value;\n        if (visitedFragments.has(fragmentName)) return null;\n        visitedFragments.add(fragmentName);\n\n        const fragmentSpread: FragmentSpread = {\n          kind: \"FragmentSpread\",\n          fragmentName,\n          selectionSet: {\n            possibleTypes,\n            selections: []\n          }\n        };\n        this.unresolvedFragmentSpreads.push(fragmentSpread);\n        return fragmentSpread;\n      }\n    }\n  }\n\n  possibleTypesForType(type: GraphQLCompositeType): GraphQLObjectType[] {\n    if (isAbstractType(type)) {\n      return Array.from(this.schema.getPossibleTypes(type)) || [];\n    } else {\n      return [type];\n    }\n  }\n}\n\nfunction wrapInBooleanConditionsIfNeeded(\n  selection: Selection | null,\n  selectionNode: SelectionNode,\n  possibleTypes: GraphQLObjectType[]\n): Selection | null {\n  if (!selection) return null;\n\n  if (!selectionNode.directives) return selection;\n\n  for (const directive of selectionNode.directives) {\n    const directiveName = directive.name.value;\n\n    if (directiveName === \"skip\" || directiveName === \"include\") {\n      if (!directive.arguments) continue;\n\n      const value = directive.arguments[0].value;\n\n      switch (value.kind) {\n        case \"BooleanValue\":\n          if (directiveName === \"skip\") {\n            return value.value ? null : selection;\n          } else {\n            return value.value ? selection : null;\n          }\n          break;\n        case \"Variable\":\n          selection = {\n            kind: \"BooleanCondition\",\n            variableName: value.name.value,\n            inverted: directiveName === \"skip\",\n            selectionSet: {\n              possibleTypes,\n              selections: [selection]\n            }\n          };\n          break;\n      }\n    }\n  }\n\n  return selection;\n}"],"sourceRoot":""}