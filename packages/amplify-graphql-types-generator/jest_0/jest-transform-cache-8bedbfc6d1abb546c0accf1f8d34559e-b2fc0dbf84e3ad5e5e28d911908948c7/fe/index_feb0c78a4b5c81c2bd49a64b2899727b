21d7e1d2828737e84ca3da0f19dbecb9
'use strict';require('ts-jest').install("/c/Users/Sandro/repo/amplify-cli/packages/amplify-graphql-types-generator/src/compiler/index.ts", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst graphql_1 = require(\"graphql\");\nconst graphql_2 = require(\"../utilities/graphql\");\nfunction compileToIR(schema, document, options = {}) {\n    if (options.addTypename) {\n        document = graphql_2.withTypenameFieldAddedWhereNeeded(document);\n    }\n    const compiler = new Compiler(schema, options);\n    const operations = Object.create(null);\n    const fragments = Object.create(null);\n    for (const definition of document.definitions) {\n        switch (definition.kind) {\n            case graphql_1.Kind.OPERATION_DEFINITION:\n                const operation = compiler.compileOperation(definition);\n                operations[operation.operationName] = operation;\n                break;\n            case graphql_1.Kind.FRAGMENT_DEFINITION:\n                const fragment = compiler.compileFragment(definition);\n                fragments[fragment.fragmentName] = fragment;\n                break;\n        }\n    }\n    for (const fragmentSpread of compiler.unresolvedFragmentSpreads) {\n        const fragment = fragments[fragmentSpread.fragmentName];\n        if (!fragment) {\n            throw new Error(`Cannot find fragment \"${fragmentSpread.fragmentName}\"`);\n        }\n        const possibleTypes = fragment.selectionSet.possibleTypes.filter(type => fragmentSpread.selectionSet.possibleTypes.includes(type));\n        fragmentSpread.isConditional = fragment.selectionSet.possibleTypes.some(type => !fragmentSpread.selectionSet.possibleTypes.includes(type));\n        fragmentSpread.selectionSet = {\n            possibleTypes,\n            selections: fragment.selectionSet.selections\n        };\n    }\n    const typesUsed = compiler.typesUsed;\n    return { schema, typesUsed, operations, fragments, options };\n}\nexports.compileToIR = compileToIR;\nclass Compiler {\n    constructor(schema, options) {\n        this.unresolvedFragmentSpreads = [];\n        this.schema = schema;\n        this.options = options;\n        this.typesUsedSet = new Set();\n    }\n    addTypeUsed(type) {\n        if (this.typesUsedSet.has(type))\n            return;\n        if (type instanceof graphql_1.GraphQLEnumType ||\n            type instanceof graphql_1.GraphQLInputObjectType ||\n            (type instanceof graphql_1.GraphQLScalarType && !graphql_1.isSpecifiedScalarType(type))) {\n            this.typesUsedSet.add(type);\n        }\n        if (type instanceof graphql_1.GraphQLInputObjectType) {\n            for (const field of Object.values(type.getFields())) {\n                this.addTypeUsed(graphql_1.getNamedType(field.type));\n            }\n        }\n    }\n    get typesUsed() {\n        return Array.from(this.typesUsedSet);\n    }\n    compileOperation(operationDefinition) {\n        if (!operationDefinition.name) {\n            throw new Error(\"Operations should be named\");\n        }\n        const filePath = graphql_2.filePathForNode(operationDefinition);\n        const operationName = operationDefinition.name.value;\n        const operationType = operationDefinition.operation;\n        const variables = (operationDefinition.variableDefinitions || []).map(node => {\n            const name = node.variable.name.value;\n            const type = graphql_1.typeFromAST(this.schema, node.type);\n            this.addTypeUsed(graphql_1.getNamedType(type));\n            return { name, type: type };\n        });\n        const source = graphql_1.print(operationDefinition);\n        const rootType = graphql_2.getOperationRootType(this.schema, operationDefinition);\n        return {\n            filePath,\n            operationName,\n            operationType,\n            variables,\n            source,\n            rootType,\n            selectionSet: this.compileSelectionSet(operationDefinition.selectionSet, rootType)\n        };\n    }\n    compileFragment(fragmentDefinition) {\n        const fragmentName = fragmentDefinition.name.value;\n        const filePath = graphql_2.filePathForNode(fragmentDefinition);\n        const source = graphql_1.print(fragmentDefinition);\n        const type = graphql_1.typeFromAST(this.schema, fragmentDefinition.typeCondition);\n        return {\n            fragmentName,\n            filePath,\n            source,\n            type,\n            selectionSet: this.compileSelectionSet(fragmentDefinition.selectionSet, type)\n        };\n    }\n    compileSelectionSet(selectionSetNode, parentType, possibleTypes = this.possibleTypesForType(parentType), visitedFragments = new Set()) {\n        return {\n            possibleTypes,\n            selections: selectionSetNode.selections\n                .map(selectionNode => wrapInBooleanConditionsIfNeeded(this.compileSelection(selectionNode, parentType, possibleTypes, visitedFragments), selectionNode, possibleTypes))\n                .filter(x => x)\n        };\n    }\n    compileSelection(selectionNode, parentType, possibleTypes, visitedFragments) {\n        switch (selectionNode.kind) {\n            case graphql_1.Kind.FIELD: {\n                const name = selectionNode.name.value;\n                const alias = selectionNode.alias\n                    ? selectionNode.alias.value\n                    : undefined;\n                const fieldDef = graphql_2.getFieldDef(this.schema, parentType, selectionNode);\n                if (!fieldDef) {\n                    throw new graphql_1.GraphQLError(`Cannot query field \"${name}\" on type \"${String(parentType)}\"`, [selectionNode]);\n                }\n                const fieldType = fieldDef.type;\n                const unmodifiedFieldType = graphql_1.getNamedType(fieldType);\n                this.addTypeUsed(unmodifiedFieldType);\n                const { description, isDeprecated, deprecationReason } = fieldDef;\n                const responseKey = alias || name;\n                const args = selectionNode.arguments && selectionNode.arguments.length > 0\n                    ? selectionNode.arguments.map(arg => {\n                        const name = arg.name.value;\n                        const argDef = fieldDef.args.find(argDef => argDef.name === arg.name.value);\n                        return {\n                            name,\n                            value: graphql_2.valueFromValueNode(arg.value),\n                            type: (argDef && argDef.type) || undefined\n                        };\n                    })\n                    : undefined;\n                let field = {\n                    kind: \"Field\",\n                    responseKey,\n                    name,\n                    alias,\n                    args,\n                    type: fieldType,\n                    description: !graphql_2.isMetaFieldName(name) && description ? description : undefined,\n                    isDeprecated,\n                    deprecationReason: deprecationReason || undefined\n                };\n                if (graphql_1.isCompositeType(unmodifiedFieldType)) {\n                    const selectionSetNode = selectionNode.selectionSet;\n                    if (!selectionSetNode) {\n                        throw new graphql_1.GraphQLError(`Composite field \"${name}\" on type \"${String(parentType)}\" requires selection set`, [selectionNode]);\n                    }\n                    field.selectionSet = this.compileSelectionSet(selectionNode.selectionSet, unmodifiedFieldType);\n                }\n                return field;\n            }\n            case graphql_1.Kind.INLINE_FRAGMENT: {\n                const typeNode = selectionNode.typeCondition;\n                const type = typeNode\n                    ? graphql_1.typeFromAST(this.schema, typeNode)\n                    : parentType;\n                const possibleTypesForTypeCondition = this.possibleTypesForType(type).filter(type => possibleTypes.includes(type));\n                return {\n                    kind: \"TypeCondition\",\n                    type,\n                    selectionSet: this.compileSelectionSet(selectionNode.selectionSet, type, possibleTypesForTypeCondition)\n                };\n            }\n            case graphql_1.Kind.FRAGMENT_SPREAD: {\n                const fragmentName = selectionNode.name.value;\n                if (visitedFragments.has(fragmentName))\n                    return null;\n                visitedFragments.add(fragmentName);\n                const fragmentSpread = {\n                    kind: \"FragmentSpread\",\n                    fragmentName,\n                    selectionSet: {\n                        possibleTypes,\n                        selections: []\n                    }\n                };\n                this.unresolvedFragmentSpreads.push(fragmentSpread);\n                return fragmentSpread;\n            }\n        }\n    }\n    possibleTypesForType(type) {\n        if (graphql_1.isAbstractType(type)) {\n            return Array.from(this.schema.getPossibleTypes(type)) || [];\n        }\n        else {\n            return [type];\n        }\n    }\n}\nfunction wrapInBooleanConditionsIfNeeded(selection, selectionNode, possibleTypes) {\n    if (!selection)\n        return null;\n    if (!selectionNode.directives)\n        return selection;\n    for (const directive of selectionNode.directives) {\n        const directiveName = directive.name.value;\n        if (directiveName === \"skip\" || directiveName === \"include\") {\n            if (!directive.arguments)\n                continue;\n            const value = directive.arguments[0].value;\n            switch (value.kind) {\n                case \"BooleanValue\":\n                    if (directiveName === \"skip\") {\n                        return value.value ? null : selection;\n                    }\n                    else {\n                        return value.value ? selection : null;\n                    }\n                    break;\n                case \"Variable\":\n                    selection = {\n                        kind: \"BooleanCondition\",\n                        variableName: value.name.value,\n                        inverted: directiveName === \"skip\",\n                        selectionSet: {\n                            possibleTypes,\n                            selections: [selection]\n                        }\n                    };\n                    break;\n            }\n        }\n    }\n    return selection;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHFDQXlCaUI7QUFFakIsa0RBTzhCO0FBOEY5QixxQkFDRSxNQUFxQixFQUNyQixRQUFzQixFQUN0QixVQUEyQixFQUFFO0lBRTdCLElBQUksT0FBTyxDQUFDLFdBQVcsRUFBRTtRQUN2QixRQUFRLEdBQUcsMkNBQWlDLENBQUMsUUFBUSxDQUFDLENBQUM7S0FDeEQ7SUFFRCxNQUFNLFFBQVEsR0FBRyxJQUFJLFFBQVEsQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFFL0MsTUFBTSxVQUFVLEdBQTJDLE1BQU0sQ0FBQyxNQUFNLENBQ3RFLElBQUksQ0FDTCxDQUFDO0lBQ0YsTUFBTSxTQUFTLEdBQXlDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFNUUsS0FBSyxNQUFNLFVBQVUsSUFBSSxRQUFRLENBQUMsV0FBVyxFQUFFO1FBQzdDLFFBQVEsVUFBVSxDQUFDLElBQUksRUFBRTtZQUN2QixLQUFLLGNBQUksQ0FBQyxvQkFBb0I7Z0JBQzVCLE1BQU0sU0FBUyxHQUFHLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsQ0FBQztnQkFDeEQsVUFBVSxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsR0FBRyxTQUFTLENBQUM7Z0JBQ2hELE1BQU07WUFDUixLQUFLLGNBQUksQ0FBQyxtQkFBbUI7Z0JBQzNCLE1BQU0sUUFBUSxHQUFHLFFBQVEsQ0FBQyxlQUFlLENBQUMsVUFBVSxDQUFDLENBQUM7Z0JBQ3RELFNBQVMsQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLEdBQUcsUUFBUSxDQUFDO2dCQUM1QyxNQUFNO1NBQ1Q7S0FDRjtJQUVELEtBQUssTUFBTSxjQUFjLElBQUksUUFBUSxDQUFDLHlCQUF5QixFQUFFO1FBQy9ELE1BQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDeEQsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNiLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLGNBQWMsQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFDO1NBQzFFO1FBR0QsTUFBTSxhQUFhLEdBQUcsUUFBUSxDQUFDLFlBQVksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQ3RFLGNBQWMsQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FDekQsQ0FBQztRQUVGLGNBQWMsQ0FBQyxhQUFhLEdBQUcsUUFBUSxDQUFDLFlBQVksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUNyRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUNsRSxDQUFDO1FBRUYsY0FBYyxDQUFDLFlBQVksR0FBRztZQUM1QixhQUFhO1lBQ2IsVUFBVSxFQUFFLFFBQVEsQ0FBQyxZQUFZLENBQUMsVUFBVTtTQUM3QyxDQUFDO0tBQ0g7SUFFRCxNQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDO0lBRXJDLE9BQU8sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLENBQUM7QUFDL0QsQ0FBQztBQXJERCxrQ0FxREM7QUFFRDtJQU9FLFlBQVksTUFBcUIsRUFBRSxPQUF3QjtRQUYzRCw4QkFBeUIsR0FBcUIsRUFBRSxDQUFDO1FBRy9DLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1FBRXZCLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUNoQyxDQUFDO0lBRUQsV0FBVyxDQUFDLElBQWlCO1FBQzNCLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDO1lBQUUsT0FBTztRQUV4QyxJQUNFLElBQUksWUFBWSx5QkFBZTtZQUMvQixJQUFJLFlBQVksZ0NBQXNCO1lBQ3RDLENBQUMsSUFBSSxZQUFZLDJCQUFpQixJQUFJLENBQUMsK0JBQXFCLENBQUMsSUFBSSxDQUFDLENBQUMsRUFDbkU7WUFDQSxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUM3QjtRQUNELElBQUksSUFBSSxZQUFZLGdDQUFzQixFQUFFO1lBQzFDLEtBQUssTUFBTSxLQUFLLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsRUFBRTtnQkFDbkQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxzQkFBWSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO2FBQzVDO1NBQ0Y7SUFDSCxDQUFDO0lBRUQsSUFBSSxTQUFTO1FBQ1gsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUN2QyxDQUFDO0lBRUQsZ0JBQWdCLENBQUMsbUJBQTRDO1FBQzNELElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLEVBQUU7WUFDN0IsTUFBTSxJQUFJLEtBQUssQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO1NBQy9DO1FBRUQsTUFBTSxRQUFRLEdBQUcseUJBQWUsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1FBQ3RELE1BQU0sYUFBYSxHQUFHLG1CQUFtQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7UUFDckQsTUFBTSxhQUFhLEdBQUcsbUJBQW1CLENBQUMsU0FBUyxDQUFDO1FBRXBELE1BQU0sU0FBUyxHQUFHLENBQUMsbUJBQW1CLENBQUMsbUJBQW1CLElBQUksRUFBRSxDQUFDLENBQUMsR0FBRyxDQUNuRSxJQUFJLENBQUMsRUFBRTtZQUNMLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztZQUN0QyxNQUFNLElBQUksR0FBRyxxQkFBVyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLElBQXVCLENBQUMsQ0FBQztZQUNwRSxJQUFJLENBQUMsV0FBVyxDQUFDLHNCQUFZLENBQUMsSUFBbUIsQ0FBQyxDQUFDLENBQUM7WUFDcEQsT0FBTyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBMkIsRUFBRSxDQUFDO1FBQ3JELENBQUMsQ0FDRixDQUFDO1FBRUYsTUFBTSxNQUFNLEdBQUcsZUFBSyxDQUFDLG1CQUFtQixDQUFDLENBQUM7UUFDMUMsTUFBTSxRQUFRLEdBQUcsOEJBQW9CLENBQ25DLElBQUksQ0FBQyxNQUFNLEVBQ1gsbUJBQW1CLENBQ0MsQ0FBQztRQUV2QixPQUFPO1lBQ0wsUUFBUTtZQUNSLGFBQWE7WUFDYixhQUFhO1lBQ2IsU0FBUztZQUNULE1BQU07WUFDTixRQUFRO1lBQ1IsWUFBWSxFQUFFLElBQUksQ0FBQyxtQkFBbUIsQ0FDcEMsbUJBQW1CLENBQUMsWUFBWSxFQUNoQyxRQUFRLENBQ1Q7U0FDRixDQUFDO0lBQ0osQ0FBQztJQUVELGVBQWUsQ0FBQyxrQkFBMEM7UUFDeEQsTUFBTSxZQUFZLEdBQUcsa0JBQWtCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztRQUVuRCxNQUFNLFFBQVEsR0FBRyx5QkFBZSxDQUFDLGtCQUFrQixDQUFDLENBQUM7UUFDckQsTUFBTSxNQUFNLEdBQUcsZUFBSyxDQUFDLGtCQUFrQixDQUFDLENBQUM7UUFFekMsTUFBTSxJQUFJLEdBQUcscUJBQVcsQ0FDdEIsSUFBSSxDQUFDLE1BQU0sRUFDWCxrQkFBa0IsQ0FBQyxhQUFhLENBQ1QsQ0FBQztRQUUxQixPQUFPO1lBQ0wsWUFBWTtZQUNaLFFBQVE7WUFDUixNQUFNO1lBQ04sSUFBSTtZQUNKLFlBQVksRUFBRSxJQUFJLENBQUMsbUJBQW1CLENBQ3BDLGtCQUFrQixDQUFDLFlBQVksRUFDL0IsSUFBSSxDQUNMO1NBQ0YsQ0FBQztJQUNKLENBQUM7SUFFRCxtQkFBbUIsQ0FDakIsZ0JBQWtDLEVBQ2xDLFVBQWdDLEVBQ2hDLGdCQUFxQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsVUFBVSxDQUFDLEVBQzFFLG1CQUFnQyxJQUFJLEdBQUcsRUFBRTtRQUV6QyxPQUFPO1lBQ0wsYUFBYTtZQUNiLFVBQVUsRUFBRSxnQkFBZ0IsQ0FBQyxVQUFVO2lCQUNwQyxHQUFHLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FDbkIsK0JBQStCLENBQzdCLElBQUksQ0FBQyxnQkFBZ0IsQ0FDbkIsYUFBYSxFQUNiLFVBQVUsRUFDVixhQUFhLEVBQ2IsZ0JBQWdCLENBQ2pCLEVBQ0QsYUFBYSxFQUNiLGFBQWEsQ0FDZCxDQUNGO2lCQUNBLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBZ0I7U0FDakMsQ0FBQztJQUNKLENBQUM7SUFFRCxnQkFBZ0IsQ0FDZCxhQUE0QixFQUM1QixVQUFnQyxFQUNoQyxhQUFrQyxFQUNsQyxnQkFBNkI7UUFFN0IsUUFBUSxhQUFhLENBQUMsSUFBSSxFQUFFO1lBQzFCLEtBQUssY0FBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUNmLE1BQU0sSUFBSSxHQUFHLGFBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO2dCQUN0QyxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsS0FBSztvQkFDL0IsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsS0FBSztvQkFDM0IsQ0FBQyxDQUFDLFNBQVMsQ0FBQztnQkFFZCxNQUFNLFFBQVEsR0FBRyxxQkFBVyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLGFBQWEsQ0FBQyxDQUFDO2dCQUNyRSxJQUFJLENBQUMsUUFBUSxFQUFFO29CQUNiLE1BQU0sSUFBSSxzQkFBWSxDQUNwQix1QkFBdUIsSUFBSSxjQUFjLE1BQU0sQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUM5RCxDQUFDLGFBQWEsQ0FBQyxDQUNoQixDQUFDO2lCQUNIO2dCQUVELE1BQU0sU0FBUyxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUM7Z0JBQ2hDLE1BQU0sbUJBQW1CLEdBQUcsc0JBQVksQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFFcEQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO2dCQUV0QyxNQUFNLEVBQUUsV0FBVyxFQUFFLFlBQVksRUFBRSxpQkFBaUIsRUFBRSxHQUFHLFFBQVEsQ0FBQztnQkFFbEUsTUFBTSxXQUFXLEdBQUcsS0FBSyxJQUFJLElBQUksQ0FBQztnQkFFbEMsTUFBTSxJQUFJLEdBQ1IsYUFBYSxDQUFDLFNBQVMsSUFBSSxhQUFhLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDO29CQUMzRCxDQUFDLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUU7d0JBQ2hDLE1BQU0sSUFBSSxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO3dCQUM1QixNQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FDL0IsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxLQUFLLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUN6QyxDQUFDO3dCQUNGLE9BQU87NEJBQ0wsSUFBSTs0QkFDSixLQUFLLEVBQUUsNEJBQWtCLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQzs0QkFDcEMsSUFBSSxFQUFFLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxTQUFTO3lCQUMzQyxDQUFDO29CQUNKLENBQUMsQ0FBQztvQkFDSixDQUFDLENBQUMsU0FBUyxDQUFDO2dCQUVoQixJQUFJLEtBQUssR0FBVTtvQkFDakIsSUFBSSxFQUFFLE9BQU87b0JBQ2IsV0FBVztvQkFDWCxJQUFJO29CQUNKLEtBQUs7b0JBQ0wsSUFBSTtvQkFDSixJQUFJLEVBQUUsU0FBUztvQkFDZixXQUFXLEVBQ1QsQ0FBQyx5QkFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxTQUFTO29CQUNqRSxZQUFZO29CQUNaLGlCQUFpQixFQUFFLGlCQUFpQixJQUFJLFNBQVM7aUJBQ2xELENBQUM7Z0JBRUYsSUFBSSx5QkFBZSxDQUFDLG1CQUFtQixDQUFDLEVBQUU7b0JBQ3hDLE1BQU0sZ0JBQWdCLEdBQUcsYUFBYSxDQUFDLFlBQVksQ0FBQztvQkFDcEQsSUFBSSxDQUFDLGdCQUFnQixFQUFFO3dCQUNyQixNQUFNLElBQUksc0JBQVksQ0FDcEIsb0JBQW9CLElBQUksY0FBYyxNQUFNLENBQzFDLFVBQVUsQ0FDWCwwQkFBMEIsRUFDM0IsQ0FBQyxhQUFhLENBQUMsQ0FDaEIsQ0FBQztxQkFDSDtvQkFFRCxLQUFLLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FDM0MsYUFBYSxDQUFDLFlBQWdDLEVBQzlDLG1CQUFtQixDQUNwQixDQUFDO2lCQUNIO2dCQUNELE9BQU8sS0FBSyxDQUFDO2FBQ2Q7WUFDRCxLQUFLLGNBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztnQkFDekIsTUFBTSxRQUFRLEdBQUcsYUFBYSxDQUFDLGFBQWEsQ0FBQztnQkFDN0MsTUFBTSxJQUFJLEdBQUcsUUFBUTtvQkFDbkIsQ0FBQyxDQUFFLHFCQUFXLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQTBCO29CQUM5RCxDQUFDLENBQUMsVUFBVSxDQUFDO2dCQUNmLE1BQU0sNkJBQTZCLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUM3RCxJQUFJLENBQ0wsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7Z0JBQy9DLE9BQU87b0JBQ0wsSUFBSSxFQUFFLGVBQWU7b0JBQ3JCLElBQUk7b0JBQ0osWUFBWSxFQUFFLElBQUksQ0FBQyxtQkFBbUIsQ0FDcEMsYUFBYSxDQUFDLFlBQVksRUFDMUIsSUFBSSxFQUNKLDZCQUE2QixDQUM5QjtpQkFDRixDQUFDO2FBQ0g7WUFDRCxLQUFLLGNBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztnQkFDekIsTUFBTSxZQUFZLEdBQUcsYUFBYSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7Z0JBQzlDLElBQUksZ0JBQWdCLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQztvQkFBRSxPQUFPLElBQUksQ0FBQztnQkFDcEQsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDO2dCQUVuQyxNQUFNLGNBQWMsR0FBbUI7b0JBQ3JDLElBQUksRUFBRSxnQkFBZ0I7b0JBQ3RCLFlBQVk7b0JBQ1osWUFBWSxFQUFFO3dCQUNaLGFBQWE7d0JBQ2IsVUFBVSxFQUFFLEVBQUU7cUJBQ2Y7aUJBQ0YsQ0FBQztnQkFDRixJQUFJLENBQUMseUJBQXlCLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO2dCQUNwRCxPQUFPLGNBQWMsQ0FBQzthQUN2QjtTQUNGO0lBQ0gsQ0FBQztJQUVELG9CQUFvQixDQUFDLElBQTBCO1FBQzdDLElBQUksd0JBQWMsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUN4QixPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUM3RDthQUFNO1lBQ0wsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ2Y7SUFDSCxDQUFDO0NBQ0Y7QUFFRCx5Q0FDRSxTQUEyQixFQUMzQixhQUE0QixFQUM1QixhQUFrQztJQUVsQyxJQUFJLENBQUMsU0FBUztRQUFFLE9BQU8sSUFBSSxDQUFDO0lBRTVCLElBQUksQ0FBQyxhQUFhLENBQUMsVUFBVTtRQUFFLE9BQU8sU0FBUyxDQUFDO0lBRWhELEtBQUssTUFBTSxTQUFTLElBQUksYUFBYSxDQUFDLFVBQVUsRUFBRTtRQUNoRCxNQUFNLGFBQWEsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztRQUUzQyxJQUFJLGFBQWEsS0FBSyxNQUFNLElBQUksYUFBYSxLQUFLLFNBQVMsRUFBRTtZQUMzRCxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVM7Z0JBQUUsU0FBUztZQUVuQyxNQUFNLEtBQUssR0FBRyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztZQUUzQyxRQUFRLEtBQUssQ0FBQyxJQUFJLEVBQUU7Z0JBQ2xCLEtBQUssY0FBYztvQkFDakIsSUFBSSxhQUFhLEtBQUssTUFBTSxFQUFFO3dCQUM1QixPQUFPLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO3FCQUN2Qzt5QkFBTTt3QkFDTCxPQUFPLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO3FCQUN2QztvQkFDRCxNQUFNO2dCQUNSLEtBQUssVUFBVTtvQkFDYixTQUFTLEdBQUc7d0JBQ1YsSUFBSSxFQUFFLGtCQUFrQjt3QkFDeEIsWUFBWSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSzt3QkFDOUIsUUFBUSxFQUFFLGFBQWEsS0FBSyxNQUFNO3dCQUNsQyxZQUFZLEVBQUU7NEJBQ1osYUFBYTs0QkFDYixVQUFVLEVBQUUsQ0FBQyxTQUFTLENBQUM7eUJBQ3hCO3FCQUNGLENBQUM7b0JBQ0YsTUFBTTthQUNUO1NBQ0Y7S0FDRjtJQUVELE9BQU8sU0FBUyxDQUFDO0FBQ25CLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBwcmludCxcbiAgdHlwZUZyb21BU1QsXG4gIGdldE5hbWVkVHlwZSxcbiAgaXNBYnN0cmFjdFR5cGUsXG4gIEtpbmQsXG4gIGlzQ29tcG9zaXRlVHlwZSxcbiAgR3JhcGhRTE91dHB1dFR5cGUsXG4gIEdyYXBoUUxJbnB1dFR5cGUsXG4gIEdyYXBoUUxTY2FsYXJUeXBlLFxuICBHcmFwaFFMRW51bVR5cGUsXG4gIEdyYXBoUUxJbnB1dE9iamVjdFR5cGUsXG4gIEdyYXBoUUxPYmplY3RUeXBlLFxuICBHcmFwaFFMRXJyb3IsXG4gIEdyYXBoUUxTY2hlbWEsXG4gIEdyYXBoUUxUeXBlLFxuICBHcmFwaFFMQ29tcG9zaXRlVHlwZSxcbiAgRG9jdW1lbnROb2RlLFxuICBPcGVyYXRpb25EZWZpbml0aW9uTm9kZSxcbiAgRnJhZ21lbnREZWZpbml0aW9uTm9kZSxcbiAgU2VsZWN0aW9uU2V0Tm9kZSxcbiAgU2VsZWN0aW9uTm9kZSxcbiAgaXNTcGVjaWZpZWRTY2FsYXJUeXBlLFxuICBOb25OdWxsVHlwZU5vZGUsXG4gIEdyYXBoUUxOb25OdWxsXG59IGZyb20gXCJncmFwaHFsXCI7XG5cbmltcG9ydCB7XG4gIGdldE9wZXJhdGlvblJvb3RUeXBlLFxuICBnZXRGaWVsZERlZixcbiAgdmFsdWVGcm9tVmFsdWVOb2RlLFxuICBmaWxlUGF0aEZvck5vZGUsXG4gIHdpdGhUeXBlbmFtZUZpZWxkQWRkZWRXaGVyZU5lZWRlZCxcbiAgaXNNZXRhRmllbGROYW1lXG59IGZyb20gXCIuLi91dGlsaXRpZXMvZ3JhcGhxbFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBpbGVyT3B0aW9ucyB7XG4gIGFkZFR5cGVuYW1lPzogYm9vbGVhbjtcbiAgbWVyZ2VJbkZpZWxkc0Zyb21GcmFnbWVudFNwcmVhZHM/OiBib29sZWFuO1xuICBwYXNzdGhyb3VnaEN1c3RvbVNjYWxhcnM/OiBib29sZWFuO1xuICBjdXN0b21TY2FsYXJzUHJlZml4Pzogc3RyaW5nO1xuICBuYW1lc3BhY2U/OiBzdHJpbmc7XG4gIGdlbmVyYXRlT3BlcmF0aW9uSWRzPzogYm9vbGVhbjtcbiAgb3BlcmF0aW9uSWRzUGF0aD86IHN0cmluZztcbiAgYWRkUzNXcmFwcGVyPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21waWxlckNvbnRleHQge1xuICBzY2hlbWE6IEdyYXBoUUxTY2hlbWE7XG4gIHR5cGVzVXNlZDogR3JhcGhRTFR5cGVbXTtcbiAgb3BlcmF0aW9uczogeyBbb3BlcmF0aW9uTmFtZTogc3RyaW5nXTogT3BlcmF0aW9uIH07XG4gIGZyYWdtZW50czogeyBbZnJhZ21lbnROYW1lOiBzdHJpbmddOiBGcmFnbWVudCB9O1xuICBvcHRpb25zOiBDb21waWxlck9wdGlvbnM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3BlcmF0aW9uIHtcbiAgb3BlcmF0aW9uSWQ/OiBzdHJpbmc7XG4gIG9wZXJhdGlvbk5hbWU6IHN0cmluZztcbiAgb3BlcmF0aW9uVHlwZTogc3RyaW5nO1xuICB2YXJpYWJsZXM6IHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgdHlwZTogR3JhcGhRTFR5cGU7XG4gIH1bXTtcbiAgZmlsZVBhdGg6IHN0cmluZztcbiAgc291cmNlOiBzdHJpbmc7XG4gIHJvb3RUeXBlOiBHcmFwaFFMT2JqZWN0VHlwZTtcbiAgc2VsZWN0aW9uU2V0OiBTZWxlY3Rpb25TZXQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnJhZ21lbnQge1xuICBmaWxlUGF0aDogc3RyaW5nO1xuICBmcmFnbWVudE5hbWU6IHN0cmluZztcbiAgc291cmNlOiBzdHJpbmc7XG4gIHR5cGU6IEdyYXBoUUxDb21wb3NpdGVUeXBlO1xuICBzZWxlY3Rpb25TZXQ6IFNlbGVjdGlvblNldDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZWxlY3Rpb25TZXQge1xuICBwb3NzaWJsZVR5cGVzOiBHcmFwaFFMT2JqZWN0VHlwZVtdO1xuICBzZWxlY3Rpb25zOiBTZWxlY3Rpb25bXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBcmd1bWVudCB7XG4gIG5hbWU6IHN0cmluZztcbiAgdmFsdWU6IGFueTtcbiAgdHlwZT86IEdyYXBoUUxJbnB1dFR5cGU7XG59XG5cbmV4cG9ydCB0eXBlIFNlbGVjdGlvbiA9XG4gIHwgRmllbGRcbiAgfCBUeXBlQ29uZGl0aW9uXG4gIHwgQm9vbGVhbkNvbmRpdGlvblxuICB8IEZyYWdtZW50U3ByZWFkO1xuXG5leHBvcnQgaW50ZXJmYWNlIEZpZWxkIHtcbiAga2luZDogXCJGaWVsZFwiO1xuICByZXNwb25zZUtleTogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGFsaWFzPzogc3RyaW5nO1xuICBhcmdzPzogQXJndW1lbnRbXTtcbiAgdHlwZTogR3JhcGhRTE91dHB1dFR5cGU7XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICBpc0RlcHJlY2F0ZWQ/OiBib29sZWFuO1xuICBkZXByZWNhdGlvblJlYXNvbj86IHN0cmluZztcbiAgaXNDb25kaXRpb25hbD86IGJvb2xlYW47XG4gIHNlbGVjdGlvblNldD86IFNlbGVjdGlvblNldDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUeXBlQ29uZGl0aW9uIHtcbiAga2luZDogXCJUeXBlQ29uZGl0aW9uXCI7XG4gIHR5cGU6IEdyYXBoUUxDb21wb3NpdGVUeXBlO1xuICBzZWxlY3Rpb25TZXQ6IFNlbGVjdGlvblNldDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCb29sZWFuQ29uZGl0aW9uIHtcbiAga2luZDogXCJCb29sZWFuQ29uZGl0aW9uXCI7XG4gIHZhcmlhYmxlTmFtZTogc3RyaW5nO1xuICBpbnZlcnRlZDogYm9vbGVhbjtcbiAgc2VsZWN0aW9uU2V0OiBTZWxlY3Rpb25TZXQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnJhZ21lbnRTcHJlYWQge1xuICBraW5kOiBcIkZyYWdtZW50U3ByZWFkXCI7XG4gIGZyYWdtZW50TmFtZTogc3RyaW5nO1xuICBpc0NvbmRpdGlvbmFsPzogYm9vbGVhbjtcbiAgc2VsZWN0aW9uU2V0OiBTZWxlY3Rpb25TZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21waWxlVG9JUihcbiAgc2NoZW1hOiBHcmFwaFFMU2NoZW1hLFxuICBkb2N1bWVudDogRG9jdW1lbnROb2RlLFxuICBvcHRpb25zOiBDb21waWxlck9wdGlvbnMgPSB7fVxuKTogQ29tcGlsZXJDb250ZXh0IHtcbiAgaWYgKG9wdGlvbnMuYWRkVHlwZW5hbWUpIHtcbiAgICBkb2N1bWVudCA9IHdpdGhUeXBlbmFtZUZpZWxkQWRkZWRXaGVyZU5lZWRlZChkb2N1bWVudCk7XG4gIH1cblxuICBjb25zdCBjb21waWxlciA9IG5ldyBDb21waWxlcihzY2hlbWEsIG9wdGlvbnMpO1xuXG4gIGNvbnN0IG9wZXJhdGlvbnM6IHsgW29wZXJhdGlvbk5hbWU6IHN0cmluZ106IE9wZXJhdGlvbiB9ID0gT2JqZWN0LmNyZWF0ZShcbiAgICBudWxsXG4gICk7XG4gIGNvbnN0IGZyYWdtZW50czogeyBbZnJhZ21lbnROYW1lOiBzdHJpbmddOiBGcmFnbWVudCB9ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmb3IgKGNvbnN0IGRlZmluaXRpb24gb2YgZG9jdW1lbnQuZGVmaW5pdGlvbnMpIHtcbiAgICBzd2l0Y2ggKGRlZmluaXRpb24ua2luZCkge1xuICAgICAgY2FzZSBLaW5kLk9QRVJBVElPTl9ERUZJTklUSU9OOlxuICAgICAgICBjb25zdCBvcGVyYXRpb24gPSBjb21waWxlci5jb21waWxlT3BlcmF0aW9uKGRlZmluaXRpb24pO1xuICAgICAgICBvcGVyYXRpb25zW29wZXJhdGlvbi5vcGVyYXRpb25OYW1lXSA9IG9wZXJhdGlvbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtpbmQuRlJBR01FTlRfREVGSU5JVElPTjpcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb21waWxlci5jb21waWxlRnJhZ21lbnQoZGVmaW5pdGlvbik7XG4gICAgICAgIGZyYWdtZW50c1tmcmFnbWVudC5mcmFnbWVudE5hbWVdID0gZnJhZ21lbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3QgZnJhZ21lbnRTcHJlYWQgb2YgY29tcGlsZXIudW5yZXNvbHZlZEZyYWdtZW50U3ByZWFkcykge1xuICAgIGNvbnN0IGZyYWdtZW50ID0gZnJhZ21lbnRzW2ZyYWdtZW50U3ByZWFkLmZyYWdtZW50TmFtZV07XG4gICAgaWYgKCFmcmFnbWVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBmcmFnbWVudCBcIiR7ZnJhZ21lbnRTcHJlYWQuZnJhZ21lbnROYW1lfVwiYCk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdGhlIHBvc3NpYmxldyB0eXBlcyBvZiB0aGUgZnJhZ21lbnQgc3ByZWFkIGFuZCB0aGUgZnJhZ21lbnQuXG4gICAgY29uc3QgcG9zc2libGVUeXBlcyA9IGZyYWdtZW50LnNlbGVjdGlvblNldC5wb3NzaWJsZVR5cGVzLmZpbHRlcih0eXBlID0+XG4gICAgICBmcmFnbWVudFNwcmVhZC5zZWxlY3Rpb25TZXQucG9zc2libGVUeXBlcy5pbmNsdWRlcyh0eXBlKVxuICAgICk7XG5cbiAgICBmcmFnbWVudFNwcmVhZC5pc0NvbmRpdGlvbmFsID0gZnJhZ21lbnQuc2VsZWN0aW9uU2V0LnBvc3NpYmxlVHlwZXMuc29tZShcbiAgICAgIHR5cGUgPT4gIWZyYWdtZW50U3ByZWFkLnNlbGVjdGlvblNldC5wb3NzaWJsZVR5cGVzLmluY2x1ZGVzKHR5cGUpXG4gICAgKTtcblxuICAgIGZyYWdtZW50U3ByZWFkLnNlbGVjdGlvblNldCA9IHtcbiAgICAgIHBvc3NpYmxlVHlwZXMsXG4gICAgICBzZWxlY3Rpb25zOiBmcmFnbWVudC5zZWxlY3Rpb25TZXQuc2VsZWN0aW9uc1xuICAgIH07XG4gIH1cblxuICBjb25zdCB0eXBlc1VzZWQgPSBjb21waWxlci50eXBlc1VzZWQ7XG5cbiAgcmV0dXJuIHsgc2NoZW1hLCB0eXBlc1VzZWQsIG9wZXJhdGlvbnMsIGZyYWdtZW50cywgb3B0aW9ucyB9O1xufVxuXG5jbGFzcyBDb21waWxlciB7XG4gIG9wdGlvbnM6IENvbXBpbGVyT3B0aW9ucztcbiAgc2NoZW1hOiBHcmFwaFFMU2NoZW1hO1xuICB0eXBlc1VzZWRTZXQ6IFNldDxHcmFwaFFMVHlwZT47XG5cbiAgdW5yZXNvbHZlZEZyYWdtZW50U3ByZWFkczogRnJhZ21lbnRTcHJlYWRbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKHNjaGVtYTogR3JhcGhRTFNjaGVtYSwgb3B0aW9uczogQ29tcGlsZXJPcHRpb25zKSB7XG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIHRoaXMudHlwZXNVc2VkU2V0ID0gbmV3IFNldCgpO1xuICB9XG5cbiAgYWRkVHlwZVVzZWQodHlwZTogR3JhcGhRTFR5cGUpIHtcbiAgICBpZiAodGhpcy50eXBlc1VzZWRTZXQuaGFzKHR5cGUpKSByZXR1cm47XG5cbiAgICBpZiAoXG4gICAgICB0eXBlIGluc3RhbmNlb2YgR3JhcGhRTEVudW1UeXBlIHx8XG4gICAgICB0eXBlIGluc3RhbmNlb2YgR3JhcGhRTElucHV0T2JqZWN0VHlwZSB8fFxuICAgICAgKHR5cGUgaW5zdGFuY2VvZiBHcmFwaFFMU2NhbGFyVHlwZSAmJiAhaXNTcGVjaWZpZWRTY2FsYXJUeXBlKHR5cGUpKVxuICAgICkge1xuICAgICAgdGhpcy50eXBlc1VzZWRTZXQuYWRkKHR5cGUpO1xuICAgIH1cbiAgICBpZiAodHlwZSBpbnN0YW5jZW9mIEdyYXBoUUxJbnB1dE9iamVjdFR5cGUpIHtcbiAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgT2JqZWN0LnZhbHVlcyh0eXBlLmdldEZpZWxkcygpKSkge1xuICAgICAgICB0aGlzLmFkZFR5cGVVc2VkKGdldE5hbWVkVHlwZShmaWVsZC50eXBlKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0IHR5cGVzVXNlZCgpOiBHcmFwaFFMVHlwZVtdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnR5cGVzVXNlZFNldCk7XG4gIH1cblxuICBjb21waWxlT3BlcmF0aW9uKG9wZXJhdGlvbkRlZmluaXRpb246IE9wZXJhdGlvbkRlZmluaXRpb25Ob2RlKTogT3BlcmF0aW9uIHtcbiAgICBpZiAoIW9wZXJhdGlvbkRlZmluaXRpb24ubmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3BlcmF0aW9ucyBzaG91bGQgYmUgbmFtZWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgZmlsZVBhdGggPSBmaWxlUGF0aEZvck5vZGUob3BlcmF0aW9uRGVmaW5pdGlvbik7XG4gICAgY29uc3Qgb3BlcmF0aW9uTmFtZSA9IG9wZXJhdGlvbkRlZmluaXRpb24ubmFtZS52YWx1ZTtcbiAgICBjb25zdCBvcGVyYXRpb25UeXBlID0gb3BlcmF0aW9uRGVmaW5pdGlvbi5vcGVyYXRpb247XG5cbiAgICBjb25zdCB2YXJpYWJsZXMgPSAob3BlcmF0aW9uRGVmaW5pdGlvbi52YXJpYWJsZURlZmluaXRpb25zIHx8IFtdKS5tYXAoXG4gICAgICBub2RlID0+IHtcbiAgICAgICAgY29uc3QgbmFtZSA9IG5vZGUudmFyaWFibGUubmFtZS52YWx1ZTtcbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVGcm9tQVNUKHRoaXMuc2NoZW1hLCBub2RlLnR5cGUgYXMgTm9uTnVsbFR5cGVOb2RlKTtcbiAgICAgICAgdGhpcy5hZGRUeXBlVXNlZChnZXROYW1lZFR5cGUodHlwZSBhcyBHcmFwaFFMVHlwZSkpO1xuICAgICAgICByZXR1cm4geyBuYW1lLCB0eXBlOiB0eXBlIGFzIEdyYXBoUUxOb25OdWxsPGFueT4gfTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgY29uc3Qgc291cmNlID0gcHJpbnQob3BlcmF0aW9uRGVmaW5pdGlvbik7XG4gICAgY29uc3Qgcm9vdFR5cGUgPSBnZXRPcGVyYXRpb25Sb290VHlwZShcbiAgICAgIHRoaXMuc2NoZW1hLFxuICAgICAgb3BlcmF0aW9uRGVmaW5pdGlvblxuICAgICkgYXMgR3JhcGhRTE9iamVjdFR5cGU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZmlsZVBhdGgsXG4gICAgICBvcGVyYXRpb25OYW1lLFxuICAgICAgb3BlcmF0aW9uVHlwZSxcbiAgICAgIHZhcmlhYmxlcyxcbiAgICAgIHNvdXJjZSxcbiAgICAgIHJvb3RUeXBlLFxuICAgICAgc2VsZWN0aW9uU2V0OiB0aGlzLmNvbXBpbGVTZWxlY3Rpb25TZXQoXG4gICAgICAgIG9wZXJhdGlvbkRlZmluaXRpb24uc2VsZWN0aW9uU2V0LFxuICAgICAgICByb290VHlwZVxuICAgICAgKVxuICAgIH07XG4gIH1cblxuICBjb21waWxlRnJhZ21lbnQoZnJhZ21lbnREZWZpbml0aW9uOiBGcmFnbWVudERlZmluaXRpb25Ob2RlKTogRnJhZ21lbnQge1xuICAgIGNvbnN0IGZyYWdtZW50TmFtZSA9IGZyYWdtZW50RGVmaW5pdGlvbi5uYW1lLnZhbHVlO1xuXG4gICAgY29uc3QgZmlsZVBhdGggPSBmaWxlUGF0aEZvck5vZGUoZnJhZ21lbnREZWZpbml0aW9uKTtcbiAgICBjb25zdCBzb3VyY2UgPSBwcmludChmcmFnbWVudERlZmluaXRpb24pO1xuXG4gICAgY29uc3QgdHlwZSA9IHR5cGVGcm9tQVNUKFxuICAgICAgdGhpcy5zY2hlbWEsXG4gICAgICBmcmFnbWVudERlZmluaXRpb24udHlwZUNvbmRpdGlvblxuICAgICkgYXMgR3JhcGhRTENvbXBvc2l0ZVR5cGU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZnJhZ21lbnROYW1lLFxuICAgICAgZmlsZVBhdGgsXG4gICAgICBzb3VyY2UsXG4gICAgICB0eXBlLFxuICAgICAgc2VsZWN0aW9uU2V0OiB0aGlzLmNvbXBpbGVTZWxlY3Rpb25TZXQoXG4gICAgICAgIGZyYWdtZW50RGVmaW5pdGlvbi5zZWxlY3Rpb25TZXQsXG4gICAgICAgIHR5cGVcbiAgICAgIClcbiAgICB9O1xuICB9XG5cbiAgY29tcGlsZVNlbGVjdGlvblNldChcbiAgICBzZWxlY3Rpb25TZXROb2RlOiBTZWxlY3Rpb25TZXROb2RlLFxuICAgIHBhcmVudFR5cGU6IEdyYXBoUUxDb21wb3NpdGVUeXBlLFxuICAgIHBvc3NpYmxlVHlwZXM6IEdyYXBoUUxPYmplY3RUeXBlW10gPSB0aGlzLnBvc3NpYmxlVHlwZXNGb3JUeXBlKHBhcmVudFR5cGUpLFxuICAgIHZpc2l0ZWRGcmFnbWVudHM6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpXG4gICk6IFNlbGVjdGlvblNldCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc3NpYmxlVHlwZXMsXG4gICAgICBzZWxlY3Rpb25zOiBzZWxlY3Rpb25TZXROb2RlLnNlbGVjdGlvbnNcbiAgICAgICAgLm1hcChzZWxlY3Rpb25Ob2RlID0+XG4gICAgICAgICAgd3JhcEluQm9vbGVhbkNvbmRpdGlvbnNJZk5lZWRlZChcbiAgICAgICAgICAgIHRoaXMuY29tcGlsZVNlbGVjdGlvbihcbiAgICAgICAgICAgICAgc2VsZWN0aW9uTm9kZSxcbiAgICAgICAgICAgICAgcGFyZW50VHlwZSxcbiAgICAgICAgICAgICAgcG9zc2libGVUeXBlcyxcbiAgICAgICAgICAgICAgdmlzaXRlZEZyYWdtZW50c1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHNlbGVjdGlvbk5vZGUsXG4gICAgICAgICAgICBwb3NzaWJsZVR5cGVzXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICAgIC5maWx0ZXIoeCA9PiB4KSBhcyBTZWxlY3Rpb25bXVxuICAgIH07XG4gIH1cblxuICBjb21waWxlU2VsZWN0aW9uKFxuICAgIHNlbGVjdGlvbk5vZGU6IFNlbGVjdGlvbk5vZGUsXG4gICAgcGFyZW50VHlwZTogR3JhcGhRTENvbXBvc2l0ZVR5cGUsXG4gICAgcG9zc2libGVUeXBlczogR3JhcGhRTE9iamVjdFR5cGVbXSxcbiAgICB2aXNpdGVkRnJhZ21lbnRzOiBTZXQ8c3RyaW5nPlxuICApOiBTZWxlY3Rpb24gfCBudWxsIHtcbiAgICBzd2l0Y2ggKHNlbGVjdGlvbk5vZGUua2luZCkge1xuICAgICAgY2FzZSBLaW5kLkZJRUxEOiB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBzZWxlY3Rpb25Ob2RlLm5hbWUudmFsdWU7XG4gICAgICAgIGNvbnN0IGFsaWFzID0gc2VsZWN0aW9uTm9kZS5hbGlhc1xuICAgICAgICAgID8gc2VsZWN0aW9uTm9kZS5hbGlhcy52YWx1ZVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGNvbnN0IGZpZWxkRGVmID0gZ2V0RmllbGREZWYodGhpcy5zY2hlbWEsIHBhcmVudFR5cGUsIHNlbGVjdGlvbk5vZGUpO1xuICAgICAgICBpZiAoIWZpZWxkRGVmKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgIGBDYW5ub3QgcXVlcnkgZmllbGQgXCIke25hbWV9XCIgb24gdHlwZSBcIiR7U3RyaW5nKHBhcmVudFR5cGUpfVwiYCxcbiAgICAgICAgICAgIFtzZWxlY3Rpb25Ob2RlXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmaWVsZFR5cGUgPSBmaWVsZERlZi50eXBlO1xuICAgICAgICBjb25zdCB1bm1vZGlmaWVkRmllbGRUeXBlID0gZ2V0TmFtZWRUeXBlKGZpZWxkVHlwZSk7XG5cbiAgICAgICAgdGhpcy5hZGRUeXBlVXNlZCh1bm1vZGlmaWVkRmllbGRUeXBlKTtcblxuICAgICAgICBjb25zdCB7IGRlc2NyaXB0aW9uLCBpc0RlcHJlY2F0ZWQsIGRlcHJlY2F0aW9uUmVhc29uIH0gPSBmaWVsZERlZjtcblxuICAgICAgICBjb25zdCByZXNwb25zZUtleSA9IGFsaWFzIHx8IG5hbWU7XG5cbiAgICAgICAgY29uc3QgYXJncyA9XG4gICAgICAgICAgc2VsZWN0aW9uTm9kZS5hcmd1bWVudHMgJiYgc2VsZWN0aW9uTm9kZS5hcmd1bWVudHMubGVuZ3RoID4gMFxuICAgICAgICAgICAgPyBzZWxlY3Rpb25Ob2RlLmFyZ3VtZW50cy5tYXAoYXJnID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYXJnLm5hbWUudmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJnRGVmID0gZmllbGREZWYuYXJncy5maW5kKFxuICAgICAgICAgICAgICAgICAgYXJnRGVmID0+IGFyZ0RlZi5uYW1lID09PSBhcmcubmFtZS52YWx1ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVGcm9tVmFsdWVOb2RlKGFyZy52YWx1ZSksXG4gICAgICAgICAgICAgICAgICB0eXBlOiAoYXJnRGVmICYmIGFyZ0RlZi50eXBlKSB8fCB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgbGV0IGZpZWxkOiBGaWVsZCA9IHtcbiAgICAgICAgICBraW5kOiBcIkZpZWxkXCIsXG4gICAgICAgICAgcmVzcG9uc2VLZXksXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBhbGlhcyxcbiAgICAgICAgICBhcmdzLFxuICAgICAgICAgIHR5cGU6IGZpZWxkVHlwZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAgICFpc01ldGFGaWVsZE5hbWUobmFtZSkgJiYgZGVzY3JpcHRpb24gPyBkZXNjcmlwdGlvbiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBpc0RlcHJlY2F0ZWQsXG4gICAgICAgICAgZGVwcmVjYXRpb25SZWFzb246IGRlcHJlY2F0aW9uUmVhc29uIHx8IHVuZGVmaW5lZFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpc0NvbXBvc2l0ZVR5cGUodW5tb2RpZmllZEZpZWxkVHlwZSkpIHtcbiAgICAgICAgICBjb25zdCBzZWxlY3Rpb25TZXROb2RlID0gc2VsZWN0aW9uTm9kZS5zZWxlY3Rpb25TZXQ7XG4gICAgICAgICAgaWYgKCFzZWxlY3Rpb25TZXROb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgICBgQ29tcG9zaXRlIGZpZWxkIFwiJHtuYW1lfVwiIG9uIHR5cGUgXCIke1N0cmluZyhcbiAgICAgICAgICAgICAgICBwYXJlbnRUeXBlXG4gICAgICAgICAgICAgICl9XCIgcmVxdWlyZXMgc2VsZWN0aW9uIHNldGAsXG4gICAgICAgICAgICAgIFtzZWxlY3Rpb25Ob2RlXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaWVsZC5zZWxlY3Rpb25TZXQgPSB0aGlzLmNvbXBpbGVTZWxlY3Rpb25TZXQoXG4gICAgICAgICAgICBzZWxlY3Rpb25Ob2RlLnNlbGVjdGlvblNldCBhcyBTZWxlY3Rpb25TZXROb2RlLFxuICAgICAgICAgICAgdW5tb2RpZmllZEZpZWxkVHlwZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkO1xuICAgICAgfVxuICAgICAgY2FzZSBLaW5kLklOTElORV9GUkFHTUVOVDoge1xuICAgICAgICBjb25zdCB0eXBlTm9kZSA9IHNlbGVjdGlvbk5vZGUudHlwZUNvbmRpdGlvbjtcbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVOb2RlXG4gICAgICAgICAgPyAodHlwZUZyb21BU1QodGhpcy5zY2hlbWEsIHR5cGVOb2RlKSBhcyBHcmFwaFFMQ29tcG9zaXRlVHlwZSlcbiAgICAgICAgICA6IHBhcmVudFR5cGU7XG4gICAgICAgIGNvbnN0IHBvc3NpYmxlVHlwZXNGb3JUeXBlQ29uZGl0aW9uID0gdGhpcy5wb3NzaWJsZVR5cGVzRm9yVHlwZShcbiAgICAgICAgICB0eXBlXG4gICAgICAgICkuZmlsdGVyKHR5cGUgPT4gcG9zc2libGVUeXBlcy5pbmNsdWRlcyh0eXBlKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAga2luZDogXCJUeXBlQ29uZGl0aW9uXCIsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBzZWxlY3Rpb25TZXQ6IHRoaXMuY29tcGlsZVNlbGVjdGlvblNldChcbiAgICAgICAgICAgIHNlbGVjdGlvbk5vZGUuc2VsZWN0aW9uU2V0LFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHBvc3NpYmxlVHlwZXNGb3JUeXBlQ29uZGl0aW9uXG4gICAgICAgICAgKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY2FzZSBLaW5kLkZSQUdNRU5UX1NQUkVBRDoge1xuICAgICAgICBjb25zdCBmcmFnbWVudE5hbWUgPSBzZWxlY3Rpb25Ob2RlLm5hbWUudmFsdWU7XG4gICAgICAgIGlmICh2aXNpdGVkRnJhZ21lbnRzLmhhcyhmcmFnbWVudE5hbWUpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmlzaXRlZEZyYWdtZW50cy5hZGQoZnJhZ21lbnROYW1lKTtcblxuICAgICAgICBjb25zdCBmcmFnbWVudFNwcmVhZDogRnJhZ21lbnRTcHJlYWQgPSB7XG4gICAgICAgICAga2luZDogXCJGcmFnbWVudFNwcmVhZFwiLFxuICAgICAgICAgIGZyYWdtZW50TmFtZSxcbiAgICAgICAgICBzZWxlY3Rpb25TZXQ6IHtcbiAgICAgICAgICAgIHBvc3NpYmxlVHlwZXMsXG4gICAgICAgICAgICBzZWxlY3Rpb25zOiBbXVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51bnJlc29sdmVkRnJhZ21lbnRTcHJlYWRzLnB1c2goZnJhZ21lbnRTcHJlYWQpO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnRTcHJlYWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcG9zc2libGVUeXBlc0ZvclR5cGUodHlwZTogR3JhcGhRTENvbXBvc2l0ZVR5cGUpOiBHcmFwaFFMT2JqZWN0VHlwZVtdIHtcbiAgICBpZiAoaXNBYnN0cmFjdFR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuc2NoZW1hLmdldFBvc3NpYmxlVHlwZXModHlwZSkpIHx8IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW3R5cGVdO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3cmFwSW5Cb29sZWFuQ29uZGl0aW9uc0lmTmVlZGVkKFxuICBzZWxlY3Rpb246IFNlbGVjdGlvbiB8IG51bGwsXG4gIHNlbGVjdGlvbk5vZGU6IFNlbGVjdGlvbk5vZGUsXG4gIHBvc3NpYmxlVHlwZXM6IEdyYXBoUUxPYmplY3RUeXBlW11cbik6IFNlbGVjdGlvbiB8IG51bGwge1xuICBpZiAoIXNlbGVjdGlvbikgcmV0dXJuIG51bGw7XG5cbiAgaWYgKCFzZWxlY3Rpb25Ob2RlLmRpcmVjdGl2ZXMpIHJldHVybiBzZWxlY3Rpb247XG5cbiAgZm9yIChjb25zdCBkaXJlY3RpdmUgb2Ygc2VsZWN0aW9uTm9kZS5kaXJlY3RpdmVzKSB7XG4gICAgY29uc3QgZGlyZWN0aXZlTmFtZSA9IGRpcmVjdGl2ZS5uYW1lLnZhbHVlO1xuXG4gICAgaWYgKGRpcmVjdGl2ZU5hbWUgPT09IFwic2tpcFwiIHx8IGRpcmVjdGl2ZU5hbWUgPT09IFwiaW5jbHVkZVwiKSB7XG4gICAgICBpZiAoIWRpcmVjdGl2ZS5hcmd1bWVudHMpIGNvbnRpbnVlO1xuXG4gICAgICBjb25zdCB2YWx1ZSA9IGRpcmVjdGl2ZS5hcmd1bWVudHNbMF0udmFsdWU7XG5cbiAgICAgIHN3aXRjaCAodmFsdWUua2luZCkge1xuICAgICAgICBjYXNlIFwiQm9vbGVhblZhbHVlXCI6XG4gICAgICAgICAgaWYgKGRpcmVjdGl2ZU5hbWUgPT09IFwic2tpcFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudmFsdWUgPyBudWxsIDogc2VsZWN0aW9uO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudmFsdWUgPyBzZWxlY3Rpb24gOiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlZhcmlhYmxlXCI6XG4gICAgICAgICAgc2VsZWN0aW9uID0ge1xuICAgICAgICAgICAga2luZDogXCJCb29sZWFuQ29uZGl0aW9uXCIsXG4gICAgICAgICAgICB2YXJpYWJsZU5hbWU6IHZhbHVlLm5hbWUudmFsdWUsXG4gICAgICAgICAgICBpbnZlcnRlZDogZGlyZWN0aXZlTmFtZSA9PT0gXCJza2lwXCIsXG4gICAgICAgICAgICBzZWxlY3Rpb25TZXQ6IHtcbiAgICAgICAgICAgICAgcG9zc2libGVUeXBlcyxcbiAgICAgICAgICAgICAgc2VsZWN0aW9uczogW3NlbGVjdGlvbl1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxlY3Rpb247XG59Il19");"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const graphql_2 = require("../utilities/graphql");
function compileToIR(schema, document, options = {}) {
    if (options.addTypename) {
        document = graphql_2.withTypenameFieldAddedWhereNeeded(document);
    }
    const compiler = new Compiler(schema, options);
    const operations = Object.create(null);
    const fragments = Object.create(null);
    for (const definition of document.definitions) {
        switch (definition.kind) {
            case graphql_1.Kind.OPERATION_DEFINITION:
                const operation = compiler.compileOperation(definition);
                operations[operation.operationName] = operation;
                break;
            case graphql_1.Kind.FRAGMENT_DEFINITION:
                const fragment = compiler.compileFragment(definition);
                fragments[fragment.fragmentName] = fragment;
                break;}

    }
    for (const fragmentSpread of compiler.unresolvedFragmentSpreads) {
        const fragment = fragments[fragmentSpread.fragmentName];
        if (!fragment) {
            throw new Error(`Cannot find fragment "${fragmentSpread.fragmentName}"`);
        }
        const possibleTypes = fragment.selectionSet.possibleTypes.filter(type => fragmentSpread.selectionSet.possibleTypes.includes(type));
        fragmentSpread.isConditional = fragment.selectionSet.possibleTypes.some(type => !fragmentSpread.selectionSet.possibleTypes.includes(type));
        fragmentSpread.selectionSet = {
            possibleTypes,
            selections: fragment.selectionSet.selections };

    }
    const typesUsed = compiler.typesUsed;
    return { schema, typesUsed, operations, fragments, options };
}
exports.compileToIR = compileToIR;
class Compiler {
    constructor(schema, options) {
        this.unresolvedFragmentSpreads = [];
        this.schema = schema;
        this.options = options;
        this.typesUsedSet = new Set();
    }
    addTypeUsed(type) {
        if (this.typesUsedSet.has(type))
        return;
        if (type instanceof graphql_1.GraphQLEnumType ||
        type instanceof graphql_1.GraphQLInputObjectType ||
        type instanceof graphql_1.GraphQLScalarType && !graphql_1.isSpecifiedScalarType(type)) {
            this.typesUsedSet.add(type);
        }
        if (type instanceof graphql_1.GraphQLInputObjectType) {
            for (const field of Object.values(type.getFields())) {
                this.addTypeUsed(graphql_1.getNamedType(field.type));
            }
        }
    }
    get typesUsed() {
        return Array.from(this.typesUsedSet);
    }
    compileOperation(operationDefinition) {
        if (!operationDefinition.name) {
            throw new Error("Operations should be named");
        }
        const filePath = graphql_2.filePathForNode(operationDefinition);
        const operationName = operationDefinition.name.value;
        const operationType = operationDefinition.operation;
        const variables = (operationDefinition.variableDefinitions || []).map(node => {
            const name = node.variable.name.value;
            const type = graphql_1.typeFromAST(this.schema, node.type);
            this.addTypeUsed(graphql_1.getNamedType(type));
            return { name, type: type };
        });
        const source = graphql_1.print(operationDefinition);
        const rootType = graphql_2.getOperationRootType(this.schema, operationDefinition);
        return {
            filePath,
            operationName,
            operationType,
            variables,
            source,
            rootType,
            selectionSet: this.compileSelectionSet(operationDefinition.selectionSet, rootType) };

    }
    compileFragment(fragmentDefinition) {
        const fragmentName = fragmentDefinition.name.value;
        const filePath = graphql_2.filePathForNode(fragmentDefinition);
        const source = graphql_1.print(fragmentDefinition);
        const type = graphql_1.typeFromAST(this.schema, fragmentDefinition.typeCondition);
        return {
            fragmentName,
            filePath,
            source,
            type,
            selectionSet: this.compileSelectionSet(fragmentDefinition.selectionSet, type) };

    }
    compileSelectionSet(selectionSetNode, parentType, possibleTypes = this.possibleTypesForType(parentType), visitedFragments = new Set()) {
        return {
            possibleTypes,
            selections: selectionSetNode.selections.
            map(selectionNode => wrapInBooleanConditionsIfNeeded(this.compileSelection(selectionNode, parentType, possibleTypes, visitedFragments), selectionNode, possibleTypes)).
            filter(x => x) };

    }
    compileSelection(selectionNode, parentType, possibleTypes, visitedFragments) {
        switch (selectionNode.kind) {
            case graphql_1.Kind.FIELD:{
                    const name = selectionNode.name.value;
                    const alias = selectionNode.alias ?
                    selectionNode.alias.value :
                    undefined;
                    const fieldDef = graphql_2.getFieldDef(this.schema, parentType, selectionNode);
                    if (!fieldDef) {
                        throw new graphql_1.GraphQLError(`Cannot query field "${name}" on type "${String(parentType)}"`, [selectionNode]);
                    }
                    const fieldType = fieldDef.type;
                    const unmodifiedFieldType = graphql_1.getNamedType(fieldType);
                    this.addTypeUsed(unmodifiedFieldType);
                    const { description, isDeprecated, deprecationReason } = fieldDef;
                    const responseKey = alias || name;
                    const args = selectionNode.arguments && selectionNode.arguments.length > 0 ?
                    selectionNode.arguments.map(arg => {
                        const name = arg.name.value;
                        const argDef = fieldDef.args.find(argDef => argDef.name === arg.name.value);
                        return {
                            name,
                            value: graphql_2.valueFromValueNode(arg.value),
                            type: argDef && argDef.type || undefined };

                    }) :
                    undefined;
                    let field = {
                        kind: "Field",
                        responseKey,
                        name,
                        alias,
                        args,
                        type: fieldType,
                        description: !graphql_2.isMetaFieldName(name) && description ? description : undefined,
                        isDeprecated,
                        deprecationReason: deprecationReason || undefined };

                    if (graphql_1.isCompositeType(unmodifiedFieldType)) {
                        const selectionSetNode = selectionNode.selectionSet;
                        if (!selectionSetNode) {
                            throw new graphql_1.GraphQLError(`Composite field "${name}" on type "${String(parentType)}" requires selection set`, [selectionNode]);
                        }
                        field.selectionSet = this.compileSelectionSet(selectionNode.selectionSet, unmodifiedFieldType);
                    }
                    return field;
                }
            case graphql_1.Kind.INLINE_FRAGMENT:{
                    const typeNode = selectionNode.typeCondition;
                    const type = typeNode ?
                    graphql_1.typeFromAST(this.schema, typeNode) :
                    parentType;
                    const possibleTypesForTypeCondition = this.possibleTypesForType(type).filter(type => possibleTypes.includes(type));
                    return {
                        kind: "TypeCondition",
                        type,
                        selectionSet: this.compileSelectionSet(selectionNode.selectionSet, type, possibleTypesForTypeCondition) };

                }
            case graphql_1.Kind.FRAGMENT_SPREAD:{
                    const fragmentName = selectionNode.name.value;
                    if (visitedFragments.has(fragmentName))
                    return null;
                    visitedFragments.add(fragmentName);
                    const fragmentSpread = {
                        kind: "FragmentSpread",
                        fragmentName,
                        selectionSet: {
                            possibleTypes,
                            selections: [] } };


                    this.unresolvedFragmentSpreads.push(fragmentSpread);
                    return fragmentSpread;
                }}

    }
    possibleTypesForType(type) {
        if (graphql_1.isAbstractType(type)) {
            return Array.from(this.schema.getPossibleTypes(type)) || [];
        } else
        {
            return [type];
        }
    }}

function wrapInBooleanConditionsIfNeeded(selection, selectionNode, possibleTypes) {
    if (!selection)
    return null;
    if (!selectionNode.directives)
    return selection;
    for (const directive of selectionNode.directives) {
        const directiveName = directive.name.value;
        if (directiveName === "skip" || directiveName === "include") {
            if (!directive.arguments)
            continue;
            const value = directive.arguments[0].value;
            switch (value.kind) {
                case "BooleanValue":
                    if (directiveName === "skip") {
                        return value.value ? null : selection;
                    } else
                    {
                        return value.value ? selection : null;
                    }
                    break;
                case "Variable":
                    selection = {
                        kind: "BooleanCondition",
                        variableName: value.name.value,
                        inverted: directiveName === "skip",
                        selectionSet: {
                            possibleTypes,
                            selections: [selection] } };


                    break;}

        }
    }
    return selection;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNFLGdDQUFZO0FBQ1YsOEJBQU0sa0JBREk7QUFFVixzQ0FBYyxNQUFNLElBQU4sQ0FBVyxLQUZmO0FBR1Ysa0NBQVUsa0JBQWtCLE1BSGxCO0FBSVYsc0NBQWM7QUFDWix5Q0FEWTtBQUVaLHdDQUFZLENBQUMsU0FBRCxDQUZBLEVBSkosRUFBWjs7O0FBU0EsMEJBbEJKOztBQW9CRDtBQUNGO0FBRUQsV0FBTyxTQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBwcmludCxcbiAgdHlwZUZyb21BU1QsXG4gIGdldE5hbWVkVHlwZSxcbiAgaXNBYnN0cmFjdFR5cGUsXG4gIEtpbmQsXG4gIGlzQ29tcG9zaXRlVHlwZSxcbiAgR3JhcGhRTE91dHB1dFR5cGUsXG4gIEdyYXBoUUxJbnB1dFR5cGUsXG4gIEdyYXBoUUxTY2FsYXJUeXBlLFxuICBHcmFwaFFMRW51bVR5cGUsXG4gIEdyYXBoUUxJbnB1dE9iamVjdFR5cGUsXG4gIEdyYXBoUUxPYmplY3RUeXBlLFxuICBHcmFwaFFMRXJyb3IsXG4gIEdyYXBoUUxTY2hlbWEsXG4gIEdyYXBoUUxUeXBlLFxuICBHcmFwaFFMQ29tcG9zaXRlVHlwZSxcbiAgRG9jdW1lbnROb2RlLFxuICBPcGVyYXRpb25EZWZpbml0aW9uTm9kZSxcbiAgRnJhZ21lbnREZWZpbml0aW9uTm9kZSxcbiAgU2VsZWN0aW9uU2V0Tm9kZSxcbiAgU2VsZWN0aW9uTm9kZSxcbiAgaXNTcGVjaWZpZWRTY2FsYXJUeXBlLFxuICBOb25OdWxsVHlwZU5vZGUsXG4gIEdyYXBoUUxOb25OdWxsXG59IGZyb20gXCJncmFwaHFsXCI7XG5cbmltcG9ydCB7XG4gIGdldE9wZXJhdGlvblJvb3RUeXBlLFxuICBnZXRGaWVsZERlZixcbiAgdmFsdWVGcm9tVmFsdWVOb2RlLFxuICBmaWxlUGF0aEZvck5vZGUsXG4gIHdpdGhUeXBlbmFtZUZpZWxkQWRkZWRXaGVyZU5lZWRlZCxcbiAgaXNNZXRhRmllbGROYW1lXG59IGZyb20gXCIuLi91dGlsaXRpZXMvZ3JhcGhxbFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBpbGVyT3B0aW9ucyB7XG4gIGFkZFR5cGVuYW1lPzogYm9vbGVhbjtcbiAgbWVyZ2VJbkZpZWxkc0Zyb21GcmFnbWVudFNwcmVhZHM/OiBib29sZWFuO1xuICBwYXNzdGhyb3VnaEN1c3RvbVNjYWxhcnM/OiBib29sZWFuO1xuICBjdXN0b21TY2FsYXJzUHJlZml4Pzogc3RyaW5nO1xuICBuYW1lc3BhY2U/OiBzdHJpbmc7XG4gIGdlbmVyYXRlT3BlcmF0aW9uSWRzPzogYm9vbGVhbjtcbiAgb3BlcmF0aW9uSWRzUGF0aD86IHN0cmluZztcbiAgYWRkUzNXcmFwcGVyPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21waWxlckNvbnRleHQge1xuICBzY2hlbWE6IEdyYXBoUUxTY2hlbWE7XG4gIHR5cGVzVXNlZDogR3JhcGhRTFR5cGVbXTtcbiAgb3BlcmF0aW9uczogeyBbb3BlcmF0aW9uTmFtZTogc3RyaW5nXTogT3BlcmF0aW9uIH07XG4gIGZyYWdtZW50czogeyBbZnJhZ21lbnROYW1lOiBzdHJpbmddOiBGcmFnbWVudCB9O1xuICBvcHRpb25zOiBDb21waWxlck9wdGlvbnM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3BlcmF0aW9uIHtcbiAgb3BlcmF0aW9uSWQ/OiBzdHJpbmc7XG4gIG9wZXJhdGlvbk5hbWU6IHN0cmluZztcbiAgb3BlcmF0aW9uVHlwZTogc3RyaW5nO1xuICB2YXJpYWJsZXM6IHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgdHlwZTogR3JhcGhRTFR5cGU7XG4gIH1bXTtcbiAgZmlsZVBhdGg6IHN0cmluZztcbiAgc291cmNlOiBzdHJpbmc7XG4gIHJvb3RUeXBlOiBHcmFwaFFMT2JqZWN0VHlwZTtcbiAgc2VsZWN0aW9uU2V0OiBTZWxlY3Rpb25TZXQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnJhZ21lbnQge1xuICBmaWxlUGF0aDogc3RyaW5nO1xuICBmcmFnbWVudE5hbWU6IHN0cmluZztcbiAgc291cmNlOiBzdHJpbmc7XG4gIHR5cGU6IEdyYXBoUUxDb21wb3NpdGVUeXBlO1xuICBzZWxlY3Rpb25TZXQ6IFNlbGVjdGlvblNldDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZWxlY3Rpb25TZXQge1xuICBwb3NzaWJsZVR5cGVzOiBHcmFwaFFMT2JqZWN0VHlwZVtdO1xuICBzZWxlY3Rpb25zOiBTZWxlY3Rpb25bXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBcmd1bWVudCB7XG4gIG5hbWU6IHN0cmluZztcbiAgdmFsdWU6IGFueTtcbiAgdHlwZT86IEdyYXBoUUxJbnB1dFR5cGU7XG59XG5cbmV4cG9ydCB0eXBlIFNlbGVjdGlvbiA9XG4gIHwgRmllbGRcbiAgfCBUeXBlQ29uZGl0aW9uXG4gIHwgQm9vbGVhbkNvbmRpdGlvblxuICB8IEZyYWdtZW50U3ByZWFkO1xuXG5leHBvcnQgaW50ZXJmYWNlIEZpZWxkIHtcbiAga2luZDogXCJGaWVsZFwiO1xuICByZXNwb25zZUtleTogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGFsaWFzPzogc3RyaW5nO1xuICBhcmdzPzogQXJndW1lbnRbXTtcbiAgdHlwZTogR3JhcGhRTE91dHB1dFR5cGU7XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICBpc0RlcHJlY2F0ZWQ/OiBib29sZWFuO1xuICBkZXByZWNhdGlvblJlYXNvbj86IHN0cmluZztcbiAgaXNDb25kaXRpb25hbD86IGJvb2xlYW47XG4gIHNlbGVjdGlvblNldD86IFNlbGVjdGlvblNldDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUeXBlQ29uZGl0aW9uIHtcbiAga2luZDogXCJUeXBlQ29uZGl0aW9uXCI7XG4gIHR5cGU6IEdyYXBoUUxDb21wb3NpdGVUeXBlO1xuICBzZWxlY3Rpb25TZXQ6IFNlbGVjdGlvblNldDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCb29sZWFuQ29uZGl0aW9uIHtcbiAga2luZDogXCJCb29sZWFuQ29uZGl0aW9uXCI7XG4gIHZhcmlhYmxlTmFtZTogc3RyaW5nO1xuICBpbnZlcnRlZDogYm9vbGVhbjtcbiAgc2VsZWN0aW9uU2V0OiBTZWxlY3Rpb25TZXQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnJhZ21lbnRTcHJlYWQge1xuICBraW5kOiBcIkZyYWdtZW50U3ByZWFkXCI7XG4gIGZyYWdtZW50TmFtZTogc3RyaW5nO1xuICBpc0NvbmRpdGlvbmFsPzogYm9vbGVhbjtcbiAgc2VsZWN0aW9uU2V0OiBTZWxlY3Rpb25TZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21waWxlVG9JUihcbiAgc2NoZW1hOiBHcmFwaFFMU2NoZW1hLFxuICBkb2N1bWVudDogRG9jdW1lbnROb2RlLFxuICBvcHRpb25zOiBDb21waWxlck9wdGlvbnMgPSB7fVxuKTogQ29tcGlsZXJDb250ZXh0IHtcbiAgaWYgKG9wdGlvbnMuYWRkVHlwZW5hbWUpIHtcbiAgICBkb2N1bWVudCA9IHdpdGhUeXBlbmFtZUZpZWxkQWRkZWRXaGVyZU5lZWRlZChkb2N1bWVudCk7XG4gIH1cblxuICBjb25zdCBjb21waWxlciA9IG5ldyBDb21waWxlcihzY2hlbWEsIG9wdGlvbnMpO1xuXG4gIGNvbnN0IG9wZXJhdGlvbnM6IHsgW29wZXJhdGlvbk5hbWU6IHN0cmluZ106IE9wZXJhdGlvbiB9ID0gT2JqZWN0LmNyZWF0ZShcbiAgICBudWxsXG4gICk7XG4gIGNvbnN0IGZyYWdtZW50czogeyBbZnJhZ21lbnROYW1lOiBzdHJpbmddOiBGcmFnbWVudCB9ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmb3IgKGNvbnN0IGRlZmluaXRpb24gb2YgZG9jdW1lbnQuZGVmaW5pdGlvbnMpIHtcbiAgICBzd2l0Y2ggKGRlZmluaXRpb24ua2luZCkge1xuICAgICAgY2FzZSBLaW5kLk9QRVJBVElPTl9ERUZJTklUSU9OOlxuICAgICAgICBjb25zdCBvcGVyYXRpb24gPSBjb21waWxlci5jb21waWxlT3BlcmF0aW9uKGRlZmluaXRpb24pO1xuICAgICAgICBvcGVyYXRpb25zW29wZXJhdGlvbi5vcGVyYXRpb25OYW1lXSA9IG9wZXJhdGlvbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtpbmQuRlJBR01FTlRfREVGSU5JVElPTjpcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb21waWxlci5jb21waWxlRnJhZ21lbnQoZGVmaW5pdGlvbik7XG4gICAgICAgIGZyYWdtZW50c1tmcmFnbWVudC5mcmFnbWVudE5hbWVdID0gZnJhZ21lbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3QgZnJhZ21lbnRTcHJlYWQgb2YgY29tcGlsZXIudW5yZXNvbHZlZEZyYWdtZW50U3ByZWFkcykge1xuICAgIGNvbnN0IGZyYWdtZW50ID0gZnJhZ21lbnRzW2ZyYWdtZW50U3ByZWFkLmZyYWdtZW50TmFtZV07XG4gICAgaWYgKCFmcmFnbWVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBmcmFnbWVudCBcIiR7ZnJhZ21lbnRTcHJlYWQuZnJhZ21lbnROYW1lfVwiYCk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdGhlIHBvc3NpYmxldyB0eXBlcyBvZiB0aGUgZnJhZ21lbnQgc3ByZWFkIGFuZCB0aGUgZnJhZ21lbnQuXG4gICAgY29uc3QgcG9zc2libGVUeXBlcyA9IGZyYWdtZW50LnNlbGVjdGlvblNldC5wb3NzaWJsZVR5cGVzLmZpbHRlcih0eXBlID0+XG4gICAgICBmcmFnbWVudFNwcmVhZC5zZWxlY3Rpb25TZXQucG9zc2libGVUeXBlcy5pbmNsdWRlcyh0eXBlKVxuICAgICk7XG5cbiAgICBmcmFnbWVudFNwcmVhZC5pc0NvbmRpdGlvbmFsID0gZnJhZ21lbnQuc2VsZWN0aW9uU2V0LnBvc3NpYmxlVHlwZXMuc29tZShcbiAgICAgIHR5cGUgPT4gIWZyYWdtZW50U3ByZWFkLnNlbGVjdGlvblNldC5wb3NzaWJsZVR5cGVzLmluY2x1ZGVzKHR5cGUpXG4gICAgKTtcblxuICAgIGZyYWdtZW50U3ByZWFkLnNlbGVjdGlvblNldCA9IHtcbiAgICAgIHBvc3NpYmxlVHlwZXMsXG4gICAgICBzZWxlY3Rpb25zOiBmcmFnbWVudC5zZWxlY3Rpb25TZXQuc2VsZWN0aW9uc1xuICAgIH07XG4gIH1cblxuICBjb25zdCB0eXBlc1VzZWQgPSBjb21waWxlci50eXBlc1VzZWQ7XG5cbiAgcmV0dXJuIHsgc2NoZW1hLCB0eXBlc1VzZWQsIG9wZXJhdGlvbnMsIGZyYWdtZW50cywgb3B0aW9ucyB9O1xufVxuXG5jbGFzcyBDb21waWxlciB7XG4gIG9wdGlvbnM6IENvbXBpbGVyT3B0aW9ucztcbiAgc2NoZW1hOiBHcmFwaFFMU2NoZW1hO1xuICB0eXBlc1VzZWRTZXQ6IFNldDxHcmFwaFFMVHlwZT47XG5cbiAgdW5yZXNvbHZlZEZyYWdtZW50U3ByZWFkczogRnJhZ21lbnRTcHJlYWRbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKHNjaGVtYTogR3JhcGhRTFNjaGVtYSwgb3B0aW9uczogQ29tcGlsZXJPcHRpb25zKSB7XG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIHRoaXMudHlwZXNVc2VkU2V0ID0gbmV3IFNldCgpO1xuICB9XG5cbiAgYWRkVHlwZVVzZWQodHlwZTogR3JhcGhRTFR5cGUpIHtcbiAgICBpZiAodGhpcy50eXBlc1VzZWRTZXQuaGFzKHR5cGUpKSByZXR1cm47XG5cbiAgICBpZiAoXG4gICAgICB0eXBlIGluc3RhbmNlb2YgR3JhcGhRTEVudW1UeXBlIHx8XG4gICAgICB0eXBlIGluc3RhbmNlb2YgR3JhcGhRTElucHV0T2JqZWN0VHlwZSB8fFxuICAgICAgKHR5cGUgaW5zdGFuY2VvZiBHcmFwaFFMU2NhbGFyVHlwZSAmJiAhaXNTcGVjaWZpZWRTY2FsYXJUeXBlKHR5cGUpKVxuICAgICkge1xuICAgICAgdGhpcy50eXBlc1VzZWRTZXQuYWRkKHR5cGUpO1xuICAgIH1cbiAgICBpZiAodHlwZSBpbnN0YW5jZW9mIEdyYXBoUUxJbnB1dE9iamVjdFR5cGUpIHtcbiAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgT2JqZWN0LnZhbHVlcyh0eXBlLmdldEZpZWxkcygpKSkge1xuICAgICAgICB0aGlzLmFkZFR5cGVVc2VkKGdldE5hbWVkVHlwZShmaWVsZC50eXBlKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0IHR5cGVzVXNlZCgpOiBHcmFwaFFMVHlwZVtdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnR5cGVzVXNlZFNldCk7XG4gIH1cblxuICBjb21waWxlT3BlcmF0aW9uKG9wZXJhdGlvbkRlZmluaXRpb246IE9wZXJhdGlvbkRlZmluaXRpb25Ob2RlKTogT3BlcmF0aW9uIHtcbiAgICBpZiAoIW9wZXJhdGlvbkRlZmluaXRpb24ubmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3BlcmF0aW9ucyBzaG91bGQgYmUgbmFtZWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgZmlsZVBhdGggPSBmaWxlUGF0aEZvck5vZGUob3BlcmF0aW9uRGVmaW5pdGlvbik7XG4gICAgY29uc3Qgb3BlcmF0aW9uTmFtZSA9IG9wZXJhdGlvbkRlZmluaXRpb24ubmFtZS52YWx1ZTtcbiAgICBjb25zdCBvcGVyYXRpb25UeXBlID0gb3BlcmF0aW9uRGVmaW5pdGlvbi5vcGVyYXRpb247XG5cbiAgICBjb25zdCB2YXJpYWJsZXMgPSAob3BlcmF0aW9uRGVmaW5pdGlvbi52YXJpYWJsZURlZmluaXRpb25zIHx8IFtdKS5tYXAoXG4gICAgICBub2RlID0+IHtcbiAgICAgICAgY29uc3QgbmFtZSA9IG5vZGUudmFyaWFibGUubmFtZS52YWx1ZTtcbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVGcm9tQVNUKHRoaXMuc2NoZW1hLCBub2RlLnR5cGUgYXMgTm9uTnVsbFR5cGVOb2RlKTtcbiAgICAgICAgdGhpcy5hZGRUeXBlVXNlZChnZXROYW1lZFR5cGUodHlwZSBhcyBHcmFwaFFMVHlwZSkpO1xuICAgICAgICByZXR1cm4geyBuYW1lLCB0eXBlOiB0eXBlIGFzIEdyYXBoUUxOb25OdWxsPGFueT4gfTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgY29uc3Qgc291cmNlID0gcHJpbnQob3BlcmF0aW9uRGVmaW5pdGlvbik7XG4gICAgY29uc3Qgcm9vdFR5cGUgPSBnZXRPcGVyYXRpb25Sb290VHlwZShcbiAgICAgIHRoaXMuc2NoZW1hLFxuICAgICAgb3BlcmF0aW9uRGVmaW5pdGlvblxuICAgICkgYXMgR3JhcGhRTE9iamVjdFR5cGU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZmlsZVBhdGgsXG4gICAgICBvcGVyYXRpb25OYW1lLFxuICAgICAgb3BlcmF0aW9uVHlwZSxcbiAgICAgIHZhcmlhYmxlcyxcbiAgICAgIHNvdXJjZSxcbiAgICAgIHJvb3RUeXBlLFxuICAgICAgc2VsZWN0aW9uU2V0OiB0aGlzLmNvbXBpbGVTZWxlY3Rpb25TZXQoXG4gICAgICAgIG9wZXJhdGlvbkRlZmluaXRpb24uc2VsZWN0aW9uU2V0LFxuICAgICAgICByb290VHlwZVxuICAgICAgKVxuICAgIH07XG4gIH1cblxuICBjb21waWxlRnJhZ21lbnQoZnJhZ21lbnREZWZpbml0aW9uOiBGcmFnbWVudERlZmluaXRpb25Ob2RlKTogRnJhZ21lbnQge1xuICAgIGNvbnN0IGZyYWdtZW50TmFtZSA9IGZyYWdtZW50RGVmaW5pdGlvbi5uYW1lLnZhbHVlO1xuXG4gICAgY29uc3QgZmlsZVBhdGggPSBmaWxlUGF0aEZvck5vZGUoZnJhZ21lbnREZWZpbml0aW9uKTtcbiAgICBjb25zdCBzb3VyY2UgPSBwcmludChmcmFnbWVudERlZmluaXRpb24pO1xuXG4gICAgY29uc3QgdHlwZSA9IHR5cGVGcm9tQVNUKFxuICAgICAgdGhpcy5zY2hlbWEsXG4gICAgICBmcmFnbWVudERlZmluaXRpb24udHlwZUNvbmRpdGlvblxuICAgICkgYXMgR3JhcGhRTENvbXBvc2l0ZVR5cGU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZnJhZ21lbnROYW1lLFxuICAgICAgZmlsZVBhdGgsXG4gICAgICBzb3VyY2UsXG4gICAgICB0eXBlLFxuICAgICAgc2VsZWN0aW9uU2V0OiB0aGlzLmNvbXBpbGVTZWxlY3Rpb25TZXQoXG4gICAgICAgIGZyYWdtZW50RGVmaW5pdGlvbi5zZWxlY3Rpb25TZXQsXG4gICAgICAgIHR5cGVcbiAgICAgIClcbiAgICB9O1xuICB9XG5cbiAgY29tcGlsZVNlbGVjdGlvblNldChcbiAgICBzZWxlY3Rpb25TZXROb2RlOiBTZWxlY3Rpb25TZXROb2RlLFxuICAgIHBhcmVudFR5cGU6IEdyYXBoUUxDb21wb3NpdGVUeXBlLFxuICAgIHBvc3NpYmxlVHlwZXM6IEdyYXBoUUxPYmplY3RUeXBlW10gPSB0aGlzLnBvc3NpYmxlVHlwZXNGb3JUeXBlKHBhcmVudFR5cGUpLFxuICAgIHZpc2l0ZWRGcmFnbWVudHM6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpXG4gICk6IFNlbGVjdGlvblNldCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc3NpYmxlVHlwZXMsXG4gICAgICBzZWxlY3Rpb25zOiBzZWxlY3Rpb25TZXROb2RlLnNlbGVjdGlvbnNcbiAgICAgICAgLm1hcChzZWxlY3Rpb25Ob2RlID0+XG4gICAgICAgICAgd3JhcEluQm9vbGVhbkNvbmRpdGlvbnNJZk5lZWRlZChcbiAgICAgICAgICAgIHRoaXMuY29tcGlsZVNlbGVjdGlvbihcbiAgICAgICAgICAgICAgc2VsZWN0aW9uTm9kZSxcbiAgICAgICAgICAgICAgcGFyZW50VHlwZSxcbiAgICAgICAgICAgICAgcG9zc2libGVUeXBlcyxcbiAgICAgICAgICAgICAgdmlzaXRlZEZyYWdtZW50c1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHNlbGVjdGlvbk5vZGUsXG4gICAgICAgICAgICBwb3NzaWJsZVR5cGVzXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICAgIC5maWx0ZXIoeCA9PiB4KSBhcyBTZWxlY3Rpb25bXVxuICAgIH07XG4gIH1cblxuICBjb21waWxlU2VsZWN0aW9uKFxuICAgIHNlbGVjdGlvbk5vZGU6IFNlbGVjdGlvbk5vZGUsXG4gICAgcGFyZW50VHlwZTogR3JhcGhRTENvbXBvc2l0ZVR5cGUsXG4gICAgcG9zc2libGVUeXBlczogR3JhcGhRTE9iamVjdFR5cGVbXSxcbiAgICB2aXNpdGVkRnJhZ21lbnRzOiBTZXQ8c3RyaW5nPlxuICApOiBTZWxlY3Rpb24gfCBudWxsIHtcbiAgICBzd2l0Y2ggKHNlbGVjdGlvbk5vZGUua2luZCkge1xuICAgICAgY2FzZSBLaW5kLkZJRUxEOiB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBzZWxlY3Rpb25Ob2RlLm5hbWUudmFsdWU7XG4gICAgICAgIGNvbnN0IGFsaWFzID0gc2VsZWN0aW9uTm9kZS5hbGlhc1xuICAgICAgICAgID8gc2VsZWN0aW9uTm9kZS5hbGlhcy52YWx1ZVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGNvbnN0IGZpZWxkRGVmID0gZ2V0RmllbGREZWYodGhpcy5zY2hlbWEsIHBhcmVudFR5cGUsIHNlbGVjdGlvbk5vZGUpO1xuICAgICAgICBpZiAoIWZpZWxkRGVmKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEdyYXBoUUxFcnJvcihcbiAgICAgICAgICAgIGBDYW5ub3QgcXVlcnkgZmllbGQgXCIke25hbWV9XCIgb24gdHlwZSBcIiR7U3RyaW5nKHBhcmVudFR5cGUpfVwiYCxcbiAgICAgICAgICAgIFtzZWxlY3Rpb25Ob2RlXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmaWVsZFR5cGUgPSBmaWVsZERlZi50eXBlO1xuICAgICAgICBjb25zdCB1bm1vZGlmaWVkRmllbGRUeXBlID0gZ2V0TmFtZWRUeXBlKGZpZWxkVHlwZSk7XG5cbiAgICAgICAgdGhpcy5hZGRUeXBlVXNlZCh1bm1vZGlmaWVkRmllbGRUeXBlKTtcblxuICAgICAgICBjb25zdCB7IGRlc2NyaXB0aW9uLCBpc0RlcHJlY2F0ZWQsIGRlcHJlY2F0aW9uUmVhc29uIH0gPSBmaWVsZERlZjtcblxuICAgICAgICBjb25zdCByZXNwb25zZUtleSA9IGFsaWFzIHx8IG5hbWU7XG5cbiAgICAgICAgY29uc3QgYXJncyA9XG4gICAgICAgICAgc2VsZWN0aW9uTm9kZS5hcmd1bWVudHMgJiYgc2VsZWN0aW9uTm9kZS5hcmd1bWVudHMubGVuZ3RoID4gMFxuICAgICAgICAgICAgPyBzZWxlY3Rpb25Ob2RlLmFyZ3VtZW50cy5tYXAoYXJnID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYXJnLm5hbWUudmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJnRGVmID0gZmllbGREZWYuYXJncy5maW5kKFxuICAgICAgICAgICAgICAgICAgYXJnRGVmID0+IGFyZ0RlZi5uYW1lID09PSBhcmcubmFtZS52YWx1ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVGcm9tVmFsdWVOb2RlKGFyZy52YWx1ZSksXG4gICAgICAgICAgICAgICAgICB0eXBlOiAoYXJnRGVmICYmIGFyZ0RlZi50eXBlKSB8fCB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgbGV0IGZpZWxkOiBGaWVsZCA9IHtcbiAgICAgICAgICBraW5kOiBcIkZpZWxkXCIsXG4gICAgICAgICAgcmVzcG9uc2VLZXksXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBhbGlhcyxcbiAgICAgICAgICBhcmdzLFxuICAgICAgICAgIHR5cGU6IGZpZWxkVHlwZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAgICFpc01ldGFGaWVsZE5hbWUobmFtZSkgJiYgZGVzY3JpcHRpb24gPyBkZXNjcmlwdGlvbiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBpc0RlcHJlY2F0ZWQsXG4gICAgICAgICAgZGVwcmVjYXRpb25SZWFzb246IGRlcHJlY2F0aW9uUmVhc29uIHx8IHVuZGVmaW5lZFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpc0NvbXBvc2l0ZVR5cGUodW5tb2RpZmllZEZpZWxkVHlwZSkpIHtcbiAgICAgICAgICBjb25zdCBzZWxlY3Rpb25TZXROb2RlID0gc2VsZWN0aW9uTm9kZS5zZWxlY3Rpb25TZXQ7XG4gICAgICAgICAgaWYgKCFzZWxlY3Rpb25TZXROb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKFxuICAgICAgICAgICAgICBgQ29tcG9zaXRlIGZpZWxkIFwiJHtuYW1lfVwiIG9uIHR5cGUgXCIke1N0cmluZyhcbiAgICAgICAgICAgICAgICBwYXJlbnRUeXBlXG4gICAgICAgICAgICAgICl9XCIgcmVxdWlyZXMgc2VsZWN0aW9uIHNldGAsXG4gICAgICAgICAgICAgIFtzZWxlY3Rpb25Ob2RlXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaWVsZC5zZWxlY3Rpb25TZXQgPSB0aGlzLmNvbXBpbGVTZWxlY3Rpb25TZXQoXG4gICAgICAgICAgICBzZWxlY3Rpb25Ob2RlLnNlbGVjdGlvblNldCBhcyBTZWxlY3Rpb25TZXROb2RlLFxuICAgICAgICAgICAgdW5tb2RpZmllZEZpZWxkVHlwZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkO1xuICAgICAgfVxuICAgICAgY2FzZSBLaW5kLklOTElORV9GUkFHTUVOVDoge1xuICAgICAgICBjb25zdCB0eXBlTm9kZSA9IHNlbGVjdGlvbk5vZGUudHlwZUNvbmRpdGlvbjtcbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVOb2RlXG4gICAgICAgICAgPyAodHlwZUZyb21BU1QodGhpcy5zY2hlbWEsIHR5cGVOb2RlKSBhcyBHcmFwaFFMQ29tcG9zaXRlVHlwZSlcbiAgICAgICAgICA6IHBhcmVudFR5cGU7XG4gICAgICAgIGNvbnN0IHBvc3NpYmxlVHlwZXNGb3JUeXBlQ29uZGl0aW9uID0gdGhpcy5wb3NzaWJsZVR5cGVzRm9yVHlwZShcbiAgICAgICAgICB0eXBlXG4gICAgICAgICkuZmlsdGVyKHR5cGUgPT4gcG9zc2libGVUeXBlcy5pbmNsdWRlcyh0eXBlKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAga2luZDogXCJUeXBlQ29uZGl0aW9uXCIsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBzZWxlY3Rpb25TZXQ6IHRoaXMuY29tcGlsZVNlbGVjdGlvblNldChcbiAgICAgICAgICAgIHNlbGVjdGlvbk5vZGUuc2VsZWN0aW9uU2V0LFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHBvc3NpYmxlVHlwZXNGb3JUeXBlQ29uZGl0aW9uXG4gICAgICAgICAgKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY2FzZSBLaW5kLkZSQUdNRU5UX1NQUkVBRDoge1xuICAgICAgICBjb25zdCBmcmFnbWVudE5hbWUgPSBzZWxlY3Rpb25Ob2RlLm5hbWUudmFsdWU7XG4gICAgICAgIGlmICh2aXNpdGVkRnJhZ21lbnRzLmhhcyhmcmFnbWVudE5hbWUpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmlzaXRlZEZyYWdtZW50cy5hZGQoZnJhZ21lbnROYW1lKTtcblxuICAgICAgICBjb25zdCBmcmFnbWVudFNwcmVhZDogRnJhZ21lbnRTcHJlYWQgPSB7XG4gICAgICAgICAga2luZDogXCJGcmFnbWVudFNwcmVhZFwiLFxuICAgICAgICAgIGZyYWdtZW50TmFtZSxcbiAgICAgICAgICBzZWxlY3Rpb25TZXQ6IHtcbiAgICAgICAgICAgIHBvc3NpYmxlVHlwZXMsXG4gICAgICAgICAgICBzZWxlY3Rpb25zOiBbXVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51bnJlc29sdmVkRnJhZ21lbnRTcHJlYWRzLnB1c2goZnJhZ21lbnRTcHJlYWQpO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnRTcHJlYWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcG9zc2libGVUeXBlc0ZvclR5cGUodHlwZTogR3JhcGhRTENvbXBvc2l0ZVR5cGUpOiBHcmFwaFFMT2JqZWN0VHlwZVtdIHtcbiAgICBpZiAoaXNBYnN0cmFjdFR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuc2NoZW1hLmdldFBvc3NpYmxlVHlwZXModHlwZSkpIHx8IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW3R5cGVdO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3cmFwSW5Cb29sZWFuQ29uZGl0aW9uc0lmTmVlZGVkKFxuICBzZWxlY3Rpb246IFNlbGVjdGlvbiB8IG51bGwsXG4gIHNlbGVjdGlvbk5vZGU6IFNlbGVjdGlvbk5vZGUsXG4gIHBvc3NpYmxlVHlwZXM6IEdyYXBoUUxPYmplY3RUeXBlW11cbik6IFNlbGVjdGlvbiB8IG51bGwge1xuICBpZiAoIXNlbGVjdGlvbikgcmV0dXJuIG51bGw7XG5cbiAgaWYgKCFzZWxlY3Rpb25Ob2RlLmRpcmVjdGl2ZXMpIHJldHVybiBzZWxlY3Rpb247XG5cbiAgZm9yIChjb25zdCBkaXJlY3RpdmUgb2Ygc2VsZWN0aW9uTm9kZS5kaXJlY3RpdmVzKSB7XG4gICAgY29uc3QgZGlyZWN0aXZlTmFtZSA9IGRpcmVjdGl2ZS5uYW1lLnZhbHVlO1xuXG4gICAgaWYgKGRpcmVjdGl2ZU5hbWUgPT09IFwic2tpcFwiIHx8IGRpcmVjdGl2ZU5hbWUgPT09IFwiaW5jbHVkZVwiKSB7XG4gICAgICBpZiAoIWRpcmVjdGl2ZS5hcmd1bWVudHMpIGNvbnRpbnVlO1xuXG4gICAgICBjb25zdCB2YWx1ZSA9IGRpcmVjdGl2ZS5hcmd1bWVudHNbMF0udmFsdWU7XG5cbiAgICAgIHN3aXRjaCAodmFsdWUua2luZCkge1xuICAgICAgICBjYXNlIFwiQm9vbGVhblZhbHVlXCI6XG4gICAgICAgICAgaWYgKGRpcmVjdGl2ZU5hbWUgPT09IFwic2tpcFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudmFsdWUgPyBudWxsIDogc2VsZWN0aW9uO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudmFsdWUgPyBzZWxlY3Rpb24gOiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlZhcmlhYmxlXCI6XG4gICAgICAgICAgc2VsZWN0aW9uID0ge1xuICAgICAgICAgICAga2luZDogXCJCb29sZWFuQ29uZGl0aW9uXCIsXG4gICAgICAgICAgICB2YXJpYWJsZU5hbWU6IHZhbHVlLm5hbWUudmFsdWUsXG4gICAgICAgICAgICBpbnZlcnRlZDogZGlyZWN0aXZlTmFtZSA9PT0gXCJza2lwXCIsXG4gICAgICAgICAgICBzZWxlY3Rpb25TZXQ6IHtcbiAgICAgICAgICAgICAgcG9zc2libGVUeXBlcyxcbiAgICAgICAgICAgICAgc2VsZWN0aW9uczogW3NlbGVjdGlvbl1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxlY3Rpb247XG59Il0sInNvdXJjZVJvb3QiOiIifQ==