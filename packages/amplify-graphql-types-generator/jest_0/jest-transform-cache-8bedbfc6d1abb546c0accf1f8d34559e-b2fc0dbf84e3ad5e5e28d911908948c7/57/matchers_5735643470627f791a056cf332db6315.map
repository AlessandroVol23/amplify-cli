{"version":3,"sources":["matchers.ts"],"names":[],"mappings":";;AAAA,MAAA,0BAAA,QAAA,mDAAA,CAAA;AAgBA,SAAA,mBAAA,CAEE,QAFF,EAGE,iBAHF,EAIE,oBAJF,EAIgC;AAE9B,UAAM,qBAAqB,wBAAA,qBAAA,CAAsB,QAAtB,EAAgC,GAAhC,CAAoC,SAAS,MAAM,WAAnD,CAA3B;AAEA,UAAM,OAAO,KAAK,MAAL,CAAY,kBAAZ,EAAgC,oBAAhC,CAAb;AAEA,QAAI,IAAJ,EAAU;AACR,eAAO;AACL,qBAAS,MACP,8BAA8B,KAAK,KAAL,CAAW,aAAX,CAAyB,iBAAzB,CAA2C,IAAzE;AACA,6BADA;AAEA,kBAAM,KAAK,KAAL,CAAW,aAAX,CAAyB,oBAAzB,CAA8C,EAFpD;AAGA,yBAHA;AAIA,iBAAK,KAAK,KAAL,CAAW,aAAX,CAAyB,kBAAzB,CAA4C,EAN9C;AAOL,kBAAM,IAPD,EAAP;;AASD,KAVD;AAUO;AACL,eAAO;AACL,qBAAS,MACP,8BAA8B,KAAK,KAAL,CAAW,aAAX,CAAyB,iBAAzB,CAA2C,IAAzE;AACA,yBADA;AAEA,kBAAM,KAAK,KAAL,CAAW,aAAX,CAAyB,oBAAzB,CAA8C,IAFpD;AAGA,yBAHA;AAIA,kBAAM,KAAK,KAAL,CAAW,aAAX,CAAyB,kBAAzB,CAA4C,EAN/C;AAOL,kBAAM,KAPD,EAAP;;AASD;AACF;AAED,SAAA,6BAAA,CAEE,QAFF,EAGE,iBAHF,EAIE,oBAJF,EAIgC;AAE9B,UAAM,UAAU,SAAS,IAAT,CAAc,WAAU;AACtC,eAAO,KAAK,MAAL,CAAY,MAAM,IAAN,CAAW,QAAQ,aAAnB,EAAkC,GAAlC,CAAsC,QAAQ,KAAK,IAAnD,CAAZ,EAAsE,iBAAtE,CAAP;AACD,KAFe,CAAhB;AAIA,QAAI,CAAC,OAAL,EAAc;AACZ,eAAO;AACL,qBAAS,MACP,0CAAA;AACA,iBAAK,KAAK,KAAL,CAAW,aAAX,CAAyB,iBAAzB,CAA2C,IADhD;AAEA,4CAFA;AAGA;AACG,eADH,CAEI,WACE,KAAK,KAAK,KAAL,CAAW,aAAX,CAAyB,QAAQ,aAAjC,CAA+C,OAAO,KAAK,KAAL,CAAW,aAAX,CACzD,wBAAA,qBAAA,CAAsB,OAAtB,EAA+B,GAA/B,CAAmC,SAAS,MAAM,IAAlD,CADyD,CAE1D,EALP;AAOG,gBAPH,CAOQ,IAPR,CALG;AAaL,kBAAM,KAbD,EAAP;;AAeD;AAED,WAAO,oBAAoB,IAApB,CAAyB,IAAzB,EAA+B,OAA/B,EAAwC,iBAAxC,EAA2D,oBAA3D,CAAP;AACD;AAED,OAAO,MAAP,CAAc;AACZ,uBADY;AAEZ,iCAFY,EAAd","sourcesContent":["import { collectAndMergeFields } from '../../src/compiler/visitors/collectAndMergeFields';\n\nimport { SelectionSet } from '../../src/compiler';\n\ndeclare global {\n  namespace jest {\n    interface Matchers<R> {\n      toMatchSelectionSet(possibleTypeNames: string[], expectedResponseKeys: string[]): R;\n      toContainSelectionSetMatching(possibleTypeNames: string[], expectedResponseKeys: string[]): R;\n    }\n    interface MatcherUtils {\n      equals(a: any, b: any): boolean;\n    }\n  }\n}\n\nfunction toMatchSelectionSet(\n  this: jest.MatcherUtils,\n  received: SelectionSet,\n  possibleTypeNames: string[],\n  expectedResponseKeys: string[]\n): { message(): string; pass: boolean } {\n  const actualResponseKeys = collectAndMergeFields(received).map(field => field.responseKey);\n\n  const pass = this.equals(actualResponseKeys, expectedResponseKeys);\n\n  if (pass) {\n    return {\n      message: () =>\n        `Expected selection set for ${this.utils.printExpected(possibleTypeNames)}\\n` +\n        `To not match:\\n` +\n        `   ${this.utils.printExpected(expectedResponseKeys)}` +\n        'Received:\\n' +\n        `  ${this.utils.printReceived(actualResponseKeys)}`,\n      pass: true\n    };\n  } else {\n    return {\n      message: () =>\n        `Expected selection set for ${this.utils.printExpected(possibleTypeNames)}\\n` +\n        `To match:\\n` +\n        `   ${this.utils.printExpected(expectedResponseKeys)}\\n` +\n        'Received:\\n' +\n        `   ${this.utils.printReceived(actualResponseKeys)}`,\n      pass: false\n    };\n  }\n}\n\nfunction toContainSelectionSetMatching(\n  this: jest.MatcherUtils,\n  received: SelectionSet[],\n  possibleTypeNames: string[],\n  expectedResponseKeys: string[]\n): { message(): string; pass: boolean } {\n  const variant = received.find(variant => {\n    return this.equals(Array.from(variant.possibleTypes).map(type => type.name), possibleTypeNames);\n  });\n\n  if (!variant) {\n    return {\n      message: () =>\n        `Expected array to contain variant for:\\n` +\n        `  ${this.utils.printExpected(possibleTypeNames)}\\n` +\n        `But only found variants for:\\n` +\n        received\n          .map(\n            variant =>\n              `  ${this.utils.printReceived(variant.possibleTypes)} -> ${this.utils.printReceived(\n                collectAndMergeFields(variant).map(field => field.name)\n              )}`\n          )\n          .join('\\n'),\n      pass: false\n    };\n  }\n\n  return toMatchSelectionSet.call(this, variant, possibleTypeNames, expectedResponseKeys);\n}\n\nexpect.extend({\n  toMatchSelectionSet,\n  toContainSelectionSetMatching\n} as any);\n"],"sourceRoot":""}