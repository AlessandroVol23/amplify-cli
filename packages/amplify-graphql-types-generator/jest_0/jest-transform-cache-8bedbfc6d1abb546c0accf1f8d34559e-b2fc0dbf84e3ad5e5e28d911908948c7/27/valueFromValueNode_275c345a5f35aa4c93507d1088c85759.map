{"version":3,"sources":["valueFromValueNode.ts"],"names":[],"mappings":";;AAAA,MAAA,YAAA,QAAA,SAAA,CAAA;AAEA,MAAA,YAAA,QAAA,0BAAA,CAAA;AAEA,SAAS,qBAAT,EAAgC,MAAK;AACnC,SAAK,wCAAL,EAA+C,MAAK;AAClD,cAAM,YAAY,UAAA,UAAA,CAAW,GAAX,CAAlB;AACA,cAAM,QAAQ,UAAA,kBAAA,CAAmB,SAAnB,CAAd;AAEA,eAAO,KAAP,EAAc,IAAd,CAAmB,CAAnB;AACD,KALD;AAOA,SAAK,yCAAL,EAAgD,MAAK;AACnD,cAAM,YAAY,UAAA,UAAA,CAAW,KAAX,CAAlB;AACA,cAAM,QAAQ,UAAA,kBAAA,CAAmB,SAAnB,CAAd;AAEA,eAAO,KAAP,EAAc,IAAd,CAAmB,GAAnB;AACD,KALD;AAOA,SAAK,4CAAL,EAAmD,MAAK;AACtD,cAAM,YAAY,UAAA,UAAA,CAAW,MAAX,CAAlB;AACA,cAAM,QAAQ,UAAA,kBAAA,CAAmB,SAAnB,CAAd;AAEA,eAAO,KAAP,EAAc,IAAd,CAAmB,IAAnB;AACD,KALD;AAOA,SAAK,oCAAL,EAA2C,MAAK;AAC9C,cAAM,YAAY,UAAA,UAAA,CAAW,MAAX,CAAlB;AACA,cAAM,QAAQ,UAAA,kBAAA,CAAmB,SAAnB,CAAd;AAEA,eAAO,KAAP,EAAc,IAAd,CAAmB,IAAnB;AACD,KALD;AAOA,SAAK,0CAAL,EAAiD,MAAK;AACpD,cAAM,YAAY,UAAA,UAAA,CAAW,OAAX,CAAlB;AACA,cAAM,QAAQ,UAAA,kBAAA,CAAmB,SAAnB,CAAd;AAEA,eAAO,KAAP,EAAc,IAAd,CAAmB,KAAnB;AACD,KALD;AAOA,SAAK,yCAAL,EAAgD,MAAK;AACnD,cAAM,YAAY,UAAA,UAAA,CAAW,MAAX,CAAlB;AACA,cAAM,QAAQ,UAAA,kBAAA,CAAmB,SAAnB,CAAd;AAEA,eAAO,KAAP,EAAc,IAAd,CAAmB,MAAnB;AACD,KALD;AAOA,SAAK,wCAAL,EAA+C,MAAK;AAClD,cAAM,YAAY,UAAA,UAAA,CAAW,YAAX,CAAlB;AACA,cAAM,QAAQ,UAAA,kBAAA,CAAmB,SAAnB,CAAd;AAEA,eAAO,KAAP,EAAc,OAAd,CAAsB,EAAE,MAAM,UAAR,EAAoB,cAAc,WAAlC,EAAtB;AACD,KALD;AAOA,SAAK,wCAAL,EAA+C,MAAK;AAClD,cAAM,YAAY,UAAA,UAAA,CAAW,gCAAX,CAAlB;AACA,cAAM,QAAQ,UAAA,kBAAA,CAAmB,SAAnB,CAAd;AAEA,eAAO,KAAP,EAAc,OAAd,CAAsB,CAAC,KAAD,EAAQ,CAAR,EAAW,MAAX,EAAmB,EAAE,MAAM,UAAR,EAAoB,cAAc,WAAlC,EAAnB,CAAtB;AACD,KALD;AAOA,SAAK,4CAAL,EAAmD,MAAK;AACtD,cAAM,YAAY,UAAA,UAAA,CAAW,oDAAX,CAAlB;AACA,cAAM,QAAQ,UAAA,kBAAA,CAAmB,SAAnB,CAAd;AAEA,eAAO,KAAP,EAAc,OAAd,CAAsB;AACpB,iBAAK,KADe;AAEpB,iBAAK,CAFe;AAGpB,iBAAK,MAHe;AAIpB,iBAAK,EAAE,MAAM,UAAR,EAAoB,cAAc,WAAlC,EAJe,EAAtB;;AAMD,KAVD;AAWD,CApED","sourcesContent":["import { parseValue } from 'graphql';\n\nimport { valueFromValueNode } from '../src/utilities/graphql';\n\ndescribe('#valueFromValueNode', () => {\n  test(`should return a number for an IntValue`, () => {\n    const valueNode = parseValue('1');\n    const value = valueFromValueNode(valueNode);\n\n    expect(value).toBe(1);\n  });\n\n  test(`should return a number for a FloatValue`, () => {\n    const valueNode = parseValue('1.0');\n    const value = valueFromValueNode(valueNode);\n\n    expect(value).toBe(1.0);\n  });\n\n  test(`should return a boolean for a BooleanValue`, () => {\n    const valueNode = parseValue('true');\n    const value = valueFromValueNode(valueNode);\n\n    expect(value).toBe(true);\n  });\n\n  test(`should return null for a NullValue`, () => {\n    const valueNode = parseValue('null');\n    const value = valueFromValueNode(valueNode);\n\n    expect(value).toBe(null);\n  });\n\n  test(`should return a string for a StringValue`, () => {\n    const valueNode = parseValue('\"foo\"');\n    const value = valueFromValueNode(valueNode);\n\n    expect(value).toBe('foo');\n  });\n\n  test(`should return a string for an EnumValue`, () => {\n    const valueNode = parseValue('JEDI');\n    const value = valueFromValueNode(valueNode);\n\n    expect(value).toBe('JEDI');\n  });\n\n  test(`should return an object for a Variable`, () => {\n    const valueNode = parseValue('$something');\n    const value = valueFromValueNode(valueNode);\n\n    expect(value).toEqual({ kind: 'Variable', variableName: 'something' });\n  });\n\n  test(`should return an array for a ListValue`, () => {\n    const valueNode = parseValue('[ \"foo\", 1, JEDI, $something ]');\n    const value = valueFromValueNode(valueNode);\n\n    expect(value).toEqual(['foo', 1, 'JEDI', { kind: 'Variable', variableName: 'something' }]);\n  });\n\n  test(`should return an object for an ObjectValue`, () => {\n    const valueNode = parseValue('{ foo: \"foo\", bar: 1, bla: JEDI, baz: $something }');\n    const value = valueFromValueNode(valueNode);\n\n    expect(value).toEqual({\n      foo: 'foo',\n      bar: 1,\n      bla: 'JEDI',\n      baz: { kind: 'Variable', variableName: 'something' }\n    });\n  });\n});\n"],"sourceRoot":""}