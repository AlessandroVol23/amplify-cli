{"version":3,"sources":["codeGeneration.ts"],"names":[],"mappings":"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","sourcesContent":["import { parse, GraphQLNonNull, GraphQLString, GraphQLEnumType, GraphQLList } from 'graphql';\n\nimport { loadSchema } from '../../src/loading';\nconst schema = loadSchema(require.resolve('../fixtures/starwars/schema.json'));\n\nimport {\n  compileToIR,\n  CompilerOptions,\n  CompilerContext,\n  SelectionSet,\n  Field,\n  Argument\n} from '../../src/compiler';\n\nimport { SwiftAPIGenerator } from '../../src/swift/codeGeneration';\n\ndescribe('Swift code generation', () => {\n  let generator: SwiftAPIGenerator;\n\n  beforeEach(() => {\n    generator = new SwiftAPIGenerator({});\n  });\n\n  function compile(\n    source: string,\n    options: CompilerOptions = { mergeInFieldsFromFragmentSpreads: true }\n  ): CompilerContext {\n    const document = parse(source);\n    const context = compileToIR(schema, document, options);\n    generator.context = context;\n    return context;\n  }\n\n  describe('#classDeclarationForOperation()', () => {\n    it(`should generate a class declaration for a query with variables`, () => {\n      const { operations } = compile(`\n        query HeroName($episode: Episode) {\n          hero(episode: $episode) {\n            name\n          }\n        }\n      `);\n\n      generator.classDeclarationForOperation(operations['HeroName']);\n\n      expect(generator.output).toMatchSnapshot();\n    });\n\n    it(`should generate a class declaration for a query with fragment spreads`, () => {\n      const { operations } = compile(`\n        query Hero {\n          hero {\n            ...HeroDetails\n          }\n        }\n\n        fragment HeroDetails on Character {\n          name\n        }\n      `);\n\n      generator.classDeclarationForOperation(operations['Hero']);\n\n      expect(generator.output).toMatchSnapshot();\n    });\n\n    it(`should generate a class declaration for a query with conditional fragment spreads`, () => {\n      const { operations } = compile(`\n        query Hero {\n          hero {\n            ...DroidDetails\n          }\n        }\n\n        fragment DroidDetails on Droid {\n          primaryFunction\n        }\n      `);\n\n      generator.classDeclarationForOperation(operations['Hero']);\n\n      expect(generator.output).toMatchSnapshot();\n    });\n\n    it(`should generate a class declaration for a query with a fragment spread nested in an inline fragment`, () => {\n      const { operations } = compile(`\n        query Hero {\n          hero {\n            ... on Droid {\n              ...HeroDetails\n            }\n          }\n        }\n\n        fragment HeroDetails on Character {\n          name\n        }\n      `);\n\n      generator.classDeclarationForOperation(operations['Hero']);\n\n      expect(generator.output).toMatchSnapshot();\n    });\n\n    it(`should generate a class declaration for a mutation with variables`, () => {\n      const { operations } = compile(`\n        mutation CreateReview($episode: Episode) {\n          createReview(episode: $episode, review: { stars: 5, commentary: \"Wow!\" }) {\n            stars\n            commentary\n          }\n        }\n      `);\n\n      generator.classDeclarationForOperation(operations['CreateReview']);\n\n      expect(generator.output).toMatchSnapshot();\n    });\n\n    it(`should generate a class declaration with an operationIdentifier property when generateOperationIds is specified`, () => {\n      const { operations } = compile(\n        `\n        query Hero {\n          hero {\n            ...HeroDetails\n          }\n        }\n        fragment HeroDetails on Character {\n          name\n        }\n      `,\n        { generateOperationIds: true, mergeInFieldsFromFragmentSpreads: true }\n      );\n\n      generator.classDeclarationForOperation(operations['Hero']);\n\n      expect(generator.output).toMatchSnapshot();\n    });\n  });\n\n  describe('#initializerDeclarationForProperties()', () => {\n    it(`should generate initializer for a property`, () => {\n      generator.initializerDeclarationForProperties([{ propertyName: 'episode', typeName: 'Episode' }]);\n\n      expect(generator.output).toMatchSnapshot();\n    });\n\n    it(`should generate initializer for an optional property`, () => {\n      generator.initializerDeclarationForProperties([\n        { propertyName: 'episode', typeName: 'Episode?', isOptional: true }\n      ]);\n\n      expect(generator.output).toMatchSnapshot();\n    });\n\n    it(`should generate initializer for multiple properties`, () => {\n      generator.initializerDeclarationForProperties([\n        { propertyName: 'episode', typeName: 'Episode?', isOptional: true },\n        { propertyName: 'scene', typeName: 'String?', isOptional: true }\n      ]);\n\n      expect(generator.output).toMatchSnapshot();\n    });\n  });\n\n  describe('#propertyAssignmentForField()', () => {\n    it('should generate expression for nullable scalar', () => {\n      expect(\n        generator.propertyAssignmentForField({\n          responseKey: 'response_key',\n          propertyName: 'propertyName',\n          type: GraphQLString\n        })\n      ).toBe('\"response_key\": propertyName');\n    });\n\n    it('should generate expression for non-null scalar', () => {\n      expect(\n        generator.propertyAssignmentForField({\n          responseKey: 'response_key',\n          propertyName: 'propertyName',\n          type: new GraphQLNonNull(GraphQLString)\n        })\n      ).toBe('\"response_key\": propertyName');\n    });\n\n    it('should generate expression for nullable list of nullable scalars', () => {\n      expect(\n        generator.propertyAssignmentForField({\n          responseKey: 'response_key',\n          propertyName: 'propertyName',\n          type: new GraphQLList(GraphQLString)\n        })\n      ).toBe('\"response_key\": propertyName');\n    });\n\n    it('should generate expression for nullable list of non-null scalars', () => {\n      expect(\n        generator.propertyAssignmentForField({\n          responseKey: 'response_key',\n          propertyName: 'propertyName',\n          type: new GraphQLList(new GraphQLNonNull(GraphQLString))\n        })\n      ).toBe('\"response_key\": propertyName');\n    });\n\n    it('should generate expression for non-null list of nullable scalars', () => {\n      expect(\n        generator.propertyAssignmentForField({\n          responseKey: 'response_key',\n          propertyName: 'propertyName',\n          type: new GraphQLNonNull(new GraphQLList(GraphQLString))\n        })\n      ).toBe('\"response_key\": propertyName');\n    });\n\n    it('should generate expression for non-null list of non-null scalars', () => {\n      expect(\n        generator.propertyAssignmentForField({\n          responseKey: 'response_key',\n          propertyName: 'propertyName',\n          type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(GraphQLString)))\n        })\n      ).toBe('\"response_key\": propertyName');\n    });\n\n    it('should generate expression for nullable composite', () => {\n      expect(\n        generator.propertyAssignmentForField({\n          responseKey: 'response_key',\n          propertyName: 'propertyName',\n          type: schema.getType('Droid')\n        })\n      ).toBe('\"response_key\": propertyName.flatMap { $0.snapshot }');\n    });\n\n    it('should generate expression for non-null composite', () => {\n      expect(\n        generator.propertyAssignmentForField({\n          responseKey: 'response_key',\n          propertyName: 'propertyName',\n          type: new GraphQLNonNull(schema.getType('Droid'))\n        })\n      ).toBe('\"response_key\": propertyName.snapshot');\n    });\n\n    it('should generate expression for nullable list of nullable composites', () => {\n      expect(\n        generator.propertyAssignmentForField({\n          responseKey: 'response_key',\n          propertyName: 'propertyName',\n          type: new GraphQLList(schema.getType('Droid'))\n        })\n      ).toBe('\"response_key\": propertyName.flatMap { $0.map { $0.flatMap { $0.snapshot } } }');\n    });\n\n    it('should generate expression for nullable list of non-null composites', () => {\n      expect(\n        generator.propertyAssignmentForField({\n          responseKey: 'response_key',\n          propertyName: 'propertyName',\n          type: new GraphQLList(new GraphQLNonNull(schema.getType('Droid')))\n        })\n      ).toBe('\"response_key\": propertyName.flatMap { $0.map { $0.snapshot } }');\n    });\n\n    it('should generate expression for non-null list of nullable composites', () => {\n      expect(\n        generator.propertyAssignmentForField({\n          responseKey: 'response_key',\n          propertyName: 'propertyName',\n          type: new GraphQLNonNull(new GraphQLList(schema.getType('Droid')))\n        })\n      ).toBe('\"response_key\": propertyName.map { $0.flatMap { $0.snapshot } }');\n    });\n\n    it('should generate expression for non-null list of non-null composites', () => {\n      expect(\n        generator.propertyAssignmentForField({\n          responseKey: 'response_key',\n          propertyName: 'propertyName',\n          type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(schema.getType('Droid')))\n        })\n      ).toBe('\"response_key\": propertyName.map { $0.snapshot }');\n    });\n  });\n\n  describe('#structDeclarationForFragment()', () => {\n    it(`should generate a struct declaration for a fragment with an abstract type condition`, () => {\n      const { fragments } = compile(`\n        fragment HeroDetails on Character {\n          name\n          appearsIn\n        }\n      `);\n\n      generator.structDeclarationForFragment(fragments['HeroDetails']);\n\n      expect(generator.output).toMatchSnapshot();\n    });\n\n    it(`should generate a struct declaration for a fragment with a concrete type condition`, () => {\n      const { fragments } = compile(`\n        fragment DroidDetails on Droid {\n          name\n          primaryFunction\n        }\n      `);\n\n      generator.structDeclarationForFragment(fragments['DroidDetails']);\n\n      expect(generator.output).toMatchSnapshot();\n    });\n\n    it(`should generate a struct declaration for a fragment with a subselection`, () => {\n      const { fragments } = compile(`\n        fragment HeroDetails on Character {\n          name\n          friends {\n            name\n          }\n        }\n      `);\n\n      generator.structDeclarationForFragment(fragments['HeroDetails']);\n\n      expect(generator.output).toMatchSnapshot();\n    });\n\n    it(`should generate a struct declaration for a fragment that includes a fragment spread`, () => {\n      const { fragments } = compile(`\n        fragment HeroDetails on Character {\n          name\n          ...MoreHeroDetails\n        }\n\n        fragment MoreHeroDetails on Character {\n          appearsIn\n        }\n      `);\n\n      generator.structDeclarationForFragment(fragments['HeroDetails']);\n\n      expect(generator.output).toMatchSnapshot();\n    });\n  });\n\n  describe('#structDeclarationForSelectionSet()', () => {\n    it(`should generate a struct declaration for a selection set`, () => {\n      const { operations } = compile(`\n        query Hero {\n          hero {\n            name\n          }\n        }\n      `);\n\n      const selectionSet = (operations['Hero'].selectionSet.selections[0] as Field)\n        .selectionSet as SelectionSet;\n\n      generator.structDeclarationForSelectionSet({ structName: 'Hero', selectionSet });\n\n      expect(generator.output).toMatchSnapshot();\n    });\n\n    it(`should escape reserved keywords in a struct declaration for a selection set`, () => {\n      const { operations } = compile(`\n        query Hero {\n          hero {\n            private: name\n          }\n        }\n      `);\n\n      const selectionSet = (operations['Hero'].selectionSet.selections[0] as Field)\n        .selectionSet as SelectionSet;\n\n      generator.structDeclarationForSelectionSet({ structName: 'Hero', selectionSet });\n\n      expect(generator.output).toMatchSnapshot();\n    });\n\n    it(`should generate a nested struct declaration for a selection set with subselections`, () => {\n      const { operations } = compile(`\n        query Hero {\n          hero {\n            friends {\n              name\n            }\n          }\n        }\n      `);\n\n      const selectionSet = (operations['Hero'].selectionSet.selections[0] as Field)\n        .selectionSet as SelectionSet;\n\n      generator.structDeclarationForSelectionSet({ structName: 'Hero', selectionSet });\n\n      expect(generator.output).toMatchSnapshot();\n    });\n\n    it(`should generate a struct declaration for a selection set with a fragment spread that matches the parent type`, () => {\n      const { operations } = compile(`\n        query Hero {\n          hero {\n            name\n            ...HeroDetails\n          }\n        }\n\n        fragment HeroDetails on Character {\n          name\n        }\n      `);\n\n      const selectionSet = (operations['Hero'].selectionSet.selections[0] as Field)\n        .selectionSet as SelectionSet;\n\n      generator.structDeclarationForSelectionSet({ structName: 'Hero', selectionSet });\n\n      expect(generator.output).toMatchSnapshot();\n    });\n\n    it(`should generate a struct declaration for a selection set with a fragment spread with a more specific type condition`, () => {\n      const { operations } = compile(`\n        query Hero {\n          hero {\n            name\n            ...DroidDetails\n          }\n        }\n\n        fragment DroidDetails on Droid {\n          name\n        }\n      `);\n\n      const selectionSet = (operations['Hero'].selectionSet.selections[0] as Field)\n        .selectionSet as SelectionSet;\n\n      generator.structDeclarationForSelectionSet({ structName: 'Hero', selectionSet });\n\n      expect(generator.output).toMatchSnapshot();\n    });\n\n    it(`should generate a struct declaration for a selection set with an inline fragment`, () => {\n      const { operations } = compile(`\n        query Hero {\n          hero {\n            name\n            ... on Droid {\n              primaryFunction\n            }\n          }\n        }\n      `);\n\n      const selectionSet = (operations['Hero'].selectionSet.selections[0] as Field)\n        .selectionSet as SelectionSet;\n\n      generator.structDeclarationForSelectionSet({ structName: 'Hero', selectionSet });\n\n      expect(generator.output).toMatchSnapshot();\n    });\n\n    it(`should generate a struct declaration for a fragment spread nested in an inline fragment`, () => {\n      const { operations } = compile(`\n        query Hero {\n          hero {\n            name\n            ... on Droid {\n              ...HeroDetails\n            }\n          }\n        }\n\n        fragment HeroDetails on Character {\n          name\n        }\n      `);\n\n      const selectionSet = (operations['Hero'].selectionSet.selections[0] as Field)\n        .selectionSet as SelectionSet;\n\n      generator.structDeclarationForSelectionSet({ structName: 'Hero', selectionSet });\n\n      expect(generator.output).toMatchSnapshot();\n    });\n\n    it(`should generate a struct declaration for a selection set with a conditional field`, () => {\n      const { operations } = compile(`\n        query Hero($includeName: Boolean!) {\n          hero {\n            name @include(if: $includeName)\n          }\n        }\n      `);\n\n      const selectionSet = (operations['Hero'].selectionSet.selections[0] as Field)\n        .selectionSet as SelectionSet;\n\n      generator.structDeclarationForSelectionSet({ structName: 'Hero', selectionSet });\n\n      expect(generator.output).toMatchSnapshot();\n    });\n  });\n\n  describe('#typeDeclarationForGraphQLType()', () => {\n    it('should generate an enum declaration for a GraphQLEnumType', () => {\n      generator.typeDeclarationForGraphQLType(schema.getType('Episode'));\n\n      expect(generator.output).toMatchSnapshot();\n    });\n\n    it('should escape identifiers in cases of enum declaration for a GraphQLEnumType', () => {\n      const albumPrivaciesEnum = new GraphQLEnumType({\n        name: 'AlbumPrivacies',\n        values: { PUBLIC: { value: 'PUBLIC' }, PRIVATE: { value: 'PRIVATE' } }\n      });\n\n      generator.typeDeclarationForGraphQLType(albumPrivaciesEnum);\n\n      expect(generator.output).toMatchSnapshot();\n    });\n\n    it('should generate a struct declaration for a GraphQLInputObjectType', () => {\n      generator.typeDeclarationForGraphQLType(schema.getType('ReviewInput'));\n\n      expect(generator.output).toMatchSnapshot();\n    });\n  });\n\n  describe('#dictionaryLiteralForFieldArguments()', () => {\n    it('should include expressions for input objects with variables', () => {\n      const { operations } = compile(`\n        mutation FieldArgumentsWithInputObjects($commentary: String!, $red: Int!) {\n          createReview(episode: JEDI, review: { stars: 2, commentary: $commentary, favorite_color: { red: $red, blue: 100, green: 50 } }) {\n            commentary\n          }\n        }\n      `);\n\n      const fieldArguments = (operations['FieldArgumentsWithInputObjects'].selectionSet\n        .selections[0] as Field).args as Argument[];\n      const dictionaryLiteral = generator.helpers.dictionaryLiteralForFieldArguments(fieldArguments);\n\n      expect(dictionaryLiteral).toBe(\n        '[\"episode\": \"JEDI\", \"review\": [\"stars\": 2, \"commentary\": GraphQLVariable(\"commentary\"), \"favorite_color\": [\"red\": GraphQLVariable(\"red\"), \"blue\": 100, \"green\": 50]]]'\n      );\n    });\n  });\n});\n"],"sourceRoot":""}