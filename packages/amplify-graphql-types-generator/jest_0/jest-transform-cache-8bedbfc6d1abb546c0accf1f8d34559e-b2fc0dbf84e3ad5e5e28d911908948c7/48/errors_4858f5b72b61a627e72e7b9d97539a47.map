{"version":3,"sources":["errors.ts"],"names":[],"mappings":";;AAAA,MAAA,YAAA,QAAA,SAAA,CAAA;AACA,MAAA,OAAA,QAAA,MAAA,CAAA;AAKA,MAAA,SAAA,SAA+B,KAA/B,CAAoC;AAGlC,gBAAY,OAAZ,EAA2B;AACzB,cAAM,OAAN;AAHF,aAAA,IAAA,GAAe,WAAf;AAIE,aAAK,OAAL,GAAe,OAAf;AACD,KANiC;;AAApC,QAAA,SAAA,GAAA,SAAA;AASA,MAAM,2BAA2B,QAAQ,GAAR,CAAY,oBAA7C;AAEA,SAAA,QAAA,CAAyB,KAAzB,EAAqC;AACnC,QAAI,iBAAiB,SAArB,EAAgC;AAC9B,wBAAgB,MAAM,OAAtB;AACD,KAFD;AAEO,QAAI,iBAAiB,UAAA,YAArB,EAAmC;AACxC,cAAM,WAAW,MAAM,MAAN,IAAgB,MAAM,MAAN,CAAa,IAA9C;AACA,YAAI,MAAM,SAAV,EAAqB;AACnB,iBAAK,MAAM,QAAX,IAAuB,MAAM,SAA7B,EAAwC;AACtC,gCAAgB,MAAM,OAAtB,EAA+B,QAA/B,EAAyC,SAAS,IAAlD;AACD;AACF,SAJD;AAIO;AACL,4BAAgB,MAAM,OAAtB,EAA+B,QAA/B;AACD;AACF,KATM;AASA;AACL,gBAAQ,GAAR,CAAY,MAAM,KAAlB;AACD;AACF;AAfD,QAAA,QAAA,GAAA,QAAA;AAiBA,SAAA,eAAA,CAAgC,OAAhC,EAAiD,QAAjD,EAAoE,UAApE,EAAuF;AACrF,QAAI,wBAAJ,EAA8B;AAC5B,YAAI,YAAY,UAAhB,EAA4B;AAG1B,oBAAQ,GAAR,CAAY,GAAG,QAAQ,IAAI,UAAU,YAAY,OAAO,EAAxD;AACD,SAJD;AAIO;AAEL,oBAAQ,GAAR,CAAY,UAAU,OAAO,EAA7B;AACD;AACF,KATD;AASO;AACL,YAAI,QAAJ,EAAc;AACZ,kBAAM,oBAAoB,MAAM,SAAS,KAAT,CAAe,KAAK,GAApB,EAAyB,KAAzB,CAA+B,CAAC,CAAhC,EAAmC,IAAnC,CAAwC,KAAK,GAA7C,CAAhC;AACA,oBAAQ,GAAR,CAAY,MAAM,iBAAiB,KAAK,OAAO,EAA/C;AACD,SAHD;AAGO;AACL,oBAAQ,GAAR,CAAY,UAAU,OAAO,EAA7B;AACD;AACF;AACF;AAlBD,QAAA,eAAA,GAAA,eAAA","sourcesContent":["import { GraphQLError } from 'graphql';\nimport * as path from 'path';\n\n// ToolError is used for errors that are part of the expected flow\n// and for which a stack trace should not be printed\n\nexport class ToolError extends Error {\n  name: string = 'ToolError';\n\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n  }\n}\n\nconst isRunningFromXcodeScript = process.env.XCODE_VERSION_ACTUAL;\n\nexport function logError(error: Error) {\n  if (error instanceof ToolError) {\n    logErrorMessage(error.message);\n  } else if (error instanceof GraphQLError) {\n    const fileName = error.source && error.source.name;\n    if (error.locations) {\n      for (const location of error.locations) {\n        logErrorMessage(error.message, fileName, location.line);\n      }\n    } else {\n      logErrorMessage(error.message, fileName);\n    }\n  } else {\n    console.log(error.stack);\n  }\n}\n\nexport function logErrorMessage(message: string, fileName?: string, lineNumber?: number) {\n  if (isRunningFromXcodeScript) {\n    if (fileName && lineNumber) {\n      // Prefixing error output with file name, line and 'error: ',\n      // so Xcode will associate it with the right file and display the error inline\n      console.log(`${fileName}:${lineNumber}: error: ${message}`);\n    } else {\n      // Prefixing error output with 'error: ', so Xcode will display it as an error\n      console.log(`error: ${message}`);\n    }\n  } else {\n    if (fileName) {\n      const truncatedFileName = '/' + fileName.split(path.sep).slice(-4).join(path.sep);\n      console.log(`...${truncatedFileName}: ${message}`);\n    } else {\n      console.log(`error: ${message}`);\n    }\n  }\n}\n"],"sourceRoot":""}