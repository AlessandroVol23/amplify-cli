{"version":3,"sources":["jsonOutput.ts"],"names":[],"mappings":";;AAAA,MAAA,YAAA,QAAA,SAAA,CAAA;AACA,MAAA,aAAA,QAAA,0BAAA,CAAA;AACA,MAAA,oBAAA,QAAA,wBAAA,CAAA;AAEA,MAAA,YAAA,QAAA,gBAAA,CAAA;AACA,MAAM,iBAAiB,UAAA,UAAA,CAAW,QAAQ,OAAR,CAAgB,iCAAhB,CAAX,CAAvB;AAEA,SAAA,iBAAA,CAA2B,MAA3B,EAA2C,SAAwB,cAAnE,EAAiF;AAC/E,QAAM,WAAW,UAAA,KAAA,CAAM,MAAN,CAAjB;AACA,SAAO,WAAA,iBAAA,CAAkB,MAAlB,EAA0B,QAA1B,EAAoC;AACzC,sCAAkC,KADO;AAEzC,iBAAa,IAF4B,EAApC,CAAP;;AAID;AAED,SAAS,aAAT,EAAwB,YAAA;AACtB,OAAK,+DAAL,EAAsE,YAAA;AACpE,UAAM,UAAU,kBAAkB;;;;;;KAAlB,CAAhB;AAQA,UAAM,SAAS,kBAAA,OAAA,CAAgB,OAAhB,CAAf;AAEA,WAAO,MAAP,EAAe,eAAf;AACD,GAZD;AAcA,OAAK,qEAAL,EAA4E,YAAA;AAC1E,UAAM,UAAU,kBAAkB;;;;;;;;;KAAlB,CAAhB;AAWA,UAAM,SAAS,kBAAA,OAAA,CAAgB,OAAhB,CAAf;AAEA,WAAO,MAAP,EAAe,eAAf;AACD,GAfD;AAiBA,OAAK,4FAAL,EAAmG,YAAA;AACjG,UAAM,UAAU,kBAAkB;;;;;;;;;;;;;;;;;KAAlB,CAAhB;AAmBA,UAAM,SAAS,kBAAA,OAAA,CAAgB,OAAhB,CAAf;AAEA,WAAO,MAAP,EAAe,eAAf;AACD,GAvBD;AAyBA,OAAK,sFAAL,EAA6F,YAAA;AAC3F,UAAM,UAAU,kBAAkB;;;;;;;KAAlB,CAAhB;AASA,UAAM,SAAS,kBAAA,OAAA,CAAgB,OAAhB,CAAf;AAEA,WAAO,MAAP,EAAe,eAAf;AACD,GAbD;AAeA,OAAK,IAAL,CAAU,gFAAV,EAA4F,YAAA;AAC1F,UAAM,SAAS,UAAA,WAAA,CAAY;;;;;;;;;;;;;;;;;;;;;KAAZ,CAAf;AAuBA,UAAM,UAAU,kBACd;;;;OADc,EAMd,MANc,CAAhB;AASA,UAAM,SAAS,kBAAA,OAAA,CAAgB,OAAhB,CAAf;AAEA,WAAO,MAAP,EAAe,eAAf;AACD,GApCD;AAqCD,CA7GD","sourcesContent":["import { GraphQLSchema, buildSchema, parse } from 'graphql';\nimport { compileToLegacyIR } from '../src/compiler/legacyIR';\nimport serializeToJSON from '../src/serializeToJSON';\n\nimport { loadSchema } from '../src/loading';\nconst starWarsSchema = loadSchema(require.resolve('./fixtures/starwars/schema.json'));\n\nfunction compileFromSource(source: string, schema: GraphQLSchema = starWarsSchema) {\n  const document = parse(source);\n  return compileToLegacyIR(schema, document, {\n    mergeInFieldsFromFragmentSpreads: false,\n    addTypename: true\n  });\n}\n\ndescribe('JSON output', function() {\n  test(`should generate JSON output for a query with an enum variable`, function() {\n    const context = compileFromSource(`\n      query HeroName($episode: Episode) {\n        hero(episode: $episode) {\n          name\n        }\n      }\n    `);\n\n    const output = serializeToJSON(context);\n\n    expect(output).toMatchSnapshot();\n  });\n\n  test(`should generate JSON output for a query with a nested selection set`, function() {\n    const context = compileFromSource(`\n      query HeroAndFriendsNames {\n        hero {\n          name\n          friends {\n            name\n          }\n        }\n      }\n    `);\n\n    const output = serializeToJSON(context);\n\n    expect(output).toMatchSnapshot();\n  });\n\n  test(`should generate JSON output for a query with a fragment spread and nested inline fragments`, function() {\n    const context = compileFromSource(`\n      query HeroAndDetails {\n        hero {\n          id\n          ...CharacterDetails\n        }\n      }\n\n      fragment CharacterDetails on Character {\n        name\n        ... on Droid {\n          primaryFunction\n        }\n        ... on Human {\n          height\n        }\n      }\n    `);\n\n    const output = serializeToJSON(context);\n\n    expect(output).toMatchSnapshot();\n  });\n\n  test(`should generate JSON output for a mutation with an enum and an input object variable`, function() {\n    const context = compileFromSource(`\n      mutation CreateReview($episode: Episode, $review: ReviewInput) {\n        createReview(episode: $episode, review: $review) {\n          stars\n          commentary\n        }\n      }\n    `);\n\n    const output = serializeToJSON(context);\n\n    expect(output).toMatchSnapshot();\n  });\n\n  test.only(`should generate JSON output for an input object type with default field values`, function() {\n    const schema = buildSchema(`\n      type Query {\n        someField(input: ComplexInput!): String!\n      }\n\n      input ComplexInput {\n        string: String = \"Hello\"\n        customScalar: Date = \"2017-04-16\"\n        listOfString: [String] = [\"test1\", \"test2\", \"test3\"]\n        listOfInt: [Int] = [1, 2, 3]\n        listOfEnums: [Episode] = [JEDI, EMPIRE]\n        listOfCustomScalar: [Date] = [\"2017-04-16\", \"2017-04-17\", \"2017-04-18\"]\n      }\n\n      scalar Date\n\n      enum Episode {\n        NEWHOPE\n        EMPIRE\n        JEDI\n      }\n    `);\n\n    const context = compileFromSource(\n      `\n      query QueryWithComplexInput($input: ComplexInput) {\n        someField(input: $input)\n      }\n      `,\n      schema\n    );\n\n    const output = serializeToJSON(context);\n\n    expect(output).toMatchSnapshot();\n  });\n});\n"],"sourceRoot":""}