{"version":3,"sources":["printer.ts"],"names":[],"mappings":";;AACA,MAAA,cAAA,QAAA,kBAAA,CAAA;AAEA,MAAA,gBAAA,QAAA,aAAA,CAAA;AAIA,MAAA,OAAA,CAAA;AAAA,kBAAA;AACU,aAAA,UAAA,GAA0B,EAA1B;AAyGT;AAvGQ,YAAK;AACV,eAAO,KAAK,UAAL;AACJ,cADI,CAEH,CAAC,QAAD,EAAmB,SAAnB,KAAgC;AAC9B,gBAAI,OAAO,SAAP,KAAqB,QAAzB,EAAmC;AACjC,uBAAO,WAAW,SAAlB;AACD,aAFD;AAEO;AACL,sBAAM,eAAe,YAAA,OAAA,CAAS,SAAT,EAAoB,IAAzC;AACA,uBAAO,WAAW,KAAK,SAAL,CAAe,YAAf,CAAlB;AACD;AACF,SATE,EAUH,EAVG,CAAP;AAYD;AAEM,YAAQ,SAAR,EAA4B;AACjC,aAAK,UAAL,GAAkB;AAChB,WAAG,KAAK,UADQ;AAEhB,YAFgB;AAGhB,YAHgB;AAIhB,iBAJgB,CAAlB;;AAMD;AAEM,oBAAa;AAClB,cAAM,SAAS,KAAK,KAAL,EAAf;AACA,aAAK,UAAL,GAAkB,EAAlB;AACA,eAAO,MAAP;AACD;AAoBO,cAAU,YAAV,EAA8B;AACpC,cAAM,QAAQ,aAAa,KAAb,CAAmB,IAAnB,CAAd;AACA,YAAI,cAAc,CAAlB;AACA,YAAI,QAAJ;AACA,cAAM,mBAAmB,EAAzB;AAGA,YAAI,mBAAmB,CAAvB;AAEA,eAAO,gBAAgB,MAAM,MAA7B,EAAqC;AACnC,uBAAW,cAAc,CAAzB;AACA,kBAAM,mBAAmB,cAAA,WAAW,GAAG,MAAM,QAAN,CAAe,EAAtD;AACA,gBAAI,iBAAiB,MAAjB,KAA4B,CAA5B,IAAiC,iBAAiB,CAAjB,MAAwB,GAA7D,EAAkE;AAChE,sBAAM,sBAAsB,MAAM,WAAN,CAA5B;AACA,sBAAM,gBAAgB,oBAAoB,OAApB,CAA4B,IAA5B,CAAtB;AACA,oBAAI,mBAAmB,aAAvB,EAAsC;AACpC,uCAAmB,aAAnB;AACD;AAED,sBAAM,CAAC,QAAD,EAAW,OAAX,IAAsB,oBAAoB,KAApB,CAA0B,IAA1B,CAA5B;AACA,iCAAiB,IAAjB,CAAsB;AACpB,0BAAM,SAAS,OAAT,CAAiB,OAAjB,EAA0B,EAA1B,IAAgC,GADlB;AAEpB,6BAAS,QAAQ,IAAR,EAFW,EAAtB;;AAIA;AACD,aAbD;AAaO;AACL,iCAAiB,IAAjB,CAAsB;AACpB,0BAAM,MAAM,WAAN,CADc;AAEpB,6BAAS,IAFW,EAAtB;;AAID;AAED;AACD;AAED,eAAO,iBAAiB,MAAjB,CAAwB,CAAC,IAAD,EAAiB,IAAjB,KAAyB;AACtD,kBAAM,EACJ,IADI,EAEJ,OAFI,KAGF,IAHJ;AAKA,gBAAI,IAAJ;AACA,gBAAI,YAAY,IAAhB,EAAsB;AACpB,sBAAM,gBAAgB,mBAAmB,KAAK,MAA9C;AACA,uBAAO,GAAG,IAAI,GAAG,IAAI,MAAJ,CAAW,aAAX,CAAyB,OAAO,OAAO,EAAxD;AACD,aAHD;AAGO;AACL,uBAAO,IAAP;AACD;AAED,mBAAO;AACL,eAAG,IADE;AAEL,gBAFK,CAAP;;AAID,SAlBM,EAkBJ,EAlBI,EAkBA,IAlBA,CAkBK,IAlBL,CAAP;AAmBD,KAzGH;;AAAA,QAAA,OAAA,GAAA,OAAA","sourcesContent":["import * as t from '@babel/types';\nimport generate from '@babel/generator';\n\nimport { stripIndent } from 'common-tags';\n\ntype Printable = t.Node | string;\n\nexport default class Printer {\n  private printQueue: Printable[] = []\n\n  public print(): string {\n    return this.printQueue\n      .reduce(\n        (document: string, printable) => {\n          if (typeof printable === 'string') {\n            return document + printable;\n          } else {\n            const documentPart = generate(printable).code;\n            return document + this.fixCommas(documentPart);\n          }\n        },\n        ''\n      ) as string;\n  }\n\n  public enqueue(printable: Printable) {\n    this.printQueue = [\n      ...this.printQueue,\n      '\\n',\n      '\\n',\n      printable\n    ];\n  }\n\n  public printAndClear() {\n    const output = this.print();\n    this.printQueue = [];\n    return output;\n  }\n\n  /**\n   * When using trailing commas on ObjectTypeProperties within\n   * ObjectTypeAnnotations, we get weird behavior:\n   * ```\n   * {\n   *   homePlanet: ?string // description\n   *   ,\n   *   friends: any  // description\n   * }\n   * ```\n   * when we want\n   * ```\n   * {\n   *   homePlanet: ?string, // description\n   *   friends: any         // description\n   * }\n   * ```\n   */\n  private fixCommas(documentPart: string) {\n    const lines = documentPart.split('\\n');\n    let currentLine = 0;\n    let nextLine;\n    const newDocumentParts = [];\n    // Keep track of what column comments should start on\n    // to keep things aligned\n    let maxCommentColumn = 0;\n\n    while (currentLine !== lines.length) {\n      nextLine = currentLine + 1;\n      const strippedNextLine = stripIndent`${lines[nextLine]}`;\n      if (strippedNextLine.length === 1 && strippedNextLine[0] === ',') {\n        const currentLineContents = lines[currentLine];\n        const commentColumn = currentLineContents.indexOf('//');\n        if (maxCommentColumn < commentColumn) {\n          maxCommentColumn = commentColumn;\n        }\n\n        const [contents, comment] = currentLineContents.split('//');\n        newDocumentParts.push({\n          main: contents.replace(/\\s+$/g, '') + ',',\n          comment: comment.trim()\n        });\n        currentLine++;\n      } else {\n        newDocumentParts.push({\n          main: lines[currentLine],\n          comment: null\n        });\n      }\n\n      currentLine++;\n    }\n\n    return newDocumentParts.reduce((memo: string[], part) => {\n      const {\n        main,\n        comment\n      } = part;\n\n      let line;\n      if (comment !== null) {\n        const spacesBetween = maxCommentColumn - main.length;\n        line = `${main}${' '.repeat(spacesBetween)} // ${comment}`\n      } else {\n        line = main;\n      }\n\n      return [\n        ...memo,\n        line\n      ];\n    }, []).join('\\n');\n  }\n}\n"],"sourceRoot":""}