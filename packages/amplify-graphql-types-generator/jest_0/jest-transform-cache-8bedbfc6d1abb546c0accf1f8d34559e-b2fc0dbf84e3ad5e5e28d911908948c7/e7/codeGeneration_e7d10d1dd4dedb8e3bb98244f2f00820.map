{"version":3,"sources":["codeGeneration.js"],"names":[],"mappings":"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","sourcesContent":["import { stripIndent } from 'common-tags';\n\nimport {\n  parse,\n  isType,\n  GraphQLID,\n  GraphQLString,\n  GraphQLInt,\n  GraphQLList,\n  GraphQLNonNull\n} from 'graphql';\n\nimport {\n  generateSource\n} from '../../src/typescript/codeGeneration';\n\nimport { loadSchema } from '../../src/loading';\nconst starWarsSchema = loadSchema(require.resolve('../fixtures/starwars/schema.json'));\nconst miscSchema = loadSchema(require.resolve('../fixtures/misc/schema.json'));\n\nimport CodeGenerator from '../../src/utilities/CodeGenerator';\n\nimport { compileToLegacyIR } from '../../src/compiler/legacyIR';\n\ndescribe('TypeScript code generation', function() {\n  let generator;\n  let compileFromSource;\n  let addFragment;\n\n  function setup(schema) {\n    const context = {\n      schema: schema,\n      operations: {},\n      fragments: {},\n      typesUsed: {}\n    }\n\n    generator = new CodeGenerator(context);\n\n    compileFromSource = (source) => {\n      const document = parse(source);\n      const context = compileToLegacyIR(schema, document, {\n        mergeInFieldsFromFragmentSpreads: true,\n        addTypename: true\n      });\n      generator.context = context;\n      return context;\n    };\n\n    addFragment = (fragment) => {\n      generator.context.fragments[fragment.fragmentName] = fragment;\n    };\n\n    return { generator, compileFromSource, addFragment };\n  }\n\n  describe('#generateSource()', function() {\n    test(`should generate simple query operations`, function() {\n      const { compileFromSource } = setup(starWarsSchema);\n      const context = compileFromSource(`\n        query HeroName {\n          hero {\n            name\n          }\n        }\n      `);\n\n      const source = generateSource(context);\n      expect(source).toMatchSnapshot();\n    });\n\n    test(`should generate simple query operations including input variables`, function() {\n      const { compileFromSource } = setup(starWarsSchema);\n      const context = compileFromSource(`\n        query HeroName($episode: Episode) {\n          hero(episode: $episode) {\n            name\n          }\n        }\n      `);\n\n      const source = generateSource(context);\n      expect(source).toMatchSnapshot();\n    });\n\n    test(`should generate simple nested query operations including input variables`, function() {\n      const { compileFromSource } = setup(starWarsSchema);\n      const context = compileFromSource(`\n        query HeroAndFriendsNames($episode: Episode) {\n          hero(episode: $episode) {\n            name\n            friends {\n              name\n            }\n          }\n        }\n      `);\n\n      const source = generateSource(context);\n      expect(source).toMatchSnapshot();\n    });\n\n    test(`should generate simple nested with required elements in lists`, function() {\n      const { compileFromSource } = setup(starWarsSchema);\n      const context = compileFromSource(`\n        query StarshipCoords {\n          starship {\n            coordinates\n          }\n        }\n      `);\n\n      const source = generateSource(context);\n      expect(source).toMatchSnapshot();\n    });\n\n    test(`should generate fragmented query operations`, function() {\n      const { compileFromSource } = setup(starWarsSchema);\n      const context = compileFromSource(`\n        query HeroAndFriendsNames {\n          hero {\n            name\n            ...heroFriends\n          }\n        }\n\n        fragment heroFriends on Character {\n          friends {\n            name\n          }\n        }\n      `);\n\n      const source = generateSource(context);\n      expect(source).toMatchSnapshot();\n    });\n\n    test(`should generate query operations with inline fragments`, function() {\n      const { compileFromSource } = setup(starWarsSchema);\n      const context = compileFromSource(`\n        query HeroAndDetails {\n          hero {\n            name\n            ...HeroDetails\n          }\n        }\n\n        fragment HeroDetails on Character {\n          ... on Droid {\n            primaryFunction\n          }\n          ... on Human {\n            height\n          }\n        }\n      `);\n\n      const source = generateSource(context);\n      expect(source).toMatchSnapshot();\n    });\n\n    test(`should generate mutation operations with complex input types`, function() {\n      const { compileFromSource } = setup(starWarsSchema);\n      const context = compileFromSource(`\n        mutation ReviewMovie($episode: Episode, $review: ReviewInput) {\n          createReview(episode: $episode, review: $review) {\n            stars\n            commentary\n          }\n        }\n      `);\n\n      const source = generateSource(context);\n      expect(source).toMatchSnapshot();\n    });\n\n    test(`should generate correct list with custom fragment`, function() {\n      const { compileFromSource } = setup(starWarsSchema);\n      const context = compileFromSource(`\n        fragment Friend on Character {\n          name\n        }\n\n        query HeroAndFriendsNames($episode: Episode) {\n          hero(episode: $episode) {\n            name\n            friends {\n              ...Friend\n            }\n          }\n        }\n      `);\n\n      const source = generateSource(context);\n      expect(source).toMatchSnapshot();\n    });\n\n    test('should handle single line comments', () => {\n      const { compileFromSource } = setup(miscSchema);\n      const context = compileFromSource(`\n        query CustomScalar {\n          commentTest {\n            singleLine\n          }\n        }\n      `);\n\n      const source = generateSource(context);\n      expect(source).toMatchSnapshot();\n    });\n\n    test('should handle multi-line comments', () => {\n      const { compileFromSource } = setup(miscSchema);\n      const context = compileFromSource(`\n        query CustomScalar {\n          commentTest {\n            multiLine\n          }\n        }\n      `);\n\n      const source = generateSource(context);\n      expect(source).toMatchSnapshot();\n    });\n\n    test('should handle comments in enums', () => {\n      const { compileFromSource } = setup(miscSchema);\n      const context = compileFromSource(`\n        query CustomScalar {\n          commentTest {\n            enumCommentTest\n          }\n        }\n      `);\n\n      const source = generateSource(context);\n      expect(source).toMatchSnapshot();\n    });\n\n    test('should handle interfaces at root', () => {\n      const { compileFromSource } = setup(miscSchema);\n      const context = compileFromSource(`\n        query CustomScalar {\n          interfaceTest {\n            prop\n            ... on ImplA {\n              propA\n            }\n            ... on ImplB {\n              propB\n            }\n          }\n        }\n      `);\n\n      const source = generateSource(context);\n      expect(source).toMatchSnapshot();\n    });\n\n    test('should handle unions at root', () => {\n      const { compileFromSource } = setup(miscSchema);\n      const context = compileFromSource(`\n        query CustomScalar {\n          unionTest {\n            ... on PartialA {\n              prop\n            }\n            ... on PartialB {\n              prop\n            }\n          }\n        }\n      `);\n\n      const source = generateSource(context);\n      expect(source).toMatchSnapshot();\n    });\n\n    test('should have __typename value matching fragment type on generic type', () => {\n      const { compileFromSource } = setup(starWarsSchema);\n      const context = compileFromSource(`\n        query HeroName {\n          hero {\n            ...HeroWithName\n          }\n        }\n\n        fragment HeroWithName on Character {\n          __typename\n          name\n        }\n      `);\n\n      const source = generateSource(context);\n      expect(source).toMatchSnapshot();\n    });\n\n    test('should have __typename value matching fragment type on specific type', () => {\n      const { compileFromSource } = setup(starWarsSchema);\n      const context = compileFromSource(`\n        query DroidName {\n          droid {\n            ...DroidWithName\n          }\n        }\n\n        fragment DroidWithName on Droid {\n          __typename\n          name\n        }\n      `);\n\n      const source = generateSource(context);\n      expect(source).toMatchSnapshot();\n    });\n  });\n});\n"],"sourceRoot":""}