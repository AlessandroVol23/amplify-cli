{"version":3,"sources":["collectFragmentsReferenced.ts"],"names":[],"mappings":";;AAEA,SAAA,0BAAA,CACE,YADF,EAEE,SAFF,EAGE,sBAAmC,IAAI,GAAJ,EAHrC,EAG8C;AAE5C,SAAK,MAAM,SAAX,IAAwB,aAAa,UAArC,EAAiD;AAC/C,gBAAQ,UAAU,IAAlB;AACE,iBAAK,gBAAL;AACE,oCAAoB,GAApB,CAAwB,UAAU,YAAlC;AAEA,sBAAM,WAAW,UAAU,UAAU,YAApB,CAAjB;AACA,oBAAI,CAAC,QAAL,EAAe;AACb,0BAAM,IAAI,KAAJ,CAAU,yBAAyB,UAAU,YAAY,GAAzD,CAAN;AACD;AAED,2CAA2B,SAAS,YAApC,EAAkD,SAAlD,EAA6D,mBAA7D;AACA;AACF,iBAAK,OAAL;AACA,iBAAK,eAAL;AACA,iBAAK,kBAAL;AACE,oBAAI,UAAU,YAAd,EAA4B;AAC1B,+CAA2B,UAAU,YAArC,EAAmD,SAAnD,EAA8D,mBAA9D;AACD;AACD,sBAjBJ;;AAmBD;AAED,WAAO,mBAAP;AACD;AA5BD,QAAA,0BAAA,GAAA,0BAAA","sourcesContent":["import { SelectionSet, Fragment } from '../';\n\nexport function collectFragmentsReferenced(\n  selectionSet: SelectionSet,\n  fragments: { [fragmentName: string]: Fragment },\n  fragmentsReferenced: Set<string> = new Set()\n): Set<string> {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case 'FragmentSpread':\n        fragmentsReferenced.add(selection.fragmentName);\n\n        const fragment = fragments[selection.fragmentName];\n        if (!fragment) {\n          throw new Error(`Cannot find fragment \"${selection.fragmentName}\"`);\n        }\n\n        collectFragmentsReferenced(fragment.selectionSet, fragments, fragmentsReferenced);\n        break;\n      case 'Field':\n      case 'TypeCondition':\n      case 'BooleanCondition':\n        if (selection.selectionSet) {\n          collectFragmentsReferenced(selection.selectionSet, fragments, fragmentsReferenced);\n        }\n        break;\n    }\n  }\n\n  return fragmentsReferenced;\n}\n"],"sourceRoot":""}