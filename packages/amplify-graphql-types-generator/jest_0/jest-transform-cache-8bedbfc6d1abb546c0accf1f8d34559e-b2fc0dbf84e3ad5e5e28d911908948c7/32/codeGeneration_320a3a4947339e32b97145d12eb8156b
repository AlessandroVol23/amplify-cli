196eb17d15f6d68b2c56e715978e1df3
'use strict';require('ts-jest').install("/c/Users/Sandro/repo/amplify-cli/packages/amplify-graphql-types-generator/test/scala/codeGeneration.js", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst graphql_1 = require(\"graphql\");\nconst codeGeneration_1 = require(\"../../src/scala/codeGeneration\");\nconst values_1 = require(\"../../src/scala/values\");\nconst loading_1 = require(\"../../src/loading\");\nconst schema = loading_1.loadSchema(require.resolve('../fixtures/starwars/schema.json'));\nconst CodeGenerator_1 = require(\"../../src/utilities/CodeGenerator\");\nconst legacyIR_1 = require(\"../../src/compiler/legacyIR\");\ndescribe('Scala code generation', function () {\n    let generator;\n    let resetGenerator;\n    let compileFromSource;\n    let addFragment;\n    beforeEach(function () {\n        resetGenerator = () => {\n            const context = {\n                schema: schema,\n                operations: {},\n                fragments: {},\n                typesUsed: {}\n            };\n            generator = new CodeGenerator_1.default(context);\n        };\n        compileFromSource = (source, options = { generateOperationIds: false }) => {\n            const document = graphql_1.parse(source);\n            let context = legacyIR_1.compileToLegacyIR(schema, document);\n            options.generateOperationIds && Object.assign(context, { generateOperationIds: true, operationIdsMap: {} });\n            generator.context = context;\n            return context;\n        };\n        addFragment = (fragment) => {\n            generator.context.fragments[fragment.fragmentName] = fragment;\n        };\n        resetGenerator();\n    });\n    describe('#classDeclarationForOperation()', function () {\n        test(`should generate a class declaration for a query with variables`, function () {\n            const { operations, fragments } = compileFromSource(`\n        query HeroName($episode: Episode) {\n          hero(episode: $episode) {\n            name\n          }\n        }\n      `);\n            codeGeneration_1.classDeclarationForOperation(generator, operations['HeroName'], Object.values(fragments));\n            expect(generator.output).toMatchSnapshot();\n        });\n        test(`should generate a class declaration for a query with fragment spreads`, function () {\n            const { operations, fragments } = compileFromSource(`\n        query Hero {\n          hero {\n            ...HeroDetails\n          }\n        }\n\n        fragment HeroDetails on Character {\n          name\n        }\n      `);\n            codeGeneration_1.classDeclarationForOperation(generator, operations['Hero'], Object.values(fragments));\n            expect(generator.output).toMatchSnapshot();\n        });\n        test(`should generate a class declaration for a query with conditional fragment spreads`, function () {\n            const { operations, fragments } = compileFromSource(`\n        query Hero {\n          hero {\n            ...DroidDetails\n          }\n        }\n\n        fragment DroidDetails on Droid {\n          primaryFunction\n        }\n      `);\n            codeGeneration_1.classDeclarationForOperation(generator, operations['Hero'], Object.values(fragments));\n            expect(generator.output).toMatchSnapshot();\n        });\n        test(`should generate a class declaration for a query with a fragment spread nested in an inline fragment`, function () {\n            const { operations, fragments } = compileFromSource(`\n        query Hero {\n          hero {\n            ... on Droid {\n              ...HeroDetails\n            }\n          }\n        }\n\n        fragment HeroDetails on Character {\n          name\n        }\n      `);\n            codeGeneration_1.classDeclarationForOperation(generator, operations['Hero'], Object.values(fragments));\n            expect(generator.output).toMatchSnapshot();\n        });\n        test(`should generate a class declaration for a mutation with variables`, function () {\n            const { operations, fragments } = compileFromSource(`\n        mutation CreateReview($episode: Episode) {\n          createReview(episode: $episode, review: { stars: 5, commentary: \"Wow!\" }) {\n            stars\n            commentary\n          }\n        }\n      `);\n            codeGeneration_1.classDeclarationForOperation(generator, operations['CreateReview'], Object.values(fragments));\n            expect(generator.output).toMatchSnapshot();\n        });\n        describe(`when generateOperationIds is specified`, function () {\n            let compileOptions = { generateOperationIds: true };\n            test(`should generate a class declaration with an operationId property`, function () {\n                const context = compileFromSource(`\n          query Hero {\n            hero {\n              ...HeroDetails\n            }\n          }\n          fragment HeroDetails on Character {\n            name\n          }\n        `, compileOptions);\n                codeGeneration_1.classDeclarationForOperation(generator, context.operations['Hero'], Object.values(context.fragments));\n                expect(generator.output).toMatchSnapshot();\n            });\n            test(`should generate different operation ids for different operations`, function () {\n                const context1 = compileFromSource(`\n          query Hero {\n            hero {\n              ...HeroDetails\n            }\n          }\n          fragment HeroDetails on Character {\n            name\n          }\n        `, compileOptions);\n                codeGeneration_1.classDeclarationForOperation(generator, context1.operations['Hero'], Object.values(context1.fragments));\n                const output1 = generator.output;\n                resetGenerator();\n                const context2 = compileFromSource(`\n          query Hero {\n            hero {\n              ...HeroDetails\n            }\n          }\n          fragment HeroDetails on Character {\n            appearsIn\n          }\n        `, compileOptions);\n                codeGeneration_1.classDeclarationForOperation(generator, context2.operations['Hero'], Object.values(context2.fragments));\n                const output2 = generator.output;\n                expect(output1).not.toBe(output2);\n            });\n            test(`should generate the same operation id regardless of operation formatting/commenting`, function () {\n                const context1 = compileFromSource(`\n          query HeroName($episode: Episode) {\n            hero(episode: $episode) {\n              name\n            }\n          }\n        `, compileOptions);\n                codeGeneration_1.classDeclarationForOperation(generator, context1.operations['HeroName'], Object.values(context1.fragments));\n                const output1 = generator.output;\n                resetGenerator();\n                const context2 = compileFromSource(`\n          # Profound comment\n          query HeroName($episode:Episode) { hero(episode: $episode) { name } }\n          # Deeply meaningful comment\n        `, compileOptions);\n                codeGeneration_1.classDeclarationForOperation(generator, context2.operations['HeroName'], Object.values(context2.fragments));\n                const output2 = generator.output;\n                expect(output1).toBe(output2);\n            });\n            test(`should generate the same operation id regardless of fragment order`, function () {\n                const context1 = compileFromSource(`\n          query Hero {\n            hero {\n              ...HeroName\n              ...HeroAppearsIn\n            }\n          }\n          fragment HeroName on Character {\n            name\n          }\n          fragment HeroAppearsIn on Character {\n            appearsIn\n          }\n        `, compileOptions);\n                codeGeneration_1.classDeclarationForOperation(generator, context1.operations['Hero'], Object.values(context1.fragments));\n                const output1 = generator.output;\n                resetGenerator();\n                const context2 = compileFromSource(`\n          query Hero {\n            hero {\n              ...HeroName\n              ...HeroAppearsIn\n            }\n          }\n          fragment HeroAppearsIn on Character {\n            appearsIn\n          }\n          fragment HeroName on Character {\n            name\n          }\n        `, compileOptions);\n                codeGeneration_1.classDeclarationForOperation(generator, context2.operations['Hero'], Object.values(context2.fragments));\n                const output2 = generator.output;\n                expect(output1).toBe(output2);\n            });\n            test(`should generate appropriate operation id mapping source when there are nested fragment references`, function () {\n                const source = `\n          query Hero {\n            hero {\n              ...HeroDetails\n            }\n          }\n          fragment HeroName on Character {\n            name\n          }\n          fragment HeroDetails on Character {\n            ...HeroName\n            appearsIn\n          }\n        `;\n                const context = compileFromSource(source, true);\n                expect(context.operations['Hero'].sourceWithFragments).toMatchSnapshot();\n            });\n        });\n    });\n    describe('#caseClassDeclarationForFragment()', function () {\n        test(`should generate a caseClass declaration for a fragment with an abstract type condition`, function () {\n            const { fragments } = compileFromSource(`\n        fragment HeroDetails on Character {\n          name\n          appearsIn\n        }\n      `);\n            codeGeneration_1.caseClassDeclarationForFragment(generator, fragments['HeroDetails']);\n            expect(generator.output).toMatchSnapshot();\n        });\n        test(`should generate a caseClass declaration for a fragment with a concrete type condition`, function () {\n            const { fragments } = compileFromSource(`\n        fragment DroidDetails on Droid {\n          name\n          primaryFunction\n        }\n      `);\n            codeGeneration_1.caseClassDeclarationForFragment(generator, fragments['DroidDetails']);\n            expect(generator.output).toMatchSnapshot();\n        });\n        test(`should generate a caseClass declaration for a fragment with a subselection`, function () {\n            const { fragments } = compileFromSource(`\n        fragment HeroDetails on Character {\n          name\n          friends {\n            name\n          }\n        }\n      `);\n            codeGeneration_1.caseClassDeclarationForFragment(generator, fragments['HeroDetails']);\n            expect(generator.output).toMatchSnapshot();\n        });\n        test(`should generate a caseClass declaration for a fragment that includes a fragment spread`, function () {\n            const { fragments } = compileFromSource(`\n        fragment HeroDetails on Character {\n          name\n          ...MoreHeroDetails\n        }\n\n        fragment MoreHeroDetails on Character {\n          appearsIn\n        }\n      `);\n            codeGeneration_1.caseClassDeclarationForFragment(generator, fragments['HeroDetails']);\n            expect(generator.output).toMatchSnapshot();\n        });\n    });\n    describe('#caseClassDeclarationForSelectionSet()', function () {\n        test(`should generate a caseClass declaration for a selection set`, function () {\n            codeGeneration_1.caseClassDeclarationForSelectionSet(generator, {\n                caseClassName: 'Hero',\n                parentType: schema.getType('Character'),\n                fields: [\n                    {\n                        responseName: 'name',\n                        fieldName: 'name',\n                        type: graphql_1.GraphQLString\n                    }\n                ]\n            });\n            expect(generator.output).toMatchSnapshot();\n        });\n        test(`should escape reserved keywords in a caseClass declaration for a selection set`, function () {\n            codeGeneration_1.caseClassDeclarationForSelectionSet(generator, {\n                caseClassName: 'Hero',\n                parentType: schema.getType('Character'),\n                fields: [\n                    {\n                        responseName: 'private',\n                        fieldName: 'name',\n                        type: graphql_1.GraphQLString\n                    }\n                ]\n            });\n            expect(generator.output).toMatchSnapshot();\n        });\n        test(`should generate a nested caseClass declaration for a selection set with subselections`, function () {\n            codeGeneration_1.caseClassDeclarationForSelectionSet(generator, {\n                caseClassName: 'Hero',\n                parentType: schema.getType('Character'),\n                fields: [\n                    {\n                        responseName: 'friends',\n                        fieldName: 'friends',\n                        type: new graphql_1.GraphQLList(schema.getType('Character')),\n                        fields: [\n                            {\n                                responseName: 'name',\n                                fieldName: 'name',\n                                type: graphql_1.GraphQLString\n                            }\n                        ]\n                    }\n                ]\n            });\n            expect(generator.output).toMatchSnapshot();\n        });\n        test(`should generate a caseClass declaration for a selection set with a fragment spread that matches the parent type`, function () {\n            addFragment({\n                fragmentName: 'HeroDetails',\n                typeCondition: schema.getType('Character')\n            });\n            codeGeneration_1.caseClassDeclarationForSelectionSet(generator, {\n                caseClassName: 'Hero',\n                parentType: schema.getType('Character'),\n                fragmentSpreads: ['HeroDetails'],\n                fields: [\n                    {\n                        responseName: 'name',\n                        fieldName: 'name',\n                        type: graphql_1.GraphQLString\n                    }\n                ]\n            });\n            expect(generator.output).toMatchSnapshot();\n        });\n        test(`should generate a caseClass declaration for a selection set with a fragment spread with a more specific type condition`, function () {\n            addFragment({\n                fragmentName: 'DroidDetails',\n                typeCondition: schema.getType('Droid')\n            });\n            codeGeneration_1.caseClassDeclarationForSelectionSet(generator, {\n                caseClassName: 'Hero',\n                parentType: schema.getType('Character'),\n                fragmentSpreads: ['DroidDetails'],\n                fields: [\n                    {\n                        responseName: 'name',\n                        fieldName: 'name',\n                        type: graphql_1.GraphQLString\n                    }\n                ]\n            });\n            expect(generator.output).toMatchSnapshot();\n        });\n        test(`should generate a caseClass declaration for a selection set with an inline fragment`, function () {\n            codeGeneration_1.caseClassDeclarationForSelectionSet(generator, {\n                caseClassName: 'Hero',\n                parentType: schema.getType('Character'),\n                fields: [\n                    {\n                        responseName: 'name',\n                        fieldName: 'name',\n                        type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLString)\n                    }\n                ],\n                inlineFragments: [\n                    {\n                        typeCondition: schema.getType('Droid'),\n                        possibleTypes: ['Droid'],\n                        fields: [\n                            {\n                                responseName: 'name',\n                                fieldName: 'name',\n                                type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLString)\n                            },\n                            {\n                                responseName: 'primaryFunction',\n                                fieldName: 'primaryFunction',\n                                type: graphql_1.GraphQLString\n                            }\n                        ]\n                    }\n                ]\n            });\n            expect(generator.output).toMatchSnapshot();\n        });\n        test(`should generate a caseClass declaration for a fragment spread nested in an inline fragment`, function () {\n            addFragment({\n                fragmentName: 'HeroDetails',\n                typeCondition: schema.getType('Character')\n            });\n            codeGeneration_1.caseClassDeclarationForSelectionSet(generator, {\n                caseClassName: 'Hero',\n                parentType: schema.getType('Character'),\n                fields: [],\n                inlineFragments: [\n                    {\n                        typeCondition: schema.getType('Droid'),\n                        possibleTypes: ['Droid'],\n                        fields: [],\n                        fragmentSpreads: ['HeroDetails'],\n                    }\n                ]\n            });\n            expect(generator.output).toMatchSnapshot();\n        });\n    });\n    describe('#dictionaryLiteralForFieldArguments()', function () {\n        test('should include expressions for input objects with variables', function () {\n            const { operations } = compileFromSource(`\n        mutation FieldArgumentsWithInputObjects($commentary: String!, $red: Int!) {\n          createReview(episode: JEDI, review: { stars: 2, commentary: $commentary, favorite_color: { red: $red, blue: 100, green: 50 } }) {\n            commentary\n          }\n        }\n      `);\n            const fieldArguments = operations['FieldArgumentsWithInputObjects'].fields[0].args;\n            const dictionaryLiteral = values_1.dictionaryLiteralForFieldArguments(fieldArguments);\n            expect(dictionaryLiteral).toBe('[\"episode\": \"JEDI\", \"review\": [\"stars\": 2, \"commentary\": Variable(\"commentary\"), \"favorite_color\": [\"red\": Variable(\"red\"), \"blue\": 100, \"green\": 50]]]');\n        });\n    });\n    describe('#typeDeclarationForGraphQLType()', function () {\n        test('should generate an enum declaration for a GraphQLEnumType', function () {\n            const generator = new CodeGenerator_1.default();\n            codeGeneration_1.typeDeclarationForGraphQLType(generator, schema.getType('Episode'));\n            expect(generator.output).toMatchSnapshot();\n        });\n        test('should escape identifiers in cases of enum declaration for a GraphQLEnumType', function () {\n            const generator = new CodeGenerator_1.default();\n            const albumPrivaciesEnum = new graphql_1.GraphQLEnumType({\n                name: 'AlbumPrivacies',\n                values: { PUBLIC: { value: \"PUBLIC\" }, PRIVATE: { value: \"PRIVATE\" } }\n            });\n            codeGeneration_1.typeDeclarationForGraphQLType(generator, albumPrivaciesEnum);\n            expect(generator.output).toMatchSnapshot();\n        });\n        test('should generate a caseClass declaration for a GraphQLInputObjectType', function () {\n            const generator = new CodeGenerator_1.default();\n            codeGeneration_1.typeDeclarationForGraphQLType(generator, schema.getType('ReviewInput'));\n            expect(generator.output).toMatchSnapshot();\n        });\n    });\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29kZUdlbmVyYXRpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb2RlR2VuZXJhdGlvbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBLHFDQVVpQjtBQUVqQixtRUFLd0M7QUFFeEMsbURBRWdDO0FBRWhDLCtDQUErQztBQUMvQyxNQUFNLE1BQU0sR0FBRyxvQkFBVSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsa0NBQWtDLENBQUMsQ0FBQyxDQUFDO0FBRS9FLHFFQUE4RDtBQUU5RCwwREFBZ0U7QUFFaEUsUUFBUSxDQUFDLHVCQUF1QixFQUFFO0lBQ2hDLElBQUksU0FBUyxDQUFDO0lBQ2QsSUFBSSxjQUFjLENBQUM7SUFDbkIsSUFBSSxpQkFBaUIsQ0FBQztJQUN0QixJQUFJLFdBQVcsQ0FBQztJQUVoQixVQUFVLENBQUM7UUFFVCxjQUFjLEdBQUcsR0FBRyxFQUFFO1lBQ3BCLE1BQU0sT0FBTyxHQUFHO2dCQUNkLE1BQU0sRUFBRSxNQUFNO2dCQUNkLFVBQVUsRUFBRSxFQUFFO2dCQUNkLFNBQVMsRUFBRSxFQUFFO2dCQUNiLFNBQVMsRUFBRSxFQUFFO2FBQ2QsQ0FBQTtZQUNELFNBQVMsR0FBRyxJQUFJLHVCQUFhLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDekMsQ0FBQyxDQUFDO1FBRUYsaUJBQWlCLEdBQUcsQ0FBQyxNQUFNLEVBQUUsT0FBTyxHQUFHLEVBQUUsb0JBQW9CLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRTtZQUN4RSxNQUFNLFFBQVEsR0FBRyxlQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDL0IsSUFBSSxPQUFPLEdBQUcsNEJBQWlCLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQ2xELE9BQU8sQ0FBQyxvQkFBb0IsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxFQUFFLG9CQUFvQixFQUFFLElBQUksRUFBRSxlQUFlLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUM1RyxT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QTZCLENBQUMsU0FBUyxFQUFFLGtCQUFrQixDQUFDLENBQUM7WUFFN0QsTUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUM3QyxDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxzRUFBc0UsRUFBRTtZQUMzRSxNQUFNLFNBQVMsR0FBRyxJQUFJLHVCQUFhLEVBQUUsQ0FBQztZQUV0Qyw4Q0FBNkIsQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO1lBRXhFLE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsZUFBZSxFQUFFLENBQUM7UUFDN0MsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3RyaXBJbmRlbnQgfSBmcm9tICdjb21tb24tdGFncyc7XG5cbmltcG9ydCB7XG4gIHBhcnNlLFxuICBpc1R5cGUsXG4gIEdyYXBoUUxJRCxcbiAgR3JhcGhRTFN0cmluZyxcbiAgR3JhcGhRTEludCxcbiAgR3JhcGhRTExpc3QsXG4gIEdyYXBoUUxOb25OdWxsLFxuICBHcmFwaFFMSW5wdXRPYmplY3RUeXBlLFxuICBHcmFwaFFMRW51bVR5cGVcbn0gZnJvbSAnZ3JhcGhxbCc7XG5cbmltcG9ydCB7XG4gIGNsYXNzRGVjbGFyYXRpb25Gb3JPcGVyYXRpb24sXG4gIGNhc2VDbGFzc0RlY2xhcmF0aW9uRm9yRnJhZ21lbnQsXG4gIGNhc2VDbGFzc0RlY2xhcmF0aW9uRm9yU2VsZWN0aW9uU2V0LFxuICB0eXBlRGVjbGFyYXRpb25Gb3JHcmFwaFFMVHlwZSxcbn0gZnJvbSAnLi4vLi4vc3JjL3NjYWxhL2NvZGVHZW5lcmF0aW9uJztcblxuaW1wb3J0IHtcbiAgZGljdGlvbmFyeUxpdGVyYWxGb3JGaWVsZEFyZ3VtZW50cyxcbn0gZnJvbSAnLi4vLi4vc3JjL3NjYWxhL3ZhbHVlcyc7XG5cbmltcG9ydCB7IGxvYWRTY2hlbWEgfSBmcm9tICcuLi8uLi9zcmMvbG9hZGluZyc7XG5jb25zdCBzY2hlbWEgPSBsb2FkU2NoZW1hKHJlcXVpcmUucmVzb2x2ZSgnLi4vZml4dHVyZXMvc3RhcndhcnMvc2NoZW1hLmpzb24nKSk7XG5cbmltcG9ydCBDb2RlR2VuZXJhdG9yIGZyb20gJy4uLy4uL3NyYy91dGlsaXRpZXMvQ29kZUdlbmVyYXRvcic7XG5cbmltcG9ydCB7IGNvbXBpbGVUb0xlZ2FjeUlSIH0gZnJvbSAnLi4vLi4vc3JjL2NvbXBpbGVyL2xlZ2FjeUlSJztcblxuZGVzY3JpYmUoJ1NjYWxhIGNvZGUgZ2VuZXJhdGlvbicsIGZ1bmN0aW9uKCkge1xuICBsZXQgZ2VuZXJhdG9yO1xuICBsZXQgcmVzZXRHZW5lcmF0b3I7XG4gIGxldCBjb21waWxlRnJvbVNvdXJjZTtcbiAgbGV0IGFkZEZyYWdtZW50O1xuXG4gIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG5cbiAgICByZXNldEdlbmVyYXRvciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIHNjaGVtYTogc2NoZW1hLFxuICAgICAgICBvcGVyYXRpb25zOiB7fSxcbiAgICAgICAgZnJhZ21lbnRzOiB7fSxcbiAgICAgICAgdHlwZXNVc2VkOiB7fVxuICAgICAgfVxuICAgICAgZ2VuZXJhdG9yID0gbmV3IENvZGVHZW5lcmF0b3IoY29udGV4dCk7XG4gICAgfTtcblxuICAgIGNvbXBpbGVGcm9tU291cmNlID0gKHNvdXJjZSwgb3B0aW9ucyA9IHsgZ2VuZXJhdGVPcGVyYXRpb25JZHM6IGZhbHNlIH0pID0+IHtcbiAgICAgIGNvbnN0IGRvY3VtZW50ID0gcGFyc2Uoc291cmNlKTtcbiAgICAgIGxldCBjb250ZXh0ID0gY29tcGlsZVRvTGVnYWN5SVIoc2NoZW1hLCBkb2N1bWVudCk7XG4gICAgICBvcHRpb25zLmdlbmVyYXRlT3BlcmF0aW9uSWRzICYmIE9iamVjdC5hc3NpZ24oY29udGV4dCwgeyBnZW5lcmF0ZU9wZXJhdGlvbklkczogdHJ1ZSwgb3BlcmF0aW9uSWRzTWFwOiB7fSB9KTtcbiAgICAgIGdlbmVyYXRvci5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH07XG5cbiAgICBhZGRGcmFnbWVudCA9IChmcmFnbWVudCkgPT4ge1xuICAgICAgZ2VuZXJhdG9yLmNvbnRleHQuZnJhZ21lbnRzW2ZyYWdtZW50LmZyYWdtZW50TmFtZV0gPSBmcmFnbWVudDtcbiAgICB9O1xuXG4gICAgcmVzZXRHZW5lcmF0b3IoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJyNjbGFzc0RlY2xhcmF0aW9uRm9yT3BlcmF0aW9uKCknLCBmdW5jdGlvbigpIHtcbiAgICB0ZXN0KGBzaG91bGQgZ2VuZXJhdGUgYSBjbGFzcyBkZWNsYXJhdGlvbiBmb3IgYSBxdWVyeSB3aXRoIHZhcmlhYmxlc2AsIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgeyBvcGVyYXRpb25zLCBmcmFnbWVudHMgfSA9IGNvbXBpbGVGcm9tU291cmNlKGBcbiAgICAgICAgcXVlcnkgSGVyb05hbWUoJGVwaXNvZGU6IEVwaXNvZGUpIHtcbiAgICAgICAgICBoZXJvKGVwaXNvZGU6ICRlcGlzb2RlKSB7XG4gICAgICAgICAgICBuYW1lXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBgKTtcblxuICAgICAgY2xhc3NEZWNsYXJhdGlvbkZvck9wZXJhdGlvbihnZW5lcmF0b3IsIG9wZXJhdGlvbnNbJ0hlcm9OYW1lJ10sIE9iamVjdC52YWx1ZXMoZnJhZ21lbnRzKSk7XG4gICAgICBleHBlY3QoZ2VuZXJhdG9yLm91dHB1dCkudG9NYXRjaFNuYXBzaG90KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KGBzaG91bGQgZ2VuZXJhdGUgYSBjbGFzcyBkZWNsYXJhdGlvbiBmb3IgYSBxdWVyeSB3aXRoIGZyYWdtZW50IHNwcmVhZHNgLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IHsgb3BlcmF0aW9ucywgZnJhZ21lbnRzIH0gPSBjb21waWxlRnJvbVNvdXJjZShgXG4gICAgICAgIHF1ZXJ5IEhlcm8ge1xuICAgICAgICAgIGhlcm8ge1xuICAgICAgICAgICAgLi4uSGVyb0RldGFpbHNcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmcmFnbWVudCBIZXJvRGV0YWlscyBvbiBDaGFyYWN0ZXIge1xuICAgICAgICAgIG5hbWVcbiAgICAgICAgfVxuICAgICAgYCk7XG5cbiAgICAgIGNsYXNzRGVjbGFyYXRpb25Gb3JPcGVyYXRpb24oZ2VuZXJhdG9yLCBvcGVyYXRpb25zWydIZXJvJ10sIE9iamVjdC52YWx1ZXMoZnJhZ21lbnRzKSk7XG4gICAgICBleHBlY3QoZ2VuZXJhdG9yLm91dHB1dCkudG9NYXRjaFNuYXBzaG90KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KGBzaG91bGQgZ2VuZXJhdGUgYSBjbGFzcyBkZWNsYXJhdGlvbiBmb3IgYSBxdWVyeSB3aXRoIGNvbmRpdGlvbmFsIGZyYWdtZW50IHNwcmVhZHNgLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IHsgb3BlcmF0aW9ucywgZnJhZ21lbnRzIH0gPSBjb21waWxlRnJvbVNvdXJjZShgXG4gICAgICAgIHF1ZXJ5IEhlcm8ge1xuICAgICAgICAgIGhlcm8ge1xuICAgICAgICAgICAgLi4uRHJvaWREZXRhaWxzXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnJhZ21lbnQgRHJvaWREZXRhaWxzIG9uIERyb2lkIHtcbiAgICAgICAgICBwcmltYXJ5RnVuY3Rpb25cbiAgICAgICAgfVxuICAgICAgYCk7XG5cbiAgICAgIGNsYXNzRGVjbGFyYXRpb25Gb3JPcGVyYXRpb24oZ2VuZXJhdG9yLCBvcGVyYXRpb25zWydIZXJvJ10sIE9iamVjdC52YWx1ZXMoZnJhZ21lbnRzKSk7XG4gICAgICBleHBlY3QoZ2VuZXJhdG9yLm91dHB1dCkudG9NYXRjaFNuYXBzaG90KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KGBzaG91bGQgZ2VuZXJhdGUgYSBjbGFzcyBkZWNsYXJhdGlvbiBmb3IgYSBxdWVyeSB3aXRoIGEgZnJhZ21lbnQgc3ByZWFkIG5lc3RlZCBpbiBhbiBpbmxpbmUgZnJhZ21lbnRgLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IHsgb3BlcmF0aW9ucywgZnJhZ21lbnRzIH0gPSBjb21waWxlRnJvbVNvdXJjZShgXG4gICAgICAgIHF1ZXJ5IEhlcm8ge1xuICAgICAgICAgIGhlcm8ge1xuICAgICAgICAgICAgLi4uIG9uIERyb2lkIHtcbiAgICAgICAgICAgICAgLi4uSGVyb0RldGFpbHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmcmFnbWVudCBIZXJvRGV0YWlscyBvbiBDaGFyYWN0ZXIge1xuICAgICAgICAgIG5hbWVcbiAgICAgICAgfVxuICAgICAgYCk7XG5cbiAgICAgIGNsYXNzRGVjbGFyYXRpb25Gb3JPcGVyYXRpb24oZ2VuZXJhdG9yLCBvcGVyYXRpb25zWydIZXJvJ10sIE9iamVjdC52YWx1ZXMoZnJhZ21lbnRzKSk7XG5cbiAgICAgIGV4cGVjdChnZW5lcmF0b3Iub3V0cHV0KS50b01hdGNoU25hcHNob3QoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoYHNob3VsZCBnZW5lcmF0ZSBhIGNsYXNzIGRlY2xhcmF0aW9uIGZvciBhIG11dGF0aW9uIHdpdGggdmFyaWFibGVzYCwgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCB7IG9wZXJhdGlvbnMsIGZyYWdtZW50cyB9ID0gY29tcGlsZUZyb21Tb3VyY2UoYFxuICAgICAgICBtdXRhdGlvbiBDcmVhdGVSZXZpZXcoJGVwaXNvZGU6IEVwaXNvZGUpIHtcbiAgICAgICAgICBjcmVhdGVSZXZpZXcoZXBpc29kZTogJGVwaXNvZGUsIHJldmlldzogeyBzdGFyczogNSwgY29tbWVudGFyeTogXCJXb3chXCIgfSkge1xuICAgICAgICAgICAgc3RhcnNcbiAgICAgICAgICAgIGNvbW1lbnRhcnlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGApO1xuXG4gICAgICBjbGFzc0RlY2xhcmF0aW9uRm9yT3BlcmF0aW9uKGdlbmVyYXRvciwgb3BlcmF0aW9uc1snQ3JlYXRlUmV2aWV3J10sIE9iamVjdC52YWx1ZXMoZnJhZ21lbnRzKSk7XG5cbiAgICAgIGV4cGVjdChnZW5lcmF0b3Iub3V0cHV0KS50b01hdGNoU25hcHNob3QoKTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKGB3aGVuIGdlbmVyYXRlT3BlcmF0aW9uSWRzIGlzIHNwZWNpZmllZGAsIGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGNvbXBpbGVPcHRpb25zID0geyBnZW5lcmF0ZU9wZXJhdGlvbklkczogdHJ1ZSB9O1xuXG4gICAgICB0ZXN0KGBzaG91bGQgZ2VuZXJhdGUgYSBjbGFzcyBkZWNsYXJhdGlvbiB3aXRoIGFuIG9wZXJhdGlvbklkIHByb3BlcnR5YCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjb21waWxlRnJvbVNvdXJjZShgXG4gICAgICAgICAgcXVlcnkgSGVybyB7XG4gICAgICAgICAgICBoZXJvIHtcbiAgICAgICAgICAgICAgLi4uSGVyb0RldGFpbHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnJhZ21lbnQgSGVyb0RldGFpbHMgb24gQ2hhcmFjdGVyIHtcbiAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICB9XG4gICAgICAgIGAsIGNvbXBpbGVPcHRpb25zKTtcblxuICAgICAgICBjbGFzc0RlY2xhcmF0aW9uRm9yT3BlcmF0aW9uKGdlbmVyYXRvciwgY29udGV4dC5vcGVyYXRpb25zWydIZXJvJ10sIE9iamVjdC52YWx1ZXMoY29udGV4dC5mcmFnbWVudHMpKTtcbiAgICAgICAgZXhwZWN0KGdlbmVyYXRvci5vdXRwdXQpLnRvTWF0Y2hTbmFwc2hvdCgpO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoYHNob3VsZCBnZW5lcmF0ZSBkaWZmZXJlbnQgb3BlcmF0aW9uIGlkcyBmb3IgZGlmZmVyZW50IG9wZXJhdGlvbnNgLCBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgY29udGV4dDEgPSBjb21waWxlRnJvbVNvdXJjZShgXG4gICAgICAgICAgcXVlcnkgSGVybyB7XG4gICAgICAgICAgICBoZXJvIHtcbiAgICAgICAgICAgICAgLi4uSGVyb0RldGFpbHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnJhZ21lbnQgSGVyb0RldGFpbHMgb24gQ2hhcmFjdGVyIHtcbiAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICB9XG4gICAgICAgIGAsIGNvbXBpbGVPcHRpb25zKTtcblxuICAgICAgICBjbGFzc0RlY2xhcmF0aW9uRm9yT3BlcmF0aW9uKGdlbmVyYXRvciwgY29udGV4dDEub3BlcmF0aW9uc1snSGVybyddLCBPYmplY3QudmFsdWVzKGNvbnRleHQxLmZyYWdtZW50cykpO1xuICAgICAgICBjb25zdCBvdXRwdXQxID0gZ2VuZXJhdG9yLm91dHB1dDtcblxuICAgICAgICByZXNldEdlbmVyYXRvcigpO1xuICAgICAgICBjb25zdCBjb250ZXh0MiA9IGNvbXBpbGVGcm9tU291cmNlKGBcbiAgICAgICAgICBxdWVyeSBIZXJvIHtcbiAgICAgICAgICAgIGhlcm8ge1xuICAgICAgICAgICAgICAuLi5IZXJvRGV0YWlsc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmcmFnbWVudCBIZXJvRGV0YWlscyBvbiBDaGFyYWN0ZXIge1xuICAgICAgICAgICAgYXBwZWFyc0luXG4gICAgICAgICAgfVxuICAgICAgICBgLCBjb21waWxlT3B0aW9ucyk7XG5cbiAgICAgICAgY2xhc3NEZWNsYXJhdGlvbkZvck9wZXJhdGlvbihnZW5lcmF0b3IsIGNvbnRleHQyLm9wZXJhdGlvbnNbJ0hlcm8nXSwgT2JqZWN0LnZhbHVlcyhjb250ZXh0Mi5mcmFnbWVudHMpKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0MiA9IGdlbmVyYXRvci5vdXRwdXQ7XG5cbiAgICAgICAgZXhwZWN0KG91dHB1dDEpLm5vdC50b0JlKG91dHB1dDIpO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoYHNob3VsZCBnZW5lcmF0ZSB0aGUgc2FtZSBvcGVyYXRpb24gaWQgcmVnYXJkbGVzcyBvZiBvcGVyYXRpb24gZm9ybWF0dGluZy9jb21tZW50aW5nYCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQxID0gY29tcGlsZUZyb21Tb3VyY2UoYFxuICAgICAgICAgIHF1ZXJ5IEhlcm9OYW1lKCRlcGlzb2RlOiBFcGlzb2RlKSB7XG4gICAgICAgICAgICBoZXJvKGVwaXNvZGU6ICRlcGlzb2RlKSB7XG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGAsIGNvbXBpbGVPcHRpb25zKTtcblxuICAgICAgICBjbGFzc0RlY2xhcmF0aW9uRm9yT3BlcmF0aW9uKGdlbmVyYXRvciwgY29udGV4dDEub3BlcmF0aW9uc1snSGVyb05hbWUnXSwgT2JqZWN0LnZhbHVlcyhjb250ZXh0MS5mcmFnbWVudHMpKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0MSA9IGdlbmVyYXRvci5vdXRwdXQ7XG5cbiAgICAgICAgcmVzZXRHZW5lcmF0b3IoKTtcbiAgICAgICAgY29uc3QgY29udGV4dDIgPSBjb21waWxlRnJvbVNvdXJjZShgXG4gICAgICAgICAgIyBQcm9mb3VuZCBjb21tZW50XG4gICAgICAgICAgcXVlcnkgSGVyb05hbWUoJGVwaXNvZGU6RXBpc29kZSkgeyBoZXJvKGVwaXNvZGU6ICRlcGlzb2RlKSB7IG5hbWUgfSB9XG4gICAgICAgICAgIyBEZWVwbHkgbWVhbmluZ2Z1bCBjb21tZW50XG4gICAgICAgIGAsIGNvbXBpbGVPcHRpb25zKTtcblxuICAgICAgICBjbGFzc0RlY2xhcmF0aW9uRm9yT3BlcmF0aW9uKGdlbmVyYXRvciwgY29udGV4dDIub3BlcmF0aW9uc1snSGVyb05hbWUnXSwgT2JqZWN0LnZhbHVlcyhjb250ZXh0Mi5mcmFnbWVudHMpKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0MiA9IGdlbmVyYXRvci5vdXRwdXQ7XG5cbiAgICAgICAgZXhwZWN0KG91dHB1dDEpLnRvQmUob3V0cHV0Mik7XG4gICAgICB9KTtcblxuICAgICAgdGVzdChgc2hvdWxkIGdlbmVyYXRlIHRoZSBzYW1lIG9wZXJhdGlvbiBpZCByZWdhcmRsZXNzIG9mIGZyYWdtZW50IG9yZGVyYCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQxID0gY29tcGlsZUZyb21Tb3VyY2UoYFxuICAgICAgICAgIHF1ZXJ5IEhlcm8ge1xuICAgICAgICAgICAgaGVybyB7XG4gICAgICAgICAgICAgIC4uLkhlcm9OYW1lXG4gICAgICAgICAgICAgIC4uLkhlcm9BcHBlYXJzSW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnJhZ21lbnQgSGVyb05hbWUgb24gQ2hhcmFjdGVyIHtcbiAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICB9XG4gICAgICAgICAgZnJhZ21lbnQgSGVyb0FwcGVhcnNJbiBvbiBDaGFyYWN0ZXIge1xuICAgICAgICAgICAgYXBwZWFyc0luXG4gICAgICAgICAgfVxuICAgICAgICBgLCBjb21waWxlT3B0aW9ucyk7XG5cbiAgICAgICAgY2xhc3NEZWNsYXJhdGlvbkZvck9wZXJhdGlvbihnZW5lcmF0b3IsIGNvbnRleHQxLm9wZXJhdGlvbnNbJ0hlcm8nXSwgT2JqZWN0LnZhbHVlcyhjb250ZXh0MS5mcmFnbWVudHMpKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0MSA9IGdlbmVyYXRvci5vdXRwdXQ7XG5cbiAgICAgICAgcmVzZXRHZW5lcmF0b3IoKTtcbiAgICAgICAgY29uc3QgY29udGV4dDIgPSBjb21waWxlRnJvbVNvdXJjZShgXG4gICAgICAgICAgcXVlcnkgSGVybyB7XG4gICAgICAgICAgICBoZXJvIHtcbiAgICAgICAgICAgICAgLi4uSGVyb05hbWVcbiAgICAgICAgICAgICAgLi4uSGVyb0FwcGVhcnNJblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmcmFnbWVudCBIZXJvQXBwZWFyc0luIG9uIENoYXJhY3RlciB7XG4gICAgICAgICAgICBhcHBlYXJzSW5cbiAgICAgICAgICB9XG4gICAgICAgICAgZnJhZ21lbnQgSGVyb05hbWUgb24gQ2hhcmFjdGVyIHtcbiAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICB9XG4gICAgICAgIGAsIGNvbXBpbGVPcHRpb25zKTtcblxuICAgICAgICBjbGFzc0RlY2xhcmF0aW9uRm9yT3BlcmF0aW9uKGdlbmVyYXRvciwgY29udGV4dDIub3BlcmF0aW9uc1snSGVybyddLCBPYmplY3QudmFsdWVzKGNvbnRleHQyLmZyYWdtZW50cykpO1xuICAgICAgICBjb25zdCBvdXRwdXQyID0gZ2VuZXJhdG9yLm91dHB1dDtcblxuICAgICAgICBleHBlY3Qob3V0cHV0MSkudG9CZShvdXRwdXQyKTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0KGBzaG91bGQgZ2VuZXJhdGUgYXBwcm9wcmlhdGUgb3BlcmF0aW9uIGlkIG1hcHBpbmcgc291cmNlIHdoZW4gdGhlcmUgYXJlIG5lc3RlZCBmcmFnbWVudCByZWZlcmVuY2VzYCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICBxdWVyeSBIZXJvIHtcbiAgICAgICAgICAgIGhlcm8ge1xuICAgICAgICAgICAgICAuLi5IZXJvRGV0YWlsc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmcmFnbWVudCBIZXJvTmFtZSBvbiBDaGFyYWN0ZXIge1xuICAgICAgICAgICAgbmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgICBmcmFnbWVudCBIZXJvRGV0YWlscyBvbiBDaGFyYWN0ZXIge1xuICAgICAgICAgICAgLi4uSGVyb05hbWVcbiAgICAgICAgICAgIGFwcGVhcnNJblxuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNvbXBpbGVGcm9tU291cmNlKHNvdXJjZSwgdHJ1ZSk7XG4gICAgICAgIGV4cGVjdChjb250ZXh0Lm9wZXJhdGlvbnNbJ0hlcm8nXS5zb3VyY2VXaXRoRnJhZ21lbnRzKS50b01hdGNoU25hcHNob3QoKTtcbiAgICAgIH0pO1xuXG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCcjY2FzZUNsYXNzRGVjbGFyYXRpb25Gb3JGcmFnbWVudCgpJywgZnVuY3Rpb24oKSB7XG4gICAgdGVzdChgc2hvdWxkIGdlbmVyYXRlIGEgY2FzZUNsYXNzIGRlY2xhcmF0aW9uIGZvciBhIGZyYWdtZW50IHdpdGggYW4gYWJzdHJhY3QgdHlwZSBjb25kaXRpb25gLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IHsgZnJhZ21lbnRzIH0gPSBjb21waWxlRnJvbVNvdXJjZShgXG4gICAgICAgIGZyYWdtZW50IEhlcm9EZXRhaWxzIG9uIENoYXJhY3RlciB7XG4gICAgICAgICAgbmFtZVxuICAgICAgICAgIGFwcGVhcnNJblxuICAgICAgICB9XG4gICAgICBgKTtcblxuICAgICAgY2FzZUNsYXNzRGVjbGFyYXRpb25Gb3JGcmFnbWVudChnZW5lcmF0b3IsIGZyYWdtZW50c1snSGVyb0RldGFpbHMnXSk7XG5cbiAgICAgIGV4cGVjdChnZW5lcmF0b3Iub3V0cHV0KS50b01hdGNoU25hcHNob3QoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoYHNob3VsZCBnZW5lcmF0ZSBhIGNhc2VDbGFzcyBkZWNsYXJhdGlvbiBmb3IgYSBmcmFnbWVudCB3aXRoIGEgY29uY3JldGUgdHlwZSBjb25kaXRpb25gLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IHsgZnJhZ21lbnRzIH0gPSBjb21waWxlRnJvbVNvdXJjZShgXG4gICAgICAgIGZyYWdtZW50IERyb2lkRGV0YWlscyBvbiBEcm9pZCB7XG4gICAgICAgICAgbmFtZVxuICAgICAgICAgIHByaW1hcnlGdW5jdGlvblxuICAgICAgICB9XG4gICAgICBgKTtcblxuICAgICAgY2FzZUNsYXNzRGVjbGFyYXRpb25Gb3JGcmFnbWVudChnZW5lcmF0b3IsIGZyYWdtZW50c1snRHJvaWREZXRhaWxzJ10pO1xuXG4gICAgICBleHBlY3QoZ2VuZXJhdG9yLm91dHB1dCkudG9NYXRjaFNuYXBzaG90KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KGBzaG91bGQgZ2VuZXJhdGUgYSBjYXNlQ2xhc3MgZGVjbGFyYXRpb24gZm9yIGEgZnJhZ21lbnQgd2l0aCBhIHN1YnNlbGVjdGlvbmAsIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgeyBmcmFnbWVudHMgfSA9IGNvbXBpbGVGcm9tU291cmNlKGBcbiAgICAgICAgZnJhZ21lbnQgSGVyb0RldGFpbHMgb24gQ2hhcmFjdGVyIHtcbiAgICAgICAgICBuYW1lXG4gICAgICAgICAgZnJpZW5kcyB7XG4gICAgICAgICAgICBuYW1lXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBgKTtcblxuICAgICAgY2FzZUNsYXNzRGVjbGFyYXRpb25Gb3JGcmFnbWVudChnZW5lcmF0b3IsIGZyYWdtZW50c1snSGVyb0RldGFpbHMnXSk7XG5cbiAgICAgIGV4cGVjdChnZW5lcmF0b3Iub3V0cHV0KS50b01hdGNoU25hcHNob3QoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoYHNob3VsZCBnZW5lcmF0ZSBhIGNhc2VDbGFzcyBkZWNsYXJhdGlvbiBmb3IgYSBmcmFnbWVudCB0aGF0IGluY2x1ZGVzIGEgZnJhZ21lbnQgc3ByZWFkYCwgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCB7IGZyYWdtZW50cyB9ID0gY29tcGlsZUZyb21Tb3VyY2UoYFxuICAgICAgICBmcmFnbWVudCBIZXJvRGV0YWlscyBvbiBDaGFyYWN0ZXIge1xuICAgICAgICAgIG5hbWVcbiAgICAgICAgICAuLi5Nb3JlSGVyb0RldGFpbHNcbiAgICAgICAgfVxuXG4gICAgICAgIGZyYWdtZW50IE1vcmVIZXJvRGV0YWlscyBvbiBDaGFyYWN0ZXIge1xuICAgICAgICAgIGFwcGVhcnNJblxuICAgICAgICB9XG4gICAgICBgKTtcblxuICAgICAgY2FzZUNsYXNzRGVjbGFyYXRpb25Gb3JGcmFnbWVudChnZW5lcmF0b3IsIGZyYWdtZW50c1snSGVyb0RldGFpbHMnXSk7XG5cbiAgICAgIGV4cGVjdChnZW5lcmF0b3Iub3V0cHV0KS50b01hdGNoU25hcHNob3QoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJyNjYXNlQ2xhc3NEZWNsYXJhdGlvbkZvclNlbGVjdGlvblNldCgpJywgZnVuY3Rpb24oKSB7XG4gICAgdGVzdChgc2hvdWxkIGdlbmVyYXRlIGEgY2FzZUNsYXNzIGRlY2xhcmF0aW9uIGZvciBhIHNlbGVjdGlvbiBzZXRgLCBmdW5jdGlvbigpIHtcbiAgICAgIGNhc2VDbGFzc0RlY2xhcmF0aW9uRm9yU2VsZWN0aW9uU2V0KGdlbmVyYXRvciwge1xuICAgICAgICBjYXNlQ2xhc3NOYW1lOiAnSGVybycsXG4gICAgICAgIHBhcmVudFR5cGU6IHNjaGVtYS5nZXRUeXBlKCdDaGFyYWN0ZXInKSxcbiAgICAgICAgZmllbGRzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmVzcG9uc2VOYW1lOiAnbmFtZScsXG4gICAgICAgICAgICBmaWVsZE5hbWU6ICduYW1lJyxcbiAgICAgICAgICAgIHR5cGU6IEdyYXBoUUxTdHJpbmdcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoZ2VuZXJhdG9yLm91dHB1dCkudG9NYXRjaFNuYXBzaG90KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KGBzaG91bGQgZXNjYXBlIHJlc2VydmVkIGtleXdvcmRzIGluIGEgY2FzZUNsYXNzIGRlY2xhcmF0aW9uIGZvciBhIHNlbGVjdGlvbiBzZXRgLCBmdW5jdGlvbigpIHtcbiAgICAgIGNhc2VDbGFzc0RlY2xhcmF0aW9uRm9yU2VsZWN0aW9uU2V0KGdlbmVyYXRvciwge1xuICAgICAgICBjYXNlQ2xhc3NOYW1lOiAnSGVybycsXG4gICAgICAgIHBhcmVudFR5cGU6IHNjaGVtYS5nZXRUeXBlKCdDaGFyYWN0ZXInKSxcbiAgICAgICAgZmllbGRzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmVzcG9uc2VOYW1lOiAncHJpdmF0ZScsXG4gICAgICAgICAgICBmaWVsZE5hbWU6ICduYW1lJyxcbiAgICAgICAgICAgIHR5cGU6IEdyYXBoUUxTdHJpbmdcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoZ2VuZXJhdG9yLm91dHB1dCkudG9NYXRjaFNuYXBzaG90KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KGBzaG91bGQgZ2VuZXJhdGUgYSBuZXN0ZWQgY2FzZUNsYXNzIGRlY2xhcmF0aW9uIGZvciBhIHNlbGVjdGlvbiBzZXQgd2l0aCBzdWJzZWxlY3Rpb25zYCwgZnVuY3Rpb24oKSB7XG4gICAgICBjYXNlQ2xhc3NEZWNsYXJhdGlvbkZvclNlbGVjdGlvblNldChnZW5lcmF0b3IsIHtcbiAgICAgICAgY2FzZUNsYXNzTmFtZTogJ0hlcm8nLFxuICAgICAgICBwYXJlbnRUeXBlOiBzY2hlbWEuZ2V0VHlwZSgnQ2hhcmFjdGVyJyksXG4gICAgICAgIGZpZWxkczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJlc3BvbnNlTmFtZTogJ2ZyaWVuZHMnLFxuICAgICAgICAgICAgZmllbGROYW1lOiAnZnJpZW5kcycsXG4gICAgICAgICAgICB0eXBlOiBuZXcgR3JhcGhRTExpc3Qoc2NoZW1hLmdldFR5cGUoJ0NoYXJhY3RlcicpKSxcbiAgICAgICAgICAgIGZpZWxkczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VOYW1lOiAnbmFtZScsXG4gICAgICAgICAgICAgICAgZmllbGROYW1lOiAnbmFtZScsXG4gICAgICAgICAgICAgICAgdHlwZTogR3JhcGhRTFN0cmluZ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KGdlbmVyYXRvci5vdXRwdXQpLnRvTWF0Y2hTbmFwc2hvdCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChgc2hvdWxkIGdlbmVyYXRlIGEgY2FzZUNsYXNzIGRlY2xhcmF0aW9uIGZvciBhIHNlbGVjdGlvbiBzZXQgd2l0aCBhIGZyYWdtZW50IHNwcmVhZCB0aGF0IG1hdGNoZXMgdGhlIHBhcmVudCB0eXBlYCwgZnVuY3Rpb24oKSB7XG4gICAgICBhZGRGcmFnbWVudCh7XG4gICAgICAgIGZyYWdtZW50TmFtZTogJ0hlcm9EZXRhaWxzJyxcbiAgICAgICAgdHlwZUNvbmRpdGlvbjogc2NoZW1hLmdldFR5cGUoJ0NoYXJhY3RlcicpXG4gICAgICB9KTtcblxuICAgICAgY2FzZUNsYXNzRGVjbGFyYXRpb25Gb3JTZWxlY3Rpb25TZXQoZ2VuZXJhdG9yLCB7XG4gICAgICAgIGNhc2VDbGFzc05hbWU6ICdIZXJvJyxcbiAgICAgICAgcGFyZW50VHlwZTogc2NoZW1hLmdldFR5cGUoJ0NoYXJhY3RlcicpLFxuICAgICAgICBmcmFnbWVudFNwcmVhZHM6IFsnSGVyb0RldGFpbHMnXSxcbiAgICAgICAgZmllbGRzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmVzcG9uc2VOYW1lOiAnbmFtZScsXG4gICAgICAgICAgICBmaWVsZE5hbWU6ICduYW1lJyxcbiAgICAgICAgICAgIHR5cGU6IEdyYXBoUUxTdHJpbmdcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoZ2VuZXJhdG9yLm91dHB1dCkudG9NYXRjaFNuYXBzaG90KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KGBzaG91bGQgZ2VuZXJhdGUgYSBjYXNlQ2xhc3MgZGVjbGFyYXRpb24gZm9yIGEgc2VsZWN0aW9uIHNldCB3aXRoIGEgZnJhZ21lbnQgc3ByZWFkIHdpdGggYSBtb3JlIHNwZWNpZmljIHR5cGUgY29uZGl0aW9uYCwgZnVuY3Rpb24oKSB7XG4gICAgICBhZGRGcmFnbWVudCh7XG4gICAgICAgIGZyYWdtZW50TmFtZTogJ0Ryb2lkRGV0YWlscycsXG4gICAgICAgIHR5cGVDb25kaXRpb246IHNjaGVtYS5nZXRUeXBlKCdEcm9pZCcpXG4gICAgICB9KTtcblxuICAgICAgY2FzZUNsYXNzRGVjbGFyYXRpb25Gb3JTZWxlY3Rpb25TZXQoZ2VuZXJhdG9yLCB7XG4gICAgICAgIGNhc2VDbGFzc05hbWU6ICdIZXJvJyxcbiAgICAgICAgcGFyZW50VHlwZTogc2NoZW1hLmdldFR5cGUoJ0NoYXJhY3RlcicpLFxuICAgICAgICBmcmFnbWVudFNwcmVhZHM6IFsnRHJvaWREZXRhaWxzJ10sXG4gICAgICAgIGZpZWxkczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJlc3BvbnNlTmFtZTogJ25hbWUnLFxuICAgICAgICAgICAgZmllbGROYW1lOiAnbmFtZScsXG4gICAgICAgICAgICB0eXBlOiBHcmFwaFFMU3RyaW5nXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KGdlbmVyYXRvci5vdXRwdXQpLnRvTWF0Y2hTbmFwc2hvdCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChgc2hvdWxkIGdlbmVyYXRlIGEgY2FzZUNsYXNzIGRlY2xhcmF0aW9uIGZvciBhIHNlbGVjdGlvbiBzZXQgd2l0aCBhbiBpbmxpbmUgZnJhZ21lbnRgLCBmdW5jdGlvbigpIHtcbiAgICAgIGNhc2VDbGFzc0RlY2xhcmF0aW9uRm9yU2VsZWN0aW9uU2V0KGdlbmVyYXRvciwge1xuICAgICAgICBjYXNlQ2xhc3NOYW1lOiAnSGVybycsXG4gICAgICAgIHBhcmVudFR5cGU6IHNjaGVtYS5nZXRUeXBlKCdDaGFyYWN0ZXInKSxcbiAgICAgICAgZmllbGRzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmVzcG9uc2VOYW1lOiAnbmFtZScsXG4gICAgICAgICAgICBmaWVsZE5hbWU6ICduYW1lJyxcbiAgICAgICAgICAgIHR5cGU6IG5ldyBHcmFwaFFMTm9uTnVsbChHcmFwaFFMU3RyaW5nKVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgaW5saW5lRnJhZ21lbnRzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZUNvbmRpdGlvbjogc2NoZW1hLmdldFR5cGUoJ0Ryb2lkJyksXG4gICAgICAgICAgICBwb3NzaWJsZVR5cGVzOiBbJ0Ryb2lkJ10sXG4gICAgICAgICAgICBmaWVsZHM6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlTmFtZTogJ25hbWUnLFxuICAgICAgICAgICAgICAgIGZpZWxkTmFtZTogJ25hbWUnLFxuICAgICAgICAgICAgICAgIHR5cGU6IG5ldyBHcmFwaFFMTm9uTnVsbChHcmFwaFFMU3RyaW5nKVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VOYW1lOiAncHJpbWFyeUZ1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICBmaWVsZE5hbWU6ICdwcmltYXJ5RnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgIHR5cGU6IEdyYXBoUUxTdHJpbmdcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChnZW5lcmF0b3Iub3V0cHV0KS50b01hdGNoU25hcHNob3QoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoYHNob3VsZCBnZW5lcmF0ZSBhIGNhc2VDbGFzcyBkZWNsYXJhdGlvbiBmb3IgYSBmcmFnbWVudCBzcHJlYWQgbmVzdGVkIGluIGFuIGlubGluZSBmcmFnbWVudGAsIGZ1bmN0aW9uKCkge1xuICAgICAgYWRkRnJhZ21lbnQoe1xuICAgICAgICBmcmFnbWVudE5hbWU6ICdIZXJvRGV0YWlscycsXG4gICAgICAgIHR5cGVDb25kaXRpb246IHNjaGVtYS5nZXRUeXBlKCdDaGFyYWN0ZXInKVxuICAgICAgfSk7XG5cbiAgICAgIGNhc2VDbGFzc0RlY2xhcmF0aW9uRm9yU2VsZWN0aW9uU2V0KGdlbmVyYXRvciwge1xuICAgICAgICBjYXNlQ2xhc3NOYW1lOiAnSGVybycsXG4gICAgICAgIHBhcmVudFR5cGU6IHNjaGVtYS5nZXRUeXBlKCdDaGFyYWN0ZXInKSxcbiAgICAgICAgZmllbGRzOiBbXSxcbiAgICAgICAgaW5saW5lRnJhZ21lbnRzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZUNvbmRpdGlvbjogc2NoZW1hLmdldFR5cGUoJ0Ryb2lkJyksXG4gICAgICAgICAgICBwb3NzaWJsZVR5cGVzOiBbJ0Ryb2lkJ10sXG4gICAgICAgICAgICBmaWVsZHM6IFtdLFxuICAgICAgICAgICAgZnJhZ21lbnRTcHJlYWRzOiBbJ0hlcm9EZXRhaWxzJ10sXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KGdlbmVyYXRvci5vdXRwdXQpLnRvTWF0Y2hTbmFwc2hvdCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnI2RpY3Rpb25hcnlMaXRlcmFsRm9yRmllbGRBcmd1bWVudHMoKScsIGZ1bmN0aW9uKCkge1xuICAgIHRlc3QoJ3Nob3VsZCBpbmNsdWRlIGV4cHJlc3Npb25zIGZvciBpbnB1dCBvYmplY3RzIHdpdGggdmFyaWFibGVzJywgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCB7IG9wZXJhdGlvbnMgfSA9IGNvbXBpbGVGcm9tU291cmNlKGBcbiAgICAgICAgbXV0YXRpb24gRmllbGRBcmd1bWVudHNXaXRoSW5wdXRPYmplY3RzKCRjb21tZW50YXJ5OiBTdHJpbmchLCAkcmVkOiBJbnQhKSB7XG4gICAgICAgICAgY3JlYXRlUmV2aWV3KGVwaXNvZGU6IEpFREksIHJldmlldzogeyBzdGFyczogMiwgY29tbWVudGFyeTogJGNvbW1lbnRhcnksIGZhdm9yaXRlX2NvbG9yOiB7IHJlZDogJHJlZCwgYmx1ZTogMTAwLCBncmVlbjogNTAgfSB9KSB7XG4gICAgICAgICAgICBjb21tZW50YXJ5XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBgKTtcblxuICAgICAgY29uc3QgZmllbGRBcmd1bWVudHMgPSBvcGVyYXRpb25zWydGaWVsZEFyZ3VtZW50c1dpdGhJbnB1dE9iamVjdHMnXS5maWVsZHNbMF0uYXJncztcbiAgICAgIGNvbnN0IGRpY3Rpb25hcnlMaXRlcmFsID0gZGljdGlvbmFyeUxpdGVyYWxGb3JGaWVsZEFyZ3VtZW50cyhmaWVsZEFyZ3VtZW50cyk7XG5cbiAgICAgIGV4cGVjdChkaWN0aW9uYXJ5TGl0ZXJhbCkudG9CZSgnW1wiZXBpc29kZVwiOiBcIkpFRElcIiwgXCJyZXZpZXdcIjogW1wic3RhcnNcIjogMiwgXCJjb21tZW50YXJ5XCI6IFZhcmlhYmxlKFwiY29tbWVudGFyeVwiKSwgXCJmYXZvcml0ZV9jb2xvclwiOiBbXCJyZWRcIjogVmFyaWFibGUoXCJyZWRcIiksIFwiYmx1ZVwiOiAxMDAsIFwiZ3JlZW5cIjogNTBdXV0nKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJyN0eXBlRGVjbGFyYXRpb25Gb3JHcmFwaFFMVHlwZSgpJywgZnVuY3Rpb24oKSB7XG4gICAgdGVzdCgnc2hvdWxkIGdlbmVyYXRlIGFuIGVudW0gZGVjbGFyYXRpb24gZm9yIGEgR3JhcGhRTEVudW1UeXBlJywgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBnZW5lcmF0b3IgPSBuZXcgQ29kZUdlbmVyYXRvcigpO1xuXG4gICAgICB0eXBlRGVjbGFyYXRpb25Gb3JHcmFwaFFMVHlwZShnZW5lcmF0b3IsIHNjaGVtYS5nZXRUeXBlKCdFcGlzb2RlJykpO1xuXG4gICAgICBleHBlY3QoZ2VuZXJhdG9yLm91dHB1dCkudG9NYXRjaFNuYXBzaG90KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgZXNjYXBlIGlkZW50aWZpZXJzIGluIGNhc2VzIG9mIGVudW0gZGVjbGFyYXRpb24gZm9yIGEgR3JhcGhRTEVudW1UeXBlJywgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBnZW5lcmF0b3IgPSBuZXcgQ29kZUdlbmVyYXRvcigpO1xuXG4gICAgICBjb25zdCBhbGJ1bVByaXZhY2llc0VudW0gPSBuZXcgR3JhcGhRTEVudW1UeXBlKHtcbiAgICAgICAgbmFtZTogJ0FsYnVtUHJpdmFjaWVzJyxcbiAgICAgICAgdmFsdWVzOiB7IFBVQkxJQzogeyB2YWx1ZTogXCJQVUJMSUNcIiB9LCBQUklWQVRFOiB7IHZhbHVlOiBcIlBSSVZBVEVcIiB9IH1cbiAgICAgIH0pO1xuXG4gICAgICB0eXBlRGVjbGFyYXRpb25Gb3JHcmFwaFFMVHlwZShnZW5lcmF0b3IsIGFsYnVtUHJpdmFjaWVzRW51bSk7XG5cbiAgICAgIGV4cGVjdChnZW5lcmF0b3Iub3V0cHV0KS50b01hdGNoU25hcHNob3QoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBnZW5lcmF0ZSBhIGNhc2VDbGFzcyBkZWNsYXJhdGlvbiBmb3IgYSBHcmFwaFFMSW5wdXRPYmplY3RUeXBlJywgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBnZW5lcmF0b3IgPSBuZXcgQ29kZUdlbmVyYXRvcigpO1xuXG4gICAgICB0eXBlRGVjbGFyYXRpb25Gb3JHcmFwaFFMVHlwZShnZW5lcmF0b3IsIHNjaGVtYS5nZXRUeXBlKCdSZXZpZXdJbnB1dCcpKTtcblxuICAgICAgZXhwZWN0KGdlbmVyYXRvci5vdXRwdXQpLnRvTWF0Y2hTbmFwc2hvdCgpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl19");"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const codeGeneration_1 = require("../../src/scala/codeGeneration");
const values_1 = require("../../src/scala/values");
const loading_1 = require("../../src/loading");
const schema = loading_1.loadSchema(require.resolve('../fixtures/starwars/schema.json'));
const CodeGenerator_1 = require("../../src/utilities/CodeGenerator");
const legacyIR_1 = require("../../src/compiler/legacyIR");
describe('Scala code generation', function () {
    let generator;
    let resetGenerator;
    let compileFromSource;
    let addFragment;
    beforeEach(function () {
        resetGenerator = () => {
            const context = {
                schema: schema,
                operations: {},
                fragments: {},
                typesUsed: {} };

            generator = new CodeGenerator_1.default(context);
        };
        compileFromSource = (source, options = { generateOperationIds: false }) => {
            const document = graphql_1.parse(source);
            let context = legacyIR_1.compileToLegacyIR(schema, document);
            options.generateOperationIds && Object.assign(context, { generateOperationIds: true, operationIdsMap: {} });
            generator.context = context;
            return context;
        };
        addFragment = fragment => {
            generator.context.fragments[fragment.fragmentName] = fragment;
        };
        resetGenerator();
    });
    describe('#classDeclarationForOperation()', function () {
        test(`should generate a class declaration for a query with variables`, function () {
            const { operations, fragments } = compileFromSource(`
        query HeroName($episode: Episode) {
          hero(episode: $episode) {
            name
          }
        }
      `);
            codeGeneration_1.classDeclarationForOperation(generator, operations['HeroName'], Object.values(fragments));
            expect(generator.output).toMatchSnapshot();
        });
        test(`should generate a class declaration for a query with fragment spreads`, function () {
            const { operations, fragments } = compileFromSource(`
        query Hero {
          hero {
            ...HeroDetails
          }
        }

        fragment HeroDetails on Character {
          name
        }
      `);
            codeGeneration_1.classDeclarationForOperation(generator, operations['Hero'], Object.values(fragments));
            expect(generator.output).toMatchSnapshot();
        });
        test(`should generate a class declaration for a query with conditional fragment spreads`, function () {
            const { operations, fragments } = compileFromSource(`
        query Hero {
          hero {
            ...DroidDetails
          }
        }

        fragment DroidDetails on Droid {
          primaryFunction
        }
      `);
            codeGeneration_1.classDeclarationForOperation(generator, operations['Hero'], Object.values(fragments));
            expect(generator.output).toMatchSnapshot();
        });
        test(`should generate a class declaration for a query with a fragment spread nested in an inline fragment`, function () {
            const { operations, fragments } = compileFromSource(`
        query Hero {
          hero {
            ... on Droid {
              ...HeroDetails
            }
          }
        }

        fragment HeroDetails on Character {
          name
        }
      `);
            codeGeneration_1.classDeclarationForOperation(generator, operations['Hero'], Object.values(fragments));
            expect(generator.output).toMatchSnapshot();
        });
        test(`should generate a class declaration for a mutation with variables`, function () {
            const { operations, fragments } = compileFromSource(`
        mutation CreateReview($episode: Episode) {
          createReview(episode: $episode, review: { stars: 5, commentary: "Wow!" }) {
            stars
            commentary
          }
        }
      `);
            codeGeneration_1.classDeclarationForOperation(generator, operations['CreateReview'], Object.values(fragments));
            expect(generator.output).toMatchSnapshot();
        });
        describe(`when generateOperationIds is specified`, function () {
            let compileOptions = { generateOperationIds: true };
            test(`should generate a class declaration with an operationId property`, function () {
                const context = compileFromSource(`
          query Hero {
            hero {
              ...HeroDetails
            }
          }
          fragment HeroDetails on Character {
            name
          }
        `, compileOptions);
                codeGeneration_1.classDeclarationForOperation(generator, context.operations['Hero'], Object.values(context.fragments));
                expect(generator.output).toMatchSnapshot();
            });
            test(`should generate different operation ids for different operations`, function () {
                const context1 = compileFromSource(`
          query Hero {
            hero {
              ...HeroDetails
            }
          }
          fragment HeroDetails on Character {
            name
          }
        `, compileOptions);
                codeGeneration_1.classDeclarationForOperation(generator, context1.operations['Hero'], Object.values(context1.fragments));
                const output1 = generator.output;
                resetGenerator();
                const context2 = compileFromSource(`
          query Hero {
            hero {
              ...HeroDetails
            }
          }
          fragment HeroDetails on Character {
            appearsIn
          }
        `, compileOptions);
                codeGeneration_1.classDeclarationForOperation(generator, context2.operations['Hero'], Object.values(context2.fragments));
                const output2 = generator.output;
                expect(output1).not.toBe(output2);
            });
            test(`should generate the same operation id regardless of operation formatting/commenting`, function () {
                const context1 = compileFromSource(`
          query HeroName($episode: Episode) {
            hero(episode: $episode) {
              name
            }
          }
        `, compileOptions);
                codeGeneration_1.classDeclarationForOperation(generator, context1.operations['HeroName'], Object.values(context1.fragments));
                const output1 = generator.output;
                resetGenerator();
                const context2 = compileFromSource(`
          # Profound comment
          query HeroName($episode:Episode) { hero(episode: $episode) { name } }
          # Deeply meaningful comment
        `, compileOptions);
                codeGeneration_1.classDeclarationForOperation(generator, context2.operations['HeroName'], Object.values(context2.fragments));
                const output2 = generator.output;
                expect(output1).toBe(output2);
            });
            test(`should generate the same operation id regardless of fragment order`, function () {
                const context1 = compileFromSource(`
          query Hero {
            hero {
              ...HeroName
              ...HeroAppearsIn
            }
          }
          fragment HeroName on Character {
            name
          }
          fragment HeroAppearsIn on Character {
            appearsIn
          }
        `, compileOptions);
                codeGeneration_1.classDeclarationForOperation(generator, context1.operations['Hero'], Object.values(context1.fragments));
                const output1 = generator.output;
                resetGenerator();
                const context2 = compileFromSource(`
          query Hero {
            hero {
              ...HeroName
              ...HeroAppearsIn
            }
          }
          fragment HeroAppearsIn on Character {
            appearsIn
          }
          fragment HeroName on Character {
            name
          }
        `, compileOptions);
                codeGeneration_1.classDeclarationForOperation(generator, context2.operations['Hero'], Object.values(context2.fragments));
                const output2 = generator.output;
                expect(output1).toBe(output2);
            });
            test(`should generate appropriate operation id mapping source when there are nested fragment references`, function () {
                const source = `
          query Hero {
            hero {
              ...HeroDetails
            }
          }
          fragment HeroName on Character {
            name
          }
          fragment HeroDetails on Character {
            ...HeroName
            appearsIn
          }
        `;
                const context = compileFromSource(source, true);
                expect(context.operations['Hero'].sourceWithFragments).toMatchSnapshot();
            });
        });
    });
    describe('#caseClassDeclarationForFragment()', function () {
        test(`should generate a caseClass declaration for a fragment with an abstract type condition`, function () {
            const { fragments } = compileFromSource(`
        fragment HeroDetails on Character {
          name
          appearsIn
        }
      `);
            codeGeneration_1.caseClassDeclarationForFragment(generator, fragments['HeroDetails']);
            expect(generator.output).toMatchSnapshot();
        });
        test(`should generate a caseClass declaration for a fragment with a concrete type condition`, function () {
            const { fragments } = compileFromSource(`
        fragment DroidDetails on Droid {
          name
          primaryFunction
        }
      `);
            codeGeneration_1.caseClassDeclarationForFragment(generator, fragments['DroidDetails']);
            expect(generator.output).toMatchSnapshot();
        });
        test(`should generate a caseClass declaration for a fragment with a subselection`, function () {
            const { fragments } = compileFromSource(`
        fragment HeroDetails on Character {
          name
          friends {
            name
          }
        }
      `);
            codeGeneration_1.caseClassDeclarationForFragment(generator, fragments['HeroDetails']);
            expect(generator.output).toMatchSnapshot();
        });
        test(`should generate a caseClass declaration for a fragment that includes a fragment spread`, function () {
            const { fragments } = compileFromSource(`
        fragment HeroDetails on Character {
          name
          ...MoreHeroDetails
        }

        fragment MoreHeroDetails on Character {
          appearsIn
        }
      `);
            codeGeneration_1.caseClassDeclarationForFragment(generator, fragments['HeroDetails']);
            expect(generator.output).toMatchSnapshot();
        });
    });
    describe('#caseClassDeclarationForSelectionSet()', function () {
        test(`should generate a caseClass declaration for a selection set`, function () {
            codeGeneration_1.caseClassDeclarationForSelectionSet(generator, {
                caseClassName: 'Hero',
                parentType: schema.getType('Character'),
                fields: [
                {
                    responseName: 'name',
                    fieldName: 'name',
                    type: graphql_1.GraphQLString }] });



            expect(generator.output).toMatchSnapshot();
        });
        test(`should escape reserved keywords in a caseClass declaration for a selection set`, function () {
            codeGeneration_1.caseClassDeclarationForSelectionSet(generator, {
                caseClassName: 'Hero',
                parentType: schema.getType('Character'),
                fields: [
                {
                    responseName: 'private',
                    fieldName: 'name',
                    type: graphql_1.GraphQLString }] });



            expect(generator.output).toMatchSnapshot();
        });
        test(`should generate a nested caseClass declaration for a selection set with subselections`, function () {
            codeGeneration_1.caseClassDeclarationForSelectionSet(generator, {
                caseClassName: 'Hero',
                parentType: schema.getType('Character'),
                fields: [
                {
                    responseName: 'friends',
                    fieldName: 'friends',
                    type: new graphql_1.GraphQLList(schema.getType('Character')),
                    fields: [
                    {
                        responseName: 'name',
                        fieldName: 'name',
                        type: graphql_1.GraphQLString }] }] });





            expect(generator.output).toMatchSnapshot();
        });
        test(`should generate a caseClass declaration for a selection set with a fragment spread that matches the parent type`, function () {
            addFragment({
                fragmentName: 'HeroDetails',
                typeCondition: schema.getType('Character') });

            codeGeneration_1.caseClassDeclarationForSelectionSet(generator, {
                caseClassName: 'Hero',
                parentType: schema.getType('Character'),
                fragmentSpreads: ['HeroDetails'],
                fields: [
                {
                    responseName: 'name',
                    fieldName: 'name',
                    type: graphql_1.GraphQLString }] });



            expect(generator.output).toMatchSnapshot();
        });
        test(`should generate a caseClass declaration for a selection set with a fragment spread with a more specific type condition`, function () {
            addFragment({
                fragmentName: 'DroidDetails',
                typeCondition: schema.getType('Droid') });

            codeGeneration_1.caseClassDeclarationForSelectionSet(generator, {
                caseClassName: 'Hero',
                parentType: schema.getType('Character'),
                fragmentSpreads: ['DroidDetails'],
                fields: [
                {
                    responseName: 'name',
                    fieldName: 'name',
                    type: graphql_1.GraphQLString }] });



            expect(generator.output).toMatchSnapshot();
        });
        test(`should generate a caseClass declaration for a selection set with an inline fragment`, function () {
            codeGeneration_1.caseClassDeclarationForSelectionSet(generator, {
                caseClassName: 'Hero',
                parentType: schema.getType('Character'),
                fields: [
                {
                    responseName: 'name',
                    fieldName: 'name',
                    type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLString) }],


                inlineFragments: [
                {
                    typeCondition: schema.getType('Droid'),
                    possibleTypes: ['Droid'],
                    fields: [
                    {
                        responseName: 'name',
                        fieldName: 'name',
                        type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLString) },

                    {
                        responseName: 'primaryFunction',
                        fieldName: 'primaryFunction',
                        type: graphql_1.GraphQLString }] }] });





            expect(generator.output).toMatchSnapshot();
        });
        test(`should generate a caseClass declaration for a fragment spread nested in an inline fragment`, function () {
            addFragment({
                fragmentName: 'HeroDetails',
                typeCondition: schema.getType('Character') });

            codeGeneration_1.caseClassDeclarationForSelectionSet(generator, {
                caseClassName: 'Hero',
                parentType: schema.getType('Character'),
                fields: [],
                inlineFragments: [
                {
                    typeCondition: schema.getType('Droid'),
                    possibleTypes: ['Droid'],
                    fields: [],
                    fragmentSpreads: ['HeroDetails'] }] });



            expect(generator.output).toMatchSnapshot();
        });
    });
    describe('#dictionaryLiteralForFieldArguments()', function () {
        test('should include expressions for input objects with variables', function () {
            const { operations } = compileFromSource(`
        mutation FieldArgumentsWithInputObjects($commentary: String!, $red: Int!) {
          createReview(episode: JEDI, review: { stars: 2, commentary: $commentary, favorite_color: { red: $red, blue: 100, green: 50 } }) {
            commentary
          }
        }
      `);
            const fieldArguments = operations['FieldArgumentsWithInputObjects'].fields[0].args;
            const dictionaryLiteral = values_1.dictionaryLiteralForFieldArguments(fieldArguments);
            expect(dictionaryLiteral).toBe('["episode": "JEDI", "review": ["stars": 2, "commentary": Variable("commentary"), "favorite_color": ["red": Variable("red"), "blue": 100, "green": 50]]]');
        });
    });
    describe('#typeDeclarationForGraphQLType()', function () {
        test('should generate an enum declaration for a GraphQLEnumType', function () {
            const generator = new CodeGenerator_1.default();
            codeGeneration_1.typeDeclarationForGraphQLType(generator, schema.getType('Episode'));
            expect(generator.output).toMatchSnapshot();
        });
        test('should escape identifiers in cases of enum declaration for a GraphQLEnumType', function () {
            const generator = new CodeGenerator_1.default();
            const albumPrivaciesEnum = new graphql_1.GraphQLEnumType({
                name: 'AlbumPrivacies',
                values: { PUBLIC: { value: "PUBLIC" }, PRIVATE: { value: "PRIVATE" } } });

            codeGeneration_1.typeDeclarationForGraphQLType(generator, albumPrivaciesEnum);
            expect(generator.output).toMatchSnapshot();
        });
        test('should generate a caseClass declaration for a GraphQLInputObjectType', function () {
            const generator = new CodeGenerator_1.default();
            codeGeneration_1.typeDeclarationForGraphQLType(generator, schema.getType('ReviewInput'));
            expect(generator.output).toMatchSnapshot();
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RDtBQWFBLGFBQUssc0VBQUwsRUFBNkUsWUFBQTtBQUMzRSxrQkFBTSxZQUFZLElBQUksZ0JBQUEsT0FBSixFQUFsQjtBQUVBLDZCQUFBLDZCQUFBLENBQThCLFNBQTlCLEVBQXlDLE9BQU8sT0FBUCxDQUFlLGFBQWYsQ0FBekM7QUFFQSxtQkFBTyxVQUFVLE1BQWpCLEVBQXlCLGVBQXpCO0FBQ0QsU0FORDtBQU9ELEtBN0JEO0FBOEJELENBemdCRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0cmlwSW5kZW50IH0gZnJvbSAnY29tbW9uLXRhZ3MnO1xuXG5pbXBvcnQge1xuICBwYXJzZSxcbiAgaXNUeXBlLFxuICBHcmFwaFFMSUQsXG4gIEdyYXBoUUxTdHJpbmcsXG4gIEdyYXBoUUxJbnQsXG4gIEdyYXBoUUxMaXN0LFxuICBHcmFwaFFMTm9uTnVsbCxcbiAgR3JhcGhRTElucHV0T2JqZWN0VHlwZSxcbiAgR3JhcGhRTEVudW1UeXBlXG59IGZyb20gJ2dyYXBocWwnO1xuXG5pbXBvcnQge1xuICBjbGFzc0RlY2xhcmF0aW9uRm9yT3BlcmF0aW9uLFxuICBjYXNlQ2xhc3NEZWNsYXJhdGlvbkZvckZyYWdtZW50LFxuICBjYXNlQ2xhc3NEZWNsYXJhdGlvbkZvclNlbGVjdGlvblNldCxcbiAgdHlwZURlY2xhcmF0aW9uRm9yR3JhcGhRTFR5cGUsXG59IGZyb20gJy4uLy4uL3NyYy9zY2FsYS9jb2RlR2VuZXJhdGlvbic7XG5cbmltcG9ydCB7XG4gIGRpY3Rpb25hcnlMaXRlcmFsRm9yRmllbGRBcmd1bWVudHMsXG59IGZyb20gJy4uLy4uL3NyYy9zY2FsYS92YWx1ZXMnO1xuXG5pbXBvcnQgeyBsb2FkU2NoZW1hIH0gZnJvbSAnLi4vLi4vc3JjL2xvYWRpbmcnO1xuY29uc3Qgc2NoZW1hID0gbG9hZFNjaGVtYShyZXF1aXJlLnJlc29sdmUoJy4uL2ZpeHR1cmVzL3N0YXJ3YXJzL3NjaGVtYS5qc29uJykpO1xuXG5pbXBvcnQgQ29kZUdlbmVyYXRvciBmcm9tICcuLi8uLi9zcmMvdXRpbGl0aWVzL0NvZGVHZW5lcmF0b3InO1xuXG5pbXBvcnQgeyBjb21waWxlVG9MZWdhY3lJUiB9IGZyb20gJy4uLy4uL3NyYy9jb21waWxlci9sZWdhY3lJUic7XG5cbmRlc2NyaWJlKCdTY2FsYSBjb2RlIGdlbmVyYXRpb24nLCBmdW5jdGlvbigpIHtcbiAgbGV0IGdlbmVyYXRvcjtcbiAgbGV0IHJlc2V0R2VuZXJhdG9yO1xuICBsZXQgY29tcGlsZUZyb21Tb3VyY2U7XG4gIGxldCBhZGRGcmFnbWVudDtcblxuICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuXG4gICAgcmVzZXRHZW5lcmF0b3IgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBzY2hlbWE6IHNjaGVtYSxcbiAgICAgICAgb3BlcmF0aW9uczoge30sXG4gICAgICAgIGZyYWdtZW50czoge30sXG4gICAgICAgIHR5cGVzVXNlZDoge31cbiAgICAgIH1cbiAgICAgIGdlbmVyYXRvciA9IG5ldyBDb2RlR2VuZXJhdG9yKGNvbnRleHQpO1xuICAgIH07XG5cbiAgICBjb21waWxlRnJvbVNvdXJjZSA9IChzb3VyY2UsIG9wdGlvbnMgPSB7IGdlbmVyYXRlT3BlcmF0aW9uSWRzOiBmYWxzZSB9KSA9PiB7XG4gICAgICBjb25zdCBkb2N1bWVudCA9IHBhcnNlKHNvdXJjZSk7XG4gICAgICBsZXQgY29udGV4dCA9IGNvbXBpbGVUb0xlZ2FjeUlSKHNjaGVtYSwgZG9jdW1lbnQpO1xuICAgICAgb3B0aW9ucy5nZW5lcmF0ZU9wZXJhdGlvbklkcyAmJiBPYmplY3QuYXNzaWduKGNvbnRleHQsIHsgZ2VuZXJhdGVPcGVyYXRpb25JZHM6IHRydWUsIG9wZXJhdGlvbklkc01hcDoge30gfSk7XG4gICAgICBnZW5lcmF0b3IuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9O1xuXG4gICAgYWRkRnJhZ21lbnQgPSAoZnJhZ21lbnQpID0+IHtcbiAgICAgIGdlbmVyYXRvci5jb250ZXh0LmZyYWdtZW50c1tmcmFnbWVudC5mcmFnbWVudE5hbWVdID0gZnJhZ21lbnQ7XG4gICAgfTtcblxuICAgIHJlc2V0R2VuZXJhdG9yKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCcjY2xhc3NEZWNsYXJhdGlvbkZvck9wZXJhdGlvbigpJywgZnVuY3Rpb24oKSB7XG4gICAgdGVzdChgc2hvdWxkIGdlbmVyYXRlIGEgY2xhc3MgZGVjbGFyYXRpb24gZm9yIGEgcXVlcnkgd2l0aCB2YXJpYWJsZXNgLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IHsgb3BlcmF0aW9ucywgZnJhZ21lbnRzIH0gPSBjb21waWxlRnJvbVNvdXJjZShgXG4gICAgICAgIHF1ZXJ5IEhlcm9OYW1lKCRlcGlzb2RlOiBFcGlzb2RlKSB7XG4gICAgICAgICAgaGVybyhlcGlzb2RlOiAkZXBpc29kZSkge1xuICAgICAgICAgICAgbmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgYCk7XG5cbiAgICAgIGNsYXNzRGVjbGFyYXRpb25Gb3JPcGVyYXRpb24oZ2VuZXJhdG9yLCBvcGVyYXRpb25zWydIZXJvTmFtZSddLCBPYmplY3QudmFsdWVzKGZyYWdtZW50cykpO1xuICAgICAgZXhwZWN0KGdlbmVyYXRvci5vdXRwdXQpLnRvTWF0Y2hTbmFwc2hvdCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChgc2hvdWxkIGdlbmVyYXRlIGEgY2xhc3MgZGVjbGFyYXRpb24gZm9yIGEgcXVlcnkgd2l0aCBmcmFnbWVudCBzcHJlYWRzYCwgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCB7IG9wZXJhdGlvbnMsIGZyYWdtZW50cyB9ID0gY29tcGlsZUZyb21Tb3VyY2UoYFxuICAgICAgICBxdWVyeSBIZXJvIHtcbiAgICAgICAgICBoZXJvIHtcbiAgICAgICAgICAgIC4uLkhlcm9EZXRhaWxzXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnJhZ21lbnQgSGVyb0RldGFpbHMgb24gQ2hhcmFjdGVyIHtcbiAgICAgICAgICBuYW1lXG4gICAgICAgIH1cbiAgICAgIGApO1xuXG4gICAgICBjbGFzc0RlY2xhcmF0aW9uRm9yT3BlcmF0aW9uKGdlbmVyYXRvciwgb3BlcmF0aW9uc1snSGVybyddLCBPYmplY3QudmFsdWVzKGZyYWdtZW50cykpO1xuICAgICAgZXhwZWN0KGdlbmVyYXRvci5vdXRwdXQpLnRvTWF0Y2hTbmFwc2hvdCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChgc2hvdWxkIGdlbmVyYXRlIGEgY2xhc3MgZGVjbGFyYXRpb24gZm9yIGEgcXVlcnkgd2l0aCBjb25kaXRpb25hbCBmcmFnbWVudCBzcHJlYWRzYCwgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCB7IG9wZXJhdGlvbnMsIGZyYWdtZW50cyB9ID0gY29tcGlsZUZyb21Tb3VyY2UoYFxuICAgICAgICBxdWVyeSBIZXJvIHtcbiAgICAgICAgICBoZXJvIHtcbiAgICAgICAgICAgIC4uLkRyb2lkRGV0YWlsc1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZyYWdtZW50IERyb2lkRGV0YWlscyBvbiBEcm9pZCB7XG4gICAgICAgICAgcHJpbWFyeUZ1bmN0aW9uXG4gICAgICAgIH1cbiAgICAgIGApO1xuXG4gICAgICBjbGFzc0RlY2xhcmF0aW9uRm9yT3BlcmF0aW9uKGdlbmVyYXRvciwgb3BlcmF0aW9uc1snSGVybyddLCBPYmplY3QudmFsdWVzKGZyYWdtZW50cykpO1xuICAgICAgZXhwZWN0KGdlbmVyYXRvci5vdXRwdXQpLnRvTWF0Y2hTbmFwc2hvdCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChgc2hvdWxkIGdlbmVyYXRlIGEgY2xhc3MgZGVjbGFyYXRpb24gZm9yIGEgcXVlcnkgd2l0aCBhIGZyYWdtZW50IHNwcmVhZCBuZXN0ZWQgaW4gYW4gaW5saW5lIGZyYWdtZW50YCwgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCB7IG9wZXJhdGlvbnMsIGZyYWdtZW50cyB9ID0gY29tcGlsZUZyb21Tb3VyY2UoYFxuICAgICAgICBxdWVyeSBIZXJvIHtcbiAgICAgICAgICBoZXJvIHtcbiAgICAgICAgICAgIC4uLiBvbiBEcm9pZCB7XG4gICAgICAgICAgICAgIC4uLkhlcm9EZXRhaWxzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnJhZ21lbnQgSGVyb0RldGFpbHMgb24gQ2hhcmFjdGVyIHtcbiAgICAgICAgICBuYW1lXG4gICAgICAgIH1cbiAgICAgIGApO1xuXG4gICAgICBjbGFzc0RlY2xhcmF0aW9uRm9yT3BlcmF0aW9uKGdlbmVyYXRvciwgb3BlcmF0aW9uc1snSGVybyddLCBPYmplY3QudmFsdWVzKGZyYWdtZW50cykpO1xuXG4gICAgICBleHBlY3QoZ2VuZXJhdG9yLm91dHB1dCkudG9NYXRjaFNuYXBzaG90KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KGBzaG91bGQgZ2VuZXJhdGUgYSBjbGFzcyBkZWNsYXJhdGlvbiBmb3IgYSBtdXRhdGlvbiB3aXRoIHZhcmlhYmxlc2AsIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgeyBvcGVyYXRpb25zLCBmcmFnbWVudHMgfSA9IGNvbXBpbGVGcm9tU291cmNlKGBcbiAgICAgICAgbXV0YXRpb24gQ3JlYXRlUmV2aWV3KCRlcGlzb2RlOiBFcGlzb2RlKSB7XG4gICAgICAgICAgY3JlYXRlUmV2aWV3KGVwaXNvZGU6ICRlcGlzb2RlLCByZXZpZXc6IHsgc3RhcnM6IDUsIGNvbW1lbnRhcnk6IFwiV293IVwiIH0pIHtcbiAgICAgICAgICAgIHN0YXJzXG4gICAgICAgICAgICBjb21tZW50YXJ5XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBgKTtcblxuICAgICAgY2xhc3NEZWNsYXJhdGlvbkZvck9wZXJhdGlvbihnZW5lcmF0b3IsIG9wZXJhdGlvbnNbJ0NyZWF0ZVJldmlldyddLCBPYmplY3QudmFsdWVzKGZyYWdtZW50cykpO1xuXG4gICAgICBleHBlY3QoZ2VuZXJhdG9yLm91dHB1dCkudG9NYXRjaFNuYXBzaG90KCk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZShgd2hlbiBnZW5lcmF0ZU9wZXJhdGlvbklkcyBpcyBzcGVjaWZpZWRgLCBmdW5jdGlvbigpIHtcbiAgICAgIGxldCBjb21waWxlT3B0aW9ucyA9IHsgZ2VuZXJhdGVPcGVyYXRpb25JZHM6IHRydWUgfTtcblxuICAgICAgdGVzdChgc2hvdWxkIGdlbmVyYXRlIGEgY2xhc3MgZGVjbGFyYXRpb24gd2l0aCBhbiBvcGVyYXRpb25JZCBwcm9wZXJ0eWAsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gY29tcGlsZUZyb21Tb3VyY2UoYFxuICAgICAgICAgIHF1ZXJ5IEhlcm8ge1xuICAgICAgICAgICAgaGVybyB7XG4gICAgICAgICAgICAgIC4uLkhlcm9EZXRhaWxzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZyYWdtZW50IEhlcm9EZXRhaWxzIG9uIENoYXJhY3RlciB7XG4gICAgICAgICAgICBuYW1lXG4gICAgICAgICAgfVxuICAgICAgICBgLCBjb21waWxlT3B0aW9ucyk7XG5cbiAgICAgICAgY2xhc3NEZWNsYXJhdGlvbkZvck9wZXJhdGlvbihnZW5lcmF0b3IsIGNvbnRleHQub3BlcmF0aW9uc1snSGVybyddLCBPYmplY3QudmFsdWVzKGNvbnRleHQuZnJhZ21lbnRzKSk7XG4gICAgICAgIGV4cGVjdChnZW5lcmF0b3Iub3V0cHV0KS50b01hdGNoU25hcHNob3QoKTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0KGBzaG91bGQgZ2VuZXJhdGUgZGlmZmVyZW50IG9wZXJhdGlvbiBpZHMgZm9yIGRpZmZlcmVudCBvcGVyYXRpb25zYCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQxID0gY29tcGlsZUZyb21Tb3VyY2UoYFxuICAgICAgICAgIHF1ZXJ5IEhlcm8ge1xuICAgICAgICAgICAgaGVybyB7XG4gICAgICAgICAgICAgIC4uLkhlcm9EZXRhaWxzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZyYWdtZW50IEhlcm9EZXRhaWxzIG9uIENoYXJhY3RlciB7XG4gICAgICAgICAgICBuYW1lXG4gICAgICAgICAgfVxuICAgICAgICBgLCBjb21waWxlT3B0aW9ucyk7XG5cbiAgICAgICAgY2xhc3NEZWNsYXJhdGlvbkZvck9wZXJhdGlvbihnZW5lcmF0b3IsIGNvbnRleHQxLm9wZXJhdGlvbnNbJ0hlcm8nXSwgT2JqZWN0LnZhbHVlcyhjb250ZXh0MS5mcmFnbWVudHMpKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0MSA9IGdlbmVyYXRvci5vdXRwdXQ7XG5cbiAgICAgICAgcmVzZXRHZW5lcmF0b3IoKTtcbiAgICAgICAgY29uc3QgY29udGV4dDIgPSBjb21waWxlRnJvbVNvdXJjZShgXG4gICAgICAgICAgcXVlcnkgSGVybyB7XG4gICAgICAgICAgICBoZXJvIHtcbiAgICAgICAgICAgICAgLi4uSGVyb0RldGFpbHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnJhZ21lbnQgSGVyb0RldGFpbHMgb24gQ2hhcmFjdGVyIHtcbiAgICAgICAgICAgIGFwcGVhcnNJblxuICAgICAgICAgIH1cbiAgICAgICAgYCwgY29tcGlsZU9wdGlvbnMpO1xuXG4gICAgICAgIGNsYXNzRGVjbGFyYXRpb25Gb3JPcGVyYXRpb24oZ2VuZXJhdG9yLCBjb250ZXh0Mi5vcGVyYXRpb25zWydIZXJvJ10sIE9iamVjdC52YWx1ZXMoY29udGV4dDIuZnJhZ21lbnRzKSk7XG4gICAgICAgIGNvbnN0IG91dHB1dDIgPSBnZW5lcmF0b3Iub3V0cHV0O1xuXG4gICAgICAgIGV4cGVjdChvdXRwdXQxKS5ub3QudG9CZShvdXRwdXQyKTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0KGBzaG91bGQgZ2VuZXJhdGUgdGhlIHNhbWUgb3BlcmF0aW9uIGlkIHJlZ2FyZGxlc3Mgb2Ygb3BlcmF0aW9uIGZvcm1hdHRpbmcvY29tbWVudGluZ2AsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBjb250ZXh0MSA9IGNvbXBpbGVGcm9tU291cmNlKGBcbiAgICAgICAgICBxdWVyeSBIZXJvTmFtZSgkZXBpc29kZTogRXBpc29kZSkge1xuICAgICAgICAgICAgaGVybyhlcGlzb2RlOiAkZXBpc29kZSkge1xuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBgLCBjb21waWxlT3B0aW9ucyk7XG5cbiAgICAgICAgY2xhc3NEZWNsYXJhdGlvbkZvck9wZXJhdGlvbihnZW5lcmF0b3IsIGNvbnRleHQxLm9wZXJhdGlvbnNbJ0hlcm9OYW1lJ10sIE9iamVjdC52YWx1ZXMoY29udGV4dDEuZnJhZ21lbnRzKSk7XG4gICAgICAgIGNvbnN0IG91dHB1dDEgPSBnZW5lcmF0b3Iub3V0cHV0O1xuXG4gICAgICAgIHJlc2V0R2VuZXJhdG9yKCk7XG4gICAgICAgIGNvbnN0IGNvbnRleHQyID0gY29tcGlsZUZyb21Tb3VyY2UoYFxuICAgICAgICAgICMgUHJvZm91bmQgY29tbWVudFxuICAgICAgICAgIHF1ZXJ5IEhlcm9OYW1lKCRlcGlzb2RlOkVwaXNvZGUpIHsgaGVybyhlcGlzb2RlOiAkZXBpc29kZSkgeyBuYW1lIH0gfVxuICAgICAgICAgICMgRGVlcGx5IG1lYW5pbmdmdWwgY29tbWVudFxuICAgICAgICBgLCBjb21waWxlT3B0aW9ucyk7XG5cbiAgICAgICAgY2xhc3NEZWNsYXJhdGlvbkZvck9wZXJhdGlvbihnZW5lcmF0b3IsIGNvbnRleHQyLm9wZXJhdGlvbnNbJ0hlcm9OYW1lJ10sIE9iamVjdC52YWx1ZXMoY29udGV4dDIuZnJhZ21lbnRzKSk7XG4gICAgICAgIGNvbnN0IG91dHB1dDIgPSBnZW5lcmF0b3Iub3V0cHV0O1xuXG4gICAgICAgIGV4cGVjdChvdXRwdXQxKS50b0JlKG91dHB1dDIpO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoYHNob3VsZCBnZW5lcmF0ZSB0aGUgc2FtZSBvcGVyYXRpb24gaWQgcmVnYXJkbGVzcyBvZiBmcmFnbWVudCBvcmRlcmAsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBjb250ZXh0MSA9IGNvbXBpbGVGcm9tU291cmNlKGBcbiAgICAgICAgICBxdWVyeSBIZXJvIHtcbiAgICAgICAgICAgIGhlcm8ge1xuICAgICAgICAgICAgICAuLi5IZXJvTmFtZVxuICAgICAgICAgICAgICAuLi5IZXJvQXBwZWFyc0luXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZyYWdtZW50IEhlcm9OYW1lIG9uIENoYXJhY3RlciB7XG4gICAgICAgICAgICBuYW1lXG4gICAgICAgICAgfVxuICAgICAgICAgIGZyYWdtZW50IEhlcm9BcHBlYXJzSW4gb24gQ2hhcmFjdGVyIHtcbiAgICAgICAgICAgIGFwcGVhcnNJblxuICAgICAgICAgIH1cbiAgICAgICAgYCwgY29tcGlsZU9wdGlvbnMpO1xuXG4gICAgICAgIGNsYXNzRGVjbGFyYXRpb25Gb3JPcGVyYXRpb24oZ2VuZXJhdG9yLCBjb250ZXh0MS5vcGVyYXRpb25zWydIZXJvJ10sIE9iamVjdC52YWx1ZXMoY29udGV4dDEuZnJhZ21lbnRzKSk7XG4gICAgICAgIGNvbnN0IG91dHB1dDEgPSBnZW5lcmF0b3Iub3V0cHV0O1xuXG4gICAgICAgIHJlc2V0R2VuZXJhdG9yKCk7XG4gICAgICAgIGNvbnN0IGNvbnRleHQyID0gY29tcGlsZUZyb21Tb3VyY2UoYFxuICAgICAgICAgIHF1ZXJ5IEhlcm8ge1xuICAgICAgICAgICAgaGVybyB7XG4gICAgICAgICAgICAgIC4uLkhlcm9OYW1lXG4gICAgICAgICAgICAgIC4uLkhlcm9BcHBlYXJzSW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnJhZ21lbnQgSGVyb0FwcGVhcnNJbiBvbiBDaGFyYWN0ZXIge1xuICAgICAgICAgICAgYXBwZWFyc0luXG4gICAgICAgICAgfVxuICAgICAgICAgIGZyYWdtZW50IEhlcm9OYW1lIG9uIENoYXJhY3RlciB7XG4gICAgICAgICAgICBuYW1lXG4gICAgICAgICAgfVxuICAgICAgICBgLCBjb21waWxlT3B0aW9ucyk7XG5cbiAgICAgICAgY2xhc3NEZWNsYXJhdGlvbkZvck9wZXJhdGlvbihnZW5lcmF0b3IsIGNvbnRleHQyLm9wZXJhdGlvbnNbJ0hlcm8nXSwgT2JqZWN0LnZhbHVlcyhjb250ZXh0Mi5mcmFnbWVudHMpKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0MiA9IGdlbmVyYXRvci5vdXRwdXQ7XG5cbiAgICAgICAgZXhwZWN0KG91dHB1dDEpLnRvQmUob3V0cHV0Mik7XG4gICAgICB9KTtcblxuICAgICAgdGVzdChgc2hvdWxkIGdlbmVyYXRlIGFwcHJvcHJpYXRlIG9wZXJhdGlvbiBpZCBtYXBwaW5nIHNvdXJjZSB3aGVuIHRoZXJlIGFyZSBuZXN0ZWQgZnJhZ21lbnQgcmVmZXJlbmNlc2AsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgcXVlcnkgSGVybyB7XG4gICAgICAgICAgICBoZXJvIHtcbiAgICAgICAgICAgICAgLi4uSGVyb0RldGFpbHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnJhZ21lbnQgSGVyb05hbWUgb24gQ2hhcmFjdGVyIHtcbiAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICB9XG4gICAgICAgICAgZnJhZ21lbnQgSGVyb0RldGFpbHMgb24gQ2hhcmFjdGVyIHtcbiAgICAgICAgICAgIC4uLkhlcm9OYW1lXG4gICAgICAgICAgICBhcHBlYXJzSW5cbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjb21waWxlRnJvbVNvdXJjZShzb3VyY2UsIHRydWUpO1xuICAgICAgICBleHBlY3QoY29udGV4dC5vcGVyYXRpb25zWydIZXJvJ10uc291cmNlV2l0aEZyYWdtZW50cykudG9NYXRjaFNuYXBzaG90KCk7XG4gICAgICB9KTtcblxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnI2Nhc2VDbGFzc0RlY2xhcmF0aW9uRm9yRnJhZ21lbnQoKScsIGZ1bmN0aW9uKCkge1xuICAgIHRlc3QoYHNob3VsZCBnZW5lcmF0ZSBhIGNhc2VDbGFzcyBkZWNsYXJhdGlvbiBmb3IgYSBmcmFnbWVudCB3aXRoIGFuIGFic3RyYWN0IHR5cGUgY29uZGl0aW9uYCwgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCB7IGZyYWdtZW50cyB9ID0gY29tcGlsZUZyb21Tb3VyY2UoYFxuICAgICAgICBmcmFnbWVudCBIZXJvRGV0YWlscyBvbiBDaGFyYWN0ZXIge1xuICAgICAgICAgIG5hbWVcbiAgICAgICAgICBhcHBlYXJzSW5cbiAgICAgICAgfVxuICAgICAgYCk7XG5cbiAgICAgIGNhc2VDbGFzc0RlY2xhcmF0aW9uRm9yRnJhZ21lbnQoZ2VuZXJhdG9yLCBmcmFnbWVudHNbJ0hlcm9EZXRhaWxzJ10pO1xuXG4gICAgICBleHBlY3QoZ2VuZXJhdG9yLm91dHB1dCkudG9NYXRjaFNuYXBzaG90KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KGBzaG91bGQgZ2VuZXJhdGUgYSBjYXNlQ2xhc3MgZGVjbGFyYXRpb24gZm9yIGEgZnJhZ21lbnQgd2l0aCBhIGNvbmNyZXRlIHR5cGUgY29uZGl0aW9uYCwgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCB7IGZyYWdtZW50cyB9ID0gY29tcGlsZUZyb21Tb3VyY2UoYFxuICAgICAgICBmcmFnbWVudCBEcm9pZERldGFpbHMgb24gRHJvaWQge1xuICAgICAgICAgIG5hbWVcbiAgICAgICAgICBwcmltYXJ5RnVuY3Rpb25cbiAgICAgICAgfVxuICAgICAgYCk7XG5cbiAgICAgIGNhc2VDbGFzc0RlY2xhcmF0aW9uRm9yRnJhZ21lbnQoZ2VuZXJhdG9yLCBmcmFnbWVudHNbJ0Ryb2lkRGV0YWlscyddKTtcblxuICAgICAgZXhwZWN0KGdlbmVyYXRvci5vdXRwdXQpLnRvTWF0Y2hTbmFwc2hvdCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChgc2hvdWxkIGdlbmVyYXRlIGEgY2FzZUNsYXNzIGRlY2xhcmF0aW9uIGZvciBhIGZyYWdtZW50IHdpdGggYSBzdWJzZWxlY3Rpb25gLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IHsgZnJhZ21lbnRzIH0gPSBjb21waWxlRnJvbVNvdXJjZShgXG4gICAgICAgIGZyYWdtZW50IEhlcm9EZXRhaWxzIG9uIENoYXJhY3RlciB7XG4gICAgICAgICAgbmFtZVxuICAgICAgICAgIGZyaWVuZHMge1xuICAgICAgICAgICAgbmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgYCk7XG5cbiAgICAgIGNhc2VDbGFzc0RlY2xhcmF0aW9uRm9yRnJhZ21lbnQoZ2VuZXJhdG9yLCBmcmFnbWVudHNbJ0hlcm9EZXRhaWxzJ10pO1xuXG4gICAgICBleHBlY3QoZ2VuZXJhdG9yLm91dHB1dCkudG9NYXRjaFNuYXBzaG90KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KGBzaG91bGQgZ2VuZXJhdGUgYSBjYXNlQ2xhc3MgZGVjbGFyYXRpb24gZm9yIGEgZnJhZ21lbnQgdGhhdCBpbmNsdWRlcyBhIGZyYWdtZW50IHNwcmVhZGAsIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgeyBmcmFnbWVudHMgfSA9IGNvbXBpbGVGcm9tU291cmNlKGBcbiAgICAgICAgZnJhZ21lbnQgSGVyb0RldGFpbHMgb24gQ2hhcmFjdGVyIHtcbiAgICAgICAgICBuYW1lXG4gICAgICAgICAgLi4uTW9yZUhlcm9EZXRhaWxzXG4gICAgICAgIH1cblxuICAgICAgICBmcmFnbWVudCBNb3JlSGVyb0RldGFpbHMgb24gQ2hhcmFjdGVyIHtcbiAgICAgICAgICBhcHBlYXJzSW5cbiAgICAgICAgfVxuICAgICAgYCk7XG5cbiAgICAgIGNhc2VDbGFzc0RlY2xhcmF0aW9uRm9yRnJhZ21lbnQoZ2VuZXJhdG9yLCBmcmFnbWVudHNbJ0hlcm9EZXRhaWxzJ10pO1xuXG4gICAgICBleHBlY3QoZ2VuZXJhdG9yLm91dHB1dCkudG9NYXRjaFNuYXBzaG90KCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCcjY2FzZUNsYXNzRGVjbGFyYXRpb25Gb3JTZWxlY3Rpb25TZXQoKScsIGZ1bmN0aW9uKCkge1xuICAgIHRlc3QoYHNob3VsZCBnZW5lcmF0ZSBhIGNhc2VDbGFzcyBkZWNsYXJhdGlvbiBmb3IgYSBzZWxlY3Rpb24gc2V0YCwgZnVuY3Rpb24oKSB7XG4gICAgICBjYXNlQ2xhc3NEZWNsYXJhdGlvbkZvclNlbGVjdGlvblNldChnZW5lcmF0b3IsIHtcbiAgICAgICAgY2FzZUNsYXNzTmFtZTogJ0hlcm8nLFxuICAgICAgICBwYXJlbnRUeXBlOiBzY2hlbWEuZ2V0VHlwZSgnQ2hhcmFjdGVyJyksXG4gICAgICAgIGZpZWxkczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJlc3BvbnNlTmFtZTogJ25hbWUnLFxuICAgICAgICAgICAgZmllbGROYW1lOiAnbmFtZScsXG4gICAgICAgICAgICB0eXBlOiBHcmFwaFFMU3RyaW5nXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KGdlbmVyYXRvci5vdXRwdXQpLnRvTWF0Y2hTbmFwc2hvdCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChgc2hvdWxkIGVzY2FwZSByZXNlcnZlZCBrZXl3b3JkcyBpbiBhIGNhc2VDbGFzcyBkZWNsYXJhdGlvbiBmb3IgYSBzZWxlY3Rpb24gc2V0YCwgZnVuY3Rpb24oKSB7XG4gICAgICBjYXNlQ2xhc3NEZWNsYXJhdGlvbkZvclNlbGVjdGlvblNldChnZW5lcmF0b3IsIHtcbiAgICAgICAgY2FzZUNsYXNzTmFtZTogJ0hlcm8nLFxuICAgICAgICBwYXJlbnRUeXBlOiBzY2hlbWEuZ2V0VHlwZSgnQ2hhcmFjdGVyJyksXG4gICAgICAgIGZpZWxkczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJlc3BvbnNlTmFtZTogJ3ByaXZhdGUnLFxuICAgICAgICAgICAgZmllbGROYW1lOiAnbmFtZScsXG4gICAgICAgICAgICB0eXBlOiBHcmFwaFFMU3RyaW5nXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KGdlbmVyYXRvci5vdXRwdXQpLnRvTWF0Y2hTbmFwc2hvdCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChgc2hvdWxkIGdlbmVyYXRlIGEgbmVzdGVkIGNhc2VDbGFzcyBkZWNsYXJhdGlvbiBmb3IgYSBzZWxlY3Rpb24gc2V0IHdpdGggc3Vic2VsZWN0aW9uc2AsIGZ1bmN0aW9uKCkge1xuICAgICAgY2FzZUNsYXNzRGVjbGFyYXRpb25Gb3JTZWxlY3Rpb25TZXQoZ2VuZXJhdG9yLCB7XG4gICAgICAgIGNhc2VDbGFzc05hbWU6ICdIZXJvJyxcbiAgICAgICAgcGFyZW50VHlwZTogc2NoZW1hLmdldFR5cGUoJ0NoYXJhY3RlcicpLFxuICAgICAgICBmaWVsZHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXNwb25zZU5hbWU6ICdmcmllbmRzJyxcbiAgICAgICAgICAgIGZpZWxkTmFtZTogJ2ZyaWVuZHMnLFxuICAgICAgICAgICAgdHlwZTogbmV3IEdyYXBoUUxMaXN0KHNjaGVtYS5nZXRUeXBlKCdDaGFyYWN0ZXInKSksXG4gICAgICAgICAgICBmaWVsZHM6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlTmFtZTogJ25hbWUnLFxuICAgICAgICAgICAgICAgIGZpZWxkTmFtZTogJ25hbWUnLFxuICAgICAgICAgICAgICAgIHR5cGU6IEdyYXBoUUxTdHJpbmdcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChnZW5lcmF0b3Iub3V0cHV0KS50b01hdGNoU25hcHNob3QoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoYHNob3VsZCBnZW5lcmF0ZSBhIGNhc2VDbGFzcyBkZWNsYXJhdGlvbiBmb3IgYSBzZWxlY3Rpb24gc2V0IHdpdGggYSBmcmFnbWVudCBzcHJlYWQgdGhhdCBtYXRjaGVzIHRoZSBwYXJlbnQgdHlwZWAsIGZ1bmN0aW9uKCkge1xuICAgICAgYWRkRnJhZ21lbnQoe1xuICAgICAgICBmcmFnbWVudE5hbWU6ICdIZXJvRGV0YWlscycsXG4gICAgICAgIHR5cGVDb25kaXRpb246IHNjaGVtYS5nZXRUeXBlKCdDaGFyYWN0ZXInKVxuICAgICAgfSk7XG5cbiAgICAgIGNhc2VDbGFzc0RlY2xhcmF0aW9uRm9yU2VsZWN0aW9uU2V0KGdlbmVyYXRvciwge1xuICAgICAgICBjYXNlQ2xhc3NOYW1lOiAnSGVybycsXG4gICAgICAgIHBhcmVudFR5cGU6IHNjaGVtYS5nZXRUeXBlKCdDaGFyYWN0ZXInKSxcbiAgICAgICAgZnJhZ21lbnRTcHJlYWRzOiBbJ0hlcm9EZXRhaWxzJ10sXG4gICAgICAgIGZpZWxkczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJlc3BvbnNlTmFtZTogJ25hbWUnLFxuICAgICAgICAgICAgZmllbGROYW1lOiAnbmFtZScsXG4gICAgICAgICAgICB0eXBlOiBHcmFwaFFMU3RyaW5nXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KGdlbmVyYXRvci5vdXRwdXQpLnRvTWF0Y2hTbmFwc2hvdCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChgc2hvdWxkIGdlbmVyYXRlIGEgY2FzZUNsYXNzIGRlY2xhcmF0aW9uIGZvciBhIHNlbGVjdGlvbiBzZXQgd2l0aCBhIGZyYWdtZW50IHNwcmVhZCB3aXRoIGEgbW9yZSBzcGVjaWZpYyB0eXBlIGNvbmRpdGlvbmAsIGZ1bmN0aW9uKCkge1xuICAgICAgYWRkRnJhZ21lbnQoe1xuICAgICAgICBmcmFnbWVudE5hbWU6ICdEcm9pZERldGFpbHMnLFxuICAgICAgICB0eXBlQ29uZGl0aW9uOiBzY2hlbWEuZ2V0VHlwZSgnRHJvaWQnKVxuICAgICAgfSk7XG5cbiAgICAgIGNhc2VDbGFzc0RlY2xhcmF0aW9uRm9yU2VsZWN0aW9uU2V0KGdlbmVyYXRvciwge1xuICAgICAgICBjYXNlQ2xhc3NOYW1lOiAnSGVybycsXG4gICAgICAgIHBhcmVudFR5cGU6IHNjaGVtYS5nZXRUeXBlKCdDaGFyYWN0ZXInKSxcbiAgICAgICAgZnJhZ21lbnRTcHJlYWRzOiBbJ0Ryb2lkRGV0YWlscyddLFxuICAgICAgICBmaWVsZHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXNwb25zZU5hbWU6ICduYW1lJyxcbiAgICAgICAgICAgIGZpZWxkTmFtZTogJ25hbWUnLFxuICAgICAgICAgICAgdHlwZTogR3JhcGhRTFN0cmluZ1xuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChnZW5lcmF0b3Iub3V0cHV0KS50b01hdGNoU25hcHNob3QoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoYHNob3VsZCBnZW5lcmF0ZSBhIGNhc2VDbGFzcyBkZWNsYXJhdGlvbiBmb3IgYSBzZWxlY3Rpb24gc2V0IHdpdGggYW4gaW5saW5lIGZyYWdtZW50YCwgZnVuY3Rpb24oKSB7XG4gICAgICBjYXNlQ2xhc3NEZWNsYXJhdGlvbkZvclNlbGVjdGlvblNldChnZW5lcmF0b3IsIHtcbiAgICAgICAgY2FzZUNsYXNzTmFtZTogJ0hlcm8nLFxuICAgICAgICBwYXJlbnRUeXBlOiBzY2hlbWEuZ2V0VHlwZSgnQ2hhcmFjdGVyJyksXG4gICAgICAgIGZpZWxkczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJlc3BvbnNlTmFtZTogJ25hbWUnLFxuICAgICAgICAgICAgZmllbGROYW1lOiAnbmFtZScsXG4gICAgICAgICAgICB0eXBlOiBuZXcgR3JhcGhRTE5vbk51bGwoR3JhcGhRTFN0cmluZylcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGlubGluZUZyYWdtZW50czogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGVDb25kaXRpb246IHNjaGVtYS5nZXRUeXBlKCdEcm9pZCcpLFxuICAgICAgICAgICAgcG9zc2libGVUeXBlczogWydEcm9pZCddLFxuICAgICAgICAgICAgZmllbGRzOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZU5hbWU6ICduYW1lJyxcbiAgICAgICAgICAgICAgICBmaWVsZE5hbWU6ICduYW1lJyxcbiAgICAgICAgICAgICAgICB0eXBlOiBuZXcgR3JhcGhRTE5vbk51bGwoR3JhcGhRTFN0cmluZylcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlTmFtZTogJ3ByaW1hcnlGdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgZmllbGROYW1lOiAncHJpbWFyeUZ1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICB0eXBlOiBHcmFwaFFMU3RyaW5nXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoZ2VuZXJhdG9yLm91dHB1dCkudG9NYXRjaFNuYXBzaG90KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KGBzaG91bGQgZ2VuZXJhdGUgYSBjYXNlQ2xhc3MgZGVjbGFyYXRpb24gZm9yIGEgZnJhZ21lbnQgc3ByZWFkIG5lc3RlZCBpbiBhbiBpbmxpbmUgZnJhZ21lbnRgLCBmdW5jdGlvbigpIHtcbiAgICAgIGFkZEZyYWdtZW50KHtcbiAgICAgICAgZnJhZ21lbnROYW1lOiAnSGVyb0RldGFpbHMnLFxuICAgICAgICB0eXBlQ29uZGl0aW9uOiBzY2hlbWEuZ2V0VHlwZSgnQ2hhcmFjdGVyJylcbiAgICAgIH0pO1xuXG4gICAgICBjYXNlQ2xhc3NEZWNsYXJhdGlvbkZvclNlbGVjdGlvblNldChnZW5lcmF0b3IsIHtcbiAgICAgICAgY2FzZUNsYXNzTmFtZTogJ0hlcm8nLFxuICAgICAgICBwYXJlbnRUeXBlOiBzY2hlbWEuZ2V0VHlwZSgnQ2hhcmFjdGVyJyksXG4gICAgICAgIGZpZWxkczogW10sXG4gICAgICAgIGlubGluZUZyYWdtZW50czogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGVDb25kaXRpb246IHNjaGVtYS5nZXRUeXBlKCdEcm9pZCcpLFxuICAgICAgICAgICAgcG9zc2libGVUeXBlczogWydEcm9pZCddLFxuICAgICAgICAgICAgZmllbGRzOiBbXSxcbiAgICAgICAgICAgIGZyYWdtZW50U3ByZWFkczogWydIZXJvRGV0YWlscyddLFxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChnZW5lcmF0b3Iub3V0cHV0KS50b01hdGNoU25hcHNob3QoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJyNkaWN0aW9uYXJ5TGl0ZXJhbEZvckZpZWxkQXJndW1lbnRzKCknLCBmdW5jdGlvbigpIHtcbiAgICB0ZXN0KCdzaG91bGQgaW5jbHVkZSBleHByZXNzaW9ucyBmb3IgaW5wdXQgb2JqZWN0cyB3aXRoIHZhcmlhYmxlcycsIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgeyBvcGVyYXRpb25zIH0gPSBjb21waWxlRnJvbVNvdXJjZShgXG4gICAgICAgIG11dGF0aW9uIEZpZWxkQXJndW1lbnRzV2l0aElucHV0T2JqZWN0cygkY29tbWVudGFyeTogU3RyaW5nISwgJHJlZDogSW50ISkge1xuICAgICAgICAgIGNyZWF0ZVJldmlldyhlcGlzb2RlOiBKRURJLCByZXZpZXc6IHsgc3RhcnM6IDIsIGNvbW1lbnRhcnk6ICRjb21tZW50YXJ5LCBmYXZvcml0ZV9jb2xvcjogeyByZWQ6ICRyZWQsIGJsdWU6IDEwMCwgZ3JlZW46IDUwIH0gfSkge1xuICAgICAgICAgICAgY29tbWVudGFyeVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgYCk7XG5cbiAgICAgIGNvbnN0IGZpZWxkQXJndW1lbnRzID0gb3BlcmF0aW9uc1snRmllbGRBcmd1bWVudHNXaXRoSW5wdXRPYmplY3RzJ10uZmllbGRzWzBdLmFyZ3M7XG4gICAgICBjb25zdCBkaWN0aW9uYXJ5TGl0ZXJhbCA9IGRpY3Rpb25hcnlMaXRlcmFsRm9yRmllbGRBcmd1bWVudHMoZmllbGRBcmd1bWVudHMpO1xuXG4gICAgICBleHBlY3QoZGljdGlvbmFyeUxpdGVyYWwpLnRvQmUoJ1tcImVwaXNvZGVcIjogXCJKRURJXCIsIFwicmV2aWV3XCI6IFtcInN0YXJzXCI6IDIsIFwiY29tbWVudGFyeVwiOiBWYXJpYWJsZShcImNvbW1lbnRhcnlcIiksIFwiZmF2b3JpdGVfY29sb3JcIjogW1wicmVkXCI6IFZhcmlhYmxlKFwicmVkXCIpLCBcImJsdWVcIjogMTAwLCBcImdyZWVuXCI6IDUwXV1dJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCcjdHlwZURlY2xhcmF0aW9uRm9yR3JhcGhRTFR5cGUoKScsIGZ1bmN0aW9uKCkge1xuICAgIHRlc3QoJ3Nob3VsZCBnZW5lcmF0ZSBhbiBlbnVtIGRlY2xhcmF0aW9uIGZvciBhIEdyYXBoUUxFbnVtVHlwZScsIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZ2VuZXJhdG9yID0gbmV3IENvZGVHZW5lcmF0b3IoKTtcblxuICAgICAgdHlwZURlY2xhcmF0aW9uRm9yR3JhcGhRTFR5cGUoZ2VuZXJhdG9yLCBzY2hlbWEuZ2V0VHlwZSgnRXBpc29kZScpKTtcblxuICAgICAgZXhwZWN0KGdlbmVyYXRvci5vdXRwdXQpLnRvTWF0Y2hTbmFwc2hvdCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGVzY2FwZSBpZGVudGlmaWVycyBpbiBjYXNlcyBvZiBlbnVtIGRlY2xhcmF0aW9uIGZvciBhIEdyYXBoUUxFbnVtVHlwZScsIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZ2VuZXJhdG9yID0gbmV3IENvZGVHZW5lcmF0b3IoKTtcblxuICAgICAgY29uc3QgYWxidW1Qcml2YWNpZXNFbnVtID0gbmV3IEdyYXBoUUxFbnVtVHlwZSh7XG4gICAgICAgIG5hbWU6ICdBbGJ1bVByaXZhY2llcycsXG4gICAgICAgIHZhbHVlczogeyBQVUJMSUM6IHsgdmFsdWU6IFwiUFVCTElDXCIgfSwgUFJJVkFURTogeyB2YWx1ZTogXCJQUklWQVRFXCIgfSB9XG4gICAgICB9KTtcblxuICAgICAgdHlwZURlY2xhcmF0aW9uRm9yR3JhcGhRTFR5cGUoZ2VuZXJhdG9yLCBhbGJ1bVByaXZhY2llc0VudW0pO1xuXG4gICAgICBleHBlY3QoZ2VuZXJhdG9yLm91dHB1dCkudG9NYXRjaFNuYXBzaG90KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgZ2VuZXJhdGUgYSBjYXNlQ2xhc3MgZGVjbGFyYXRpb24gZm9yIGEgR3JhcGhRTElucHV0T2JqZWN0VHlwZScsIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZ2VuZXJhdG9yID0gbmV3IENvZGVHZW5lcmF0b3IoKTtcblxuICAgICAgdHlwZURlY2xhcmF0aW9uRm9yR3JhcGhRTFR5cGUoZ2VuZXJhdG9yLCBzY2hlbWEuZ2V0VHlwZSgnUmV2aWV3SW5wdXQnKSk7XG5cbiAgICAgIGV4cGVjdChnZW5lcmF0b3Iub3V0cHV0KS50b01hdGNoU25hcHNob3QoKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=