caaa9c170dce731aff7cfb246fcc35ad
'use strict';require('ts-jest').install("/c/Users/Sandro/repo/amplify-cli/packages/amplify-graphql-types-generator/src/swift/codeGeneration.ts", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst path = require(\"path\");\nconst graphql_1 = require(\"graphql\");\nconst printing_1 = require(\"../utilities/printing\");\nconst language_1 = require(\"./language\");\nconst helpers_1 = require(\"./helpers\");\nconst s3Wrapper_1 = require(\"./s3Wrapper\");\nconst graphql_2 = require(\"../utilities/graphql\");\nconst typeCase_1 = require(\"../compiler/visitors/typeCase\");\nconst collectFragmentsReferenced_1 = require(\"../compiler/visitors/collectFragmentsReferenced\");\nconst generateOperationId_1 = require(\"../compiler/visitors/generateOperationId\");\nconst collectAndMergeFields_1 = require(\"../compiler/visitors/collectAndMergeFields\");\nrequire(\"../utilities/array\");\nconst complextypes_1 = require(\"../utilities/complextypes\");\nfunction generateSource(context, outputIndividualFiles, only) {\n    const generator = new SwiftAPIGenerator(context);\n    if (outputIndividualFiles) {\n        generator.withinFile(`Types.graphql.swift`, () => {\n            generator.fileHeader();\n            generator.namespaceDeclaration(context.options.namespace, () => {\n                context.typesUsed.forEach(type => {\n                    generator.typeDeclarationForGraphQLType(type);\n                });\n            });\n            if (context.options.addS3Wrapper) {\n                generator.printOnNewline(`\\n${s3Wrapper_1.s3WrapperCode}`);\n            }\n        });\n        const inputFilePaths = new Set();\n        Object.values(context.operations).forEach(operation => {\n            inputFilePaths.add(operation.filePath);\n        });\n        Object.values(context.fragments).forEach(fragment => {\n            inputFilePaths.add(fragment.filePath);\n        });\n        for (const inputFilePath of inputFilePaths) {\n            if (only && inputFilePath !== only)\n                continue;\n            generator.withinFile(`${path.basename(inputFilePath)}.swift`, () => {\n                generator.fileHeader();\n                generator.namespaceExtensionDeclaration(context.options.namespace, () => {\n                    Object.values(context.operations).forEach(operation => {\n                        if (operation.filePath === inputFilePath) {\n                            generator.classDeclarationForOperation(operation);\n                        }\n                    });\n                    Object.values(context.fragments).forEach(fragment => {\n                        if (fragment.filePath === inputFilePath) {\n                            generator.structDeclarationForFragment(fragment);\n                        }\n                    });\n                });\n            });\n        }\n    }\n    else {\n        generator.fileHeader();\n        generator.namespaceDeclaration(context.options.namespace, () => {\n            context.typesUsed.forEach(type => {\n                generator.typeDeclarationForGraphQLType(type);\n            });\n            Object.values(context.operations).forEach(operation => {\n                generator.classDeclarationForOperation(operation);\n            });\n            Object.values(context.fragments).forEach(fragment => {\n                generator.structDeclarationForFragment(fragment);\n            });\n        });\n        if (context.options.addS3Wrapper) {\n            generator.printOnNewline(`\\n${s3Wrapper_1.s3WrapperCode}`);\n        }\n    }\n    return generator;\n}\nexports.generateSource = generateSource;\nclass SwiftAPIGenerator extends language_1.SwiftGenerator {\n    constructor(context) {\n        super(context);\n        this.helpers = new helpers_1.Helpers(context.options);\n    }\n    fileHeader() {\n        this.printOnNewline('//  This file was automatically generated and should not be edited.');\n        this.printNewline();\n        this.printOnNewline('import AWSAppSync');\n    }\n    classDeclarationForOperation(operation) {\n        const { operationName, operationType, variables, source, selectionSet } = operation;\n        let className;\n        let protocol;\n        switch (operationType) {\n            case 'query':\n                className = `${this.helpers.operationClassName(operationName)}Query`;\n                protocol = 'GraphQLQuery';\n                break;\n            case 'mutation':\n                className = `${this.helpers.operationClassName(operationName)}Mutation`;\n                protocol = 'GraphQLMutation';\n                break;\n            case 'subscription':\n                className = `${this.helpers.operationClassName(operationName)}Subscription`;\n                protocol = 'GraphQLSubscription';\n                break;\n            default:\n                throw new graphql_1.GraphQLError(`Unsupported operation type \"${operationType}\"`);\n        }\n        this.classDeclaration({\n            className,\n            modifiers: ['public', 'final'],\n            adoptedProtocols: [protocol]\n        }, () => {\n            if (source) {\n                this.printOnNewline('public static let operationString =');\n                this.withIndent(() => {\n                    this.multilineString(source);\n                });\n            }\n            const fragmentsReferenced = collectFragmentsReferenced_1.collectFragmentsReferenced(operation.selectionSet, this.context.fragments);\n            if (this.context.options.generateOperationIds) {\n                const { operationId } = generateOperationId_1.generateOperationId(operation, this.context.fragments, fragmentsReferenced);\n                operation.operationId = operationId;\n                this.printNewlineIfNeeded();\n                this.printOnNewline(`public static let operationIdentifier: String? = \"${operationId}\"`);\n            }\n            if (fragmentsReferenced.size > 0) {\n                this.printNewlineIfNeeded();\n                this.printOnNewline('public static var requestString: String { return operationString');\n                fragmentsReferenced.forEach(fragmentName => {\n                    this.print(`.appending(${this.helpers.structNameForFragmentName(fragmentName)}.fragmentString)`);\n                });\n                this.print(' }');\n            }\n            this.printNewlineIfNeeded();\n            if (variables && variables.length > 0) {\n                const properties = variables.map(({ name, type }) => {\n                    const typeName = this.helpers.typeNameFromGraphQLType(type);\n                    const isOptional = !(graphql_1.isNonNullType(type) ||\n                        (graphql_1.isListType(type) && graphql_1.isNonNullType(type.ofType)));\n                    return { name, propertyName: name, type, typeName, isOptional };\n                });\n                this.propertyDeclarations(properties);\n                this.printNewlineIfNeeded();\n                this.initializerDeclarationForProperties(properties);\n                this.printNewlineIfNeeded();\n                this.printOnNewline(`public var variables: GraphQLMap?`);\n                this.withinBlock(() => {\n                    this.printOnNewline(printing_1.wrap(`return [`, printing_1.join(properties.map(({ name, propertyName }) => `\"${name}\": ${language_1.escapeIdentifierIfNeeded(propertyName)}`), ', ') || ':', `]`));\n                });\n            }\n            else {\n                this.initializerDeclarationForProperties([]);\n            }\n            this.structDeclarationForSelectionSet({\n                structName: 'Data',\n                selectionSet\n            });\n        });\n    }\n    structDeclarationForFragment({ fragmentName, selectionSet, source }) {\n        const structName = this.helpers.structNameForFragmentName(fragmentName);\n        this.structDeclarationForSelectionSet({\n            structName,\n            adoptedProtocols: ['GraphQLFragment'],\n            selectionSet\n        }, () => {\n            if (source) {\n                this.printOnNewline('public static let fragmentString =');\n                this.withIndent(() => {\n                    this.multilineString(source);\n                });\n            }\n        });\n    }\n    structDeclarationForSelectionSet({ structName, adoptedProtocols = ['GraphQLSelectionSet'], selectionSet }, before) {\n        const typeCase = typeCase_1.typeCaseForSelectionSet(selectionSet, this.context.options.mergeInFieldsFromFragmentSpreads);\n        this.structDeclarationForVariant({\n            structName,\n            adoptedProtocols,\n            variant: typeCase.default,\n            typeCase\n        }, before, () => {\n            const variants = typeCase.variants.map(this.helpers.propertyFromVariant, this.helpers);\n            for (const variant of variants) {\n                this.propertyDeclarationForVariant(variant);\n                this.structDeclarationForVariant({\n                    structName: variant.structName,\n                    variant\n                });\n            }\n        });\n    }\n    structDeclarationForVariant({ structName, adoptedProtocols = ['GraphQLSelectionSet'], variant, typeCase }, before, after) {\n        this.structDeclaration({ structName, adoptedProtocols }, () => {\n            if (before) {\n                before();\n            }\n            this.printNewlineIfNeeded();\n            this.printOnNewline('public static let possibleTypes = [');\n            this.print(printing_1.join(variant.possibleTypes.map(type => `\"${type.name}\"`), ', '));\n            this.print(']');\n            this.printNewlineIfNeeded();\n            this.printOnNewline('public static let selections: [GraphQLSelection] = ');\n            if (typeCase) {\n                this.typeCaseInitialization(typeCase);\n            }\n            else {\n                this.selectionSetInitialization(variant);\n            }\n            this.printNewlineIfNeeded();\n            this.propertyDeclaration({\n                propertyName: 'snapshot',\n                typeName: 'Snapshot'\n            });\n            this.printNewlineIfNeeded();\n            this.printOnNewline('public init(snapshot: Snapshot)');\n            this.withinBlock(() => {\n                this.printOnNewline(`self.snapshot = snapshot`);\n            });\n            if (typeCase) {\n                this.initializersForTypeCase(typeCase);\n            }\n            else {\n                this.initializersForVariant(variant);\n            }\n            const fields = collectAndMergeFields_1.collectAndMergeFields(variant, this.context.options.mergeInFieldsFromFragmentSpreads).map(field => this.helpers.propertyFromField(field));\n            const fragmentSpreads = variant.fragmentSpreads.map(fragmentSpread => {\n                const isConditional = variant.possibleTypes.some(type => !fragmentSpread.selectionSet.possibleTypes.includes(type));\n                return this.helpers.propertyFromFragmentSpread(fragmentSpread, isConditional);\n            });\n            fields.forEach(this.propertyDeclarationForField, this);\n            if (fragmentSpreads.length > 0) {\n                this.printNewlineIfNeeded();\n                this.printOnNewline(`public var fragments: Fragments`);\n                this.withinBlock(() => {\n                    this.printOnNewline('get');\n                    this.withinBlock(() => {\n                        this.printOnNewline(`return Fragments(snapshot: snapshot)`);\n                    });\n                    this.printOnNewline('set');\n                    this.withinBlock(() => {\n                        this.printOnNewline(`snapshot += newValue.snapshot`);\n                    });\n                });\n                this.structDeclaration({\n                    structName: 'Fragments'\n                }, () => {\n                    this.propertyDeclaration({\n                        propertyName: 'snapshot',\n                        typeName: 'Snapshot'\n                    });\n                    for (const fragmentSpread of fragmentSpreads) {\n                        const { propertyName, typeName, structName, isConditional } = fragmentSpread;\n                        this.printNewlineIfNeeded();\n                        this.printOnNewline(`public var ${language_1.escapeIdentifierIfNeeded(propertyName)}: ${typeName}`);\n                        this.withinBlock(() => {\n                            this.printOnNewline('get');\n                            this.withinBlock(() => {\n                                if (isConditional) {\n                                    this.printOnNewline(`if !${structName}.possibleTypes.contains(snapshot[\"__typename\"]! as! String) { return nil }`);\n                                }\n                                this.printOnNewline(`return ${structName}(snapshot: snapshot)`);\n                            });\n                            this.printOnNewline('set');\n                            this.withinBlock(() => {\n                                if (isConditional) {\n                                    this.printOnNewline(`guard let newValue = newValue else { return }`);\n                                    this.printOnNewline(`snapshot += newValue.snapshot`);\n                                }\n                                else {\n                                    this.printOnNewline(`snapshot += newValue.snapshot`);\n                                }\n                            });\n                        });\n                    }\n                });\n            }\n            for (const field of fields) {\n                if (graphql_1.isCompositeType(graphql_1.getNamedType(field.type)) && field.selectionSet) {\n                    this.structDeclarationForSelectionSet({\n                        structName: field.structName,\n                        selectionSet: field.selectionSet\n                    });\n                }\n            }\n            if (after) {\n                after();\n            }\n        });\n    }\n    initializersForTypeCase(typeCase) {\n        const variants = typeCase.variants;\n        if (variants.length == 0) {\n            this.initializersForVariant(typeCase.default);\n        }\n        else {\n            const remainder = typeCase.remainder;\n            for (const variant of remainder ? [remainder, ...variants] : variants) {\n                this.initializersForVariant(variant, variant === remainder ? undefined : this.helpers.structNameForVariant(variant), false);\n            }\n        }\n    }\n    initializersForVariant(variant, namespace, useInitializerIfPossible = true) {\n        if (useInitializerIfPossible && variant.possibleTypes.length == 1) {\n            const properties = this.helpers.propertiesForSelectionSet(variant);\n            if (!properties)\n                return;\n            this.printNewlineIfNeeded();\n            this.printOnNewline(`public init`);\n            this.parametersForProperties(properties);\n            this.withinBlock(() => {\n                this.printOnNewline(printing_1.wrap(`self.init(snapshot: [`, printing_1.join([\n                    `\"__typename\": \"${variant.possibleTypes[0]}\"`,\n                    ...properties.map(this.propertyAssignmentForField, this)\n                ], ', ') || ':', `])`));\n            });\n        }\n        else {\n            const structName = this.scope.typeName;\n            for (const possibleType of variant.possibleTypes) {\n                const properties = this.helpers.propertiesForSelectionSet({\n                    possibleTypes: [possibleType],\n                    selections: variant.selections\n                }, namespace);\n                if (!properties)\n                    continue;\n                this.printNewlineIfNeeded();\n                this.printOnNewline(`public static func make${possibleType}`);\n                this.parametersForProperties(properties);\n                this.print(` -> ${structName}`);\n                this.withinBlock(() => {\n                    this.printOnNewline(printing_1.wrap(`return ${structName}(snapshot: [`, printing_1.join([\n                        `\"__typename\": \"${possibleType}\"`,\n                        ...properties.map(this.propertyAssignmentForField, this)\n                    ], ', ') || ':', `])`));\n                });\n            }\n        }\n    }\n    propertyAssignmentForField(field) {\n        const { responseKey, propertyName, type } = field;\n        const valueExpression = graphql_1.isCompositeType(graphql_1.getNamedType(type))\n            ? this.helpers.mapExpressionForType(type, identifier => `${identifier}.snapshot`, language_1.escapeIdentifierIfNeeded(propertyName))\n            : language_1.escapeIdentifierIfNeeded(propertyName);\n        return `\"${responseKey}\": ${valueExpression}`;\n    }\n    propertyDeclarationForField(field) {\n        const { responseKey, propertyName, typeName, type, isOptional } = field;\n        const unmodifiedFieldType = graphql_1.getNamedType(type);\n        this.printNewlineIfNeeded();\n        this.comment(field.description);\n        this.deprecationAttributes(field.isDeprecated, field.deprecationReason);\n        this.printOnNewline(`public var ${language_1.escapeIdentifierIfNeeded(propertyName)}: ${typeName}`);\n        this.withinBlock(() => {\n            if (graphql_1.isCompositeType(unmodifiedFieldType)) {\n                const structName = language_1.escapeIdentifierIfNeeded(this.helpers.structNameForPropertyName(propertyName));\n                if (graphql_2.isList(type)) {\n                    this.printOnNewline('get');\n                    this.withinBlock(() => {\n                        const snapshotTypeName = this.helpers.typeNameFromGraphQLType(type, 'Snapshot', false);\n                        let getter;\n                        if (isOptional) {\n                            getter = `return (snapshot[\"${responseKey}\"] as? ${snapshotTypeName})`;\n                        }\n                        else {\n                            getter = `return (snapshot[\"${responseKey}\"] as! ${snapshotTypeName})`;\n                        }\n                        getter += this.helpers.mapExpressionForType(type, identifier => `${structName}(snapshot: ${identifier})`);\n                        this.printOnNewline(getter);\n                    });\n                    this.printOnNewline('set');\n                    this.withinBlock(() => {\n                        let newValueExpression = this.helpers.mapExpressionForType(type, identifier => `${identifier}.snapshot`, 'newValue');\n                        this.printOnNewline(`snapshot.updateValue(${newValueExpression}, forKey: \"${responseKey}\")`);\n                    });\n                }\n                else {\n                    this.printOnNewline('get');\n                    this.withinBlock(() => {\n                        if (isOptional) {\n                            this.printOnNewline(`return (snapshot[\"${responseKey}\"] as? Snapshot).flatMap { ${structName}(snapshot: $0) }`);\n                        }\n                        else {\n                            this.printOnNewline(`return ${structName}(snapshot: snapshot[\"${responseKey}\"]! as! Snapshot)`);\n                        }\n                    });\n                    this.printOnNewline('set');\n                    this.withinBlock(() => {\n                        let newValueExpression;\n                        if (isOptional) {\n                            newValueExpression = 'newValue?.snapshot';\n                        }\n                        else {\n                            newValueExpression = 'newValue.snapshot';\n                        }\n                        this.printOnNewline(`snapshot.updateValue(${newValueExpression}, forKey: \"${responseKey}\")`);\n                    });\n                }\n            }\n            else {\n                this.printOnNewline('get');\n                this.withinBlock(() => {\n                    if (isOptional) {\n                        this.printOnNewline(`return snapshot[\"${responseKey}\"] as? ${typeName.slice(0, -1)}`);\n                    }\n                    else {\n                        this.printOnNewline(`return snapshot[\"${responseKey}\"]! as! ${typeName}`);\n                    }\n                });\n                this.printOnNewline('set');\n                this.withinBlock(() => {\n                    this.printOnNewline(`snapshot.updateValue(newValue, forKey: \"${responseKey}\")`);\n                });\n            }\n        });\n    }\n    propertyDeclarationForVariant(variant) {\n        const { propertyName, typeName, structName } = variant;\n        this.printNewlineIfNeeded();\n        this.printOnNewline(`public var ${language_1.escapeIdentifierIfNeeded(propertyName)}: ${typeName}`);\n        this.withinBlock(() => {\n            this.printOnNewline('get');\n            this.withinBlock(() => {\n                this.printOnNewline(`if !${structName}.possibleTypes.contains(__typename) { return nil }`);\n                this.printOnNewline(`return ${structName}(snapshot: snapshot)`);\n            });\n            this.printOnNewline('set');\n            this.withinBlock(() => {\n                this.printOnNewline(`guard let newValue = newValue else { return }`);\n                this.printOnNewline(`snapshot = newValue.snapshot`);\n            });\n        });\n    }\n    initializerDeclarationForProperties(properties) {\n        this.printOnNewline(`public init`);\n        this.parametersForProperties(properties);\n        this.withinBlock(() => {\n            properties.forEach(({ propertyName }) => {\n                this.printOnNewline(`self.${propertyName} = ${language_1.escapeIdentifierIfNeeded(propertyName)}`);\n            });\n        });\n    }\n    parametersForProperties(properties) {\n        this.print('(');\n        this.print(printing_1.join(properties.map(({ propertyName, typeName, isOptional }) => printing_1.join([`${language_1.escapeIdentifierIfNeeded(propertyName)}: ${typeName}`, isOptional && ' = nil'])), ', '));\n        this.print(')');\n    }\n    typeCaseInitialization(typeCase) {\n        if (typeCase.variants.length < 1) {\n            this.selectionSetInitialization(typeCase.default);\n            return;\n        }\n        this.print('[');\n        this.withIndent(() => {\n            this.printOnNewline(`GraphQLTypeCase(`);\n            this.withIndent(() => {\n                this.printOnNewline(`variants: [`);\n                this.print(typeCase.variants\n                    .flatMap(variant => {\n                    const structName = this.helpers.structNameForVariant(variant);\n                    return variant.possibleTypes.map(type => `\"${type}\": ${structName}.selections`);\n                })\n                    .join(', '));\n                this.print('],');\n                this.printOnNewline(`default: `);\n                this.selectionSetInitialization(typeCase.default);\n            });\n            this.printOnNewline(')');\n        });\n        this.printOnNewline(']');\n    }\n    selectionSetInitialization(selectionSet) {\n        this.print('[');\n        this.withIndent(() => {\n            for (const selection of selectionSet.selections) {\n                switch (selection.kind) {\n                    case 'Field': {\n                        const { name, alias, args, type } = selection;\n                        const responseKey = selection.alias || selection.name;\n                        const structName = this.helpers.structNameForPropertyName(responseKey);\n                        this.printOnNewline(`GraphQLField(`);\n                        this.print(printing_1.join([\n                            `\"${name}\"`,\n                            alias ? `alias: \"${alias}\"` : null,\n                            args &&\n                                args.length &&\n                                `arguments: ${this.helpers.dictionaryLiteralForFieldArguments(args)}`,\n                            `type: ${this.helpers.fieldTypeEnum(type, structName)}`\n                        ], ', '));\n                        this.print('),');\n                        break;\n                    }\n                    case 'BooleanCondition':\n                        this.printOnNewline(`GraphQLBooleanCondition(`);\n                        this.print(printing_1.join([\n                            `variableName: \"${selection.variableName}\"`,\n                            `inverted: ${selection.inverted}`,\n                            'selections: '\n                        ], ', '));\n                        this.selectionSetInitialization(selection.selectionSet);\n                        this.print('),');\n                        break;\n                    case 'TypeCondition': {\n                        this.printOnNewline(`GraphQLTypeCondition(`);\n                        this.print(printing_1.join([\n                            `possibleTypes: [${printing_1.join(selection.selectionSet.possibleTypes.map(type => `\"${type.name}\"`), ', ')}]`,\n                            'selections: '\n                        ], ', '));\n                        this.selectionSetInitialization(selection.selectionSet);\n                        this.print('),');\n                        break;\n                    }\n                    case 'FragmentSpread': {\n                        const structName = this.helpers.structNameForFragmentName(selection.fragmentName);\n                        this.printOnNewline(`GraphQLFragmentSpread(${structName}.self),`);\n                        break;\n                    }\n                }\n            }\n        });\n        this.printOnNewline(']');\n    }\n    typeDeclarationForGraphQLType(type) {\n        if (type instanceof graphql_1.GraphQLEnumType) {\n            this.enumerationDeclaration(type);\n        }\n        else if (type instanceof graphql_1.GraphQLInputObjectType) {\n            this.structDeclarationForInputObjectType(type);\n        }\n    }\n    enumerationDeclaration(type) {\n        const { name, description } = type;\n        const values = type.getValues();\n        this.printNewlineIfNeeded();\n        this.comment(description || undefined);\n        this.printOnNewline(`public enum ${name}: RawRepresentable, Equatable, JSONDecodable, JSONEncodable`);\n        this.withinBlock(() => {\n            this.printOnNewline('public typealias RawValue = String');\n            values.forEach(value => {\n                this.comment(value.description || undefined);\n                this.deprecationAttributes(value.isDeprecated, value.deprecationReason || undefined);\n                this.printOnNewline(`case ${language_1.escapeIdentifierIfNeeded(this.helpers.enumCaseName(value.name))}`);\n            });\n            this.comment('Auto generated constant for unknown enum values');\n            this.printOnNewline('case unknown(RawValue)');\n            this.printNewlineIfNeeded();\n            this.printOnNewline('public init?(rawValue: RawValue)');\n            this.withinBlock(() => {\n                this.printOnNewline('switch rawValue');\n                this.withinBlock(() => {\n                    values.forEach(value => {\n                        this.printOnNewline(`case \"${value.value}\": self = ${language_1.escapeIdentifierIfNeeded(this.helpers.enumDotCaseName(value.name))}`);\n                    });\n                    this.printOnNewline(`default: self = .unknown(rawValue)`);\n                });\n            });\n            this.printNewlineIfNeeded();\n            this.printOnNewline('public var rawValue: RawValue');\n            this.withinBlock(() => {\n                this.printOnNewline('switch self');\n                this.withinBlock(() => {\n                    values.forEach(value => {\n                        this.printOnNewline(`case ${language_1.escapeIdentifierIfNeeded(this.helpers.enumDotCaseName(value.name))}: return \"${value.value}\"`);\n                    });\n                    this.printOnNewline(`case .unknown(let value): return value`);\n                });\n            });\n            this.printNewlineIfNeeded();\n            this.printOnNewline(`public static func == (lhs: ${name}, rhs: ${name}) -> Bool`);\n            this.withinBlock(() => {\n                this.printOnNewline('switch (lhs, rhs)');\n                this.withinBlock(() => {\n                    values.forEach(value => {\n                        const enumDotCaseName = language_1.escapeIdentifierIfNeeded(this.helpers.enumDotCaseName(value.name));\n                        const tuple = `(${enumDotCaseName}, ${enumDotCaseName})`;\n                        this.printOnNewline(`case ${tuple}: return true`);\n                    });\n                    this.printOnNewline(`case (.unknown(let lhsValue), .unknown(let rhsValue)): return lhsValue == rhsValue`);\n                    this.printOnNewline(`default: return false`);\n                });\n            });\n        });\n    }\n    structDeclarationForInputObjectType(type) {\n        const { name: structName, description } = type;\n        const adoptedProtocols = ['GraphQLMapConvertible'];\n        const fields = Object.values(type.getFields());\n        let properties = fields.map(this.helpers.propertyFromInputField, this.helpers);\n        if (complextypes_1.isS3Field(type)) {\n            properties = [\n                ...properties,\n                {\n                    propertyName: 'localUri',\n                    name: 'localUri',\n                    typeName: 'String',\n                    isOptional: false,\n                    description: '',\n                },\n                {\n                    propertyName: 'mimeType',\n                    name: 'mimeType',\n                    typeName: 'String',\n                    isOptional: false,\n                    description: '',\n                },\n            ];\n        }\n        this.structDeclaration({ structName, description: description || undefined, adoptedProtocols }, () => {\n            this.printOnNewline(`public var graphQLMap: GraphQLMap`);\n            this.printNewlineIfNeeded();\n            this.printOnNewline(`public init`);\n            this.print('(');\n            this.print(printing_1.join(properties.map(({ propertyName, typeName, isOptional }) => printing_1.join([\n                `${language_1.escapeIdentifierIfNeeded(propertyName)}: ${typeName}`,\n                isOptional && ' = nil'\n            ])), ', '));\n            this.print(')');\n            this.withinBlock(() => {\n                this.printOnNewline(printing_1.wrap(`graphQLMap = [`, printing_1.join(properties.map(({ name, propertyName }) => `\"${name}\": ${language_1.escapeIdentifierIfNeeded(propertyName)}`), ', ') || ':', `]`));\n            });\n            for (const { propertyName, typeName, description } of properties) {\n                this.printNewlineIfNeeded();\n                this.comment(description || undefined);\n                this.printOnNewline(`public var ${language_1.escapeIdentifierIfNeeded(propertyName)}: ${typeName}`);\n                this.withinBlock(() => {\n                    this.printOnNewline('get');\n                    this.withinBlock(() => {\n                        this.printOnNewline(`return graphQLMap[\"${propertyName}\"] as! ${typeName}`);\n                    });\n                    this.printOnNewline('set');\n                    this.withinBlock(() => {\n                        this.printOnNewline(`graphQLMap.updateValue(newValue, forKey: \"${propertyName}\")`);\n                    });\n                });\n            }\n        });\n    }\n}\nexports.SwiftAPIGenerator = SwiftAPIGenerator;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29kZUdlbmVyYXRpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb2RlR2VuZXJhdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLDZCQUE2QjtBQUU3QixxQ0FTaUI7QUFJakIsb0RBQW1EO0FBRW5ELHlDQUF3RjtBQUN4Rix1Q0FBb0M7QUFDcEMsMkNBQTRDO0FBQzVDLGtEQUE4QztBQUU5Qyw0REFBMkY7QUFDM0YsZ0dBQTZGO0FBQzdGLGtGQUErRTtBQUMvRSxzRkFBbUY7QUFFbkYsOEJBQTRCO0FBQzVCLDREQUFzRDtBQVF0RCx3QkFDRSxPQUF3QixFQUN4QixxQkFBOEIsRUFDOUIsSUFBYTtJQUViLE1BQU0sU0FBUyxHQUFHLElBQUksaUJBQWlCLENBQUMsT0FBTyxDQUFDLENBQUM7SUFFakQsSUFBSSxxQkFBcUIsRUFBRTtRQUN6QixTQUFTLENBQUMsVUFBVSxDQUFDLHFCQUFxQixFQUFFLEdBQUcsRUFBRTtZQUMvQyxTQUFTLENBQUMsVUFBVSxFQUFFLENBQUM7WUFFdkIsU0FBUyxDQUFDLG9CQUFvQixDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLEdBQUcsRUFBRTtnQkFDN0QsT0FBTyxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUU7b0JBQy9CLFNBQVMsQ0FBQyw2QkFBNkIsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDaEQsQ0FBQyxDQUFDLENBQUM7WUFDTCxDQUFDLENBQUMsQ0FBQztZQUVILElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUU7Z0JBQ2hDLFNBQVMsQ0FBQyxjQUFjLENBQUMsS0FBSyx5QkFBYSxFQUFFLENBQUMsQ0FBQzthQUNoRDtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsTUFBTSxjQUFjLEdBQUcsSUFBSSxHQUFHLEVBQVUsQ0FBQztRQUV6QyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxPQUFPLENB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LElBQUksRUFBRSxZQUFZLEVBQUUsRUFBRSxFQUFFLENBQUMsSUFBSSxJQUFJLE1BQU0sbUNBQXdCLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FDbkYsRUFDRCxJQUFJLENBQ0wsSUFBSSxHQUFHLEVBQ1IsR0FBRyxDQUNKLENBQ0YsQ0FBQztZQUNKLENBQUMsQ0FBQyxDQUFDO1lBRUgsS0FBSyxNQUFNLEVBQUUsWUFBWSxFQUFFLFFBQVEsRUFBRSxXQUFXLEVBQUUsSUFBSSxVQUFVLEVBQUU7Z0JBQ2hFLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO2dCQUM1QixJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsSUFBSSxTQUFTLENBQUMsQ0FBQztnQkFDdkMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxjQUFjLG1DQUF3QixDQUFDLFlBQVksQ0FBQyxLQUFLLFFBQVEsRUFBRSxDQUFDLENBQUM7Z0JBQ3pGLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxFQUFFO29CQUNwQixJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUMzQixJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsRUFBRTt3QkFDcEIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxzQkFBc0IsWUFBWSxVQUFVLFFBQVEsRUFBRSxDQUFDLENBQUM7b0JBQzlFLENBQUMsQ0FBQyxDQUFDO29CQUNILElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQzNCLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxFQUFFO3dCQUNwQixJQUFJLENBQUMsY0FBYyxDQUFDLDZDQUE2QyxZQUFZLElBQUksQ0FBQyxDQUFDO29CQUNyRixDQUFDLENBQUMsQ0FBQztnQkFDTCxDQUFDLENBQUMsQ0FBQzthQUNKO1FBQ0gsQ0FBQyxDQUNGLENBQUM7SUFDSixDQUFDO0NBQ0Y7QUFuekJELDhDQW16QkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQge1xuICBHcmFwaFFMRXJyb3IsXG4gIEdyYXBoUUxUeXBlLFxuICBnZXROYW1lZFR5cGUsXG4gIGlzQ29tcG9zaXRlVHlwZSxcbiAgR3JhcGhRTEVudW1UeXBlLFxuICBpc05vbk51bGxUeXBlLFxuICBpc0xpc3RUeXBlLFxuICBHcmFwaFFMSW5wdXRPYmplY3RUeXBlXG59IGZyb20gJ2dyYXBocWwnO1xuXG5pbXBvcnQgeyBDb21waWxlckNvbnRleHQsIE9wZXJhdGlvbiwgRnJhZ21lbnQsIFNlbGVjdGlvblNldCwgRmllbGQgfSBmcm9tICcuLi9jb21waWxlcic7XG5cbmltcG9ydCB7IGpvaW4sIHdyYXAgfSBmcm9tICcuLi91dGlsaXRpZXMvcHJpbnRpbmcnO1xuXG5pbXBvcnQgeyBTd2lmdEdlbmVyYXRvciwgUHJvcGVydHksIGVzY2FwZUlkZW50aWZpZXJJZk5lZWRlZCwgU3RydWN0IH0gZnJvbSAnLi9sYW5ndWFnZSc7XG5pbXBvcnQgeyBIZWxwZXJzIH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7IHMzV3JhcHBlckNvZGUgfSBmcm9tICcuL3MzV3JhcHBlcic7XG5pbXBvcnQgeyBpc0xpc3QgfSBmcm9tICcuLi91dGlsaXRpZXMvZ3JhcGhxbCc7XG5cbmltcG9ydCB7IHR5cGVDYXNlRm9yU2VsZWN0aW9uU2V0LCBUeXBlQ2FzZSwgVmFyaWFudCB9IGZyb20gJy4uL2NvbXBpbGVyL3Zpc2l0b3JzL3R5cGVDYXNlJztcbmltcG9ydCB7IGNvbGxlY3RGcmFnbWVudHNSZWZlcmVuY2VkIH0gZnJvbSAnLi4vY29tcGlsZXIvdmlzaXRvcnMvY29sbGVjdEZyYWdtZW50c1JlZmVyZW5jZWQnO1xuaW1wb3J0IHsgZ2VuZXJhdGVPcGVyYXRpb25JZCB9IGZyb20gJy4uL2NvbXBpbGVyL3Zpc2l0b3JzL2dlbmVyYXRlT3BlcmF0aW9uSWQnO1xuaW1wb3J0IHsgY29sbGVjdEFuZE1lcmdlRmllbGRzIH0gZnJvbSAnLi4vY29tcGlsZXIvdmlzaXRvcnMvY29sbGVjdEFuZE1lcmdlRmllbGRzJztcblxuaW1wb3J0ICcuLi91dGlsaXRpZXMvYXJyYXknO1xuaW1wb3J0IHsgaXNTM0ZpZWxkIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2NvbXBsZXh0eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9ucyB7XG4gIG5hbWVzcGFjZT86IHN0cmluZztcbiAgcGFzc3Rocm91Z2hDdXN0b21TY2FsYXJzPzogYm9vbGVhbjtcbiAgY3VzdG9tU2NhbGFyc1ByZWZpeD86IHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlU291cmNlKFxuICBjb250ZXh0OiBDb21waWxlckNvbnRleHQsXG4gIG91dHB1dEluZGl2aWR1YWxGaWxlczogYm9vbGVhbixcbiAgb25seT86IHN0cmluZ1xuKTogU3dpZnRBUElHZW5lcmF0b3Ige1xuICBjb25zdCBnZW5lcmF0b3IgPSBuZXcgU3dpZnRBUElHZW5lcmF0b3IoY29udGV4dCk7XG5cbiAgaWYgKG91dHB1dEluZGl2aWR1YWxGaWxlcykge1xuICAgIGdlbmVyYXRvci53aXRoaW5GaWxlKGBUeXBlcy5ncmFwaHFsLnN3aWZ0YCwgKCkgPT4ge1xuICAgICAgZ2VuZXJhdG9yLmZpbGVIZWFkZXIoKTtcblxuICAgICAgZ2VuZXJhdG9yLm5hbWVzcGFjZURlY2xhcmF0aW9uKGNvbnRleHQub3B0aW9ucy5uYW1lc3BhY2UsICgpID0+IHtcbiAgICAgICAgY29udGV4dC50eXBlc1VzZWQuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgICAgICBnZW5lcmF0b3IudHlwZURlY2xhcmF0aW9uRm9yR3JhcGhRTFR5cGUodHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChjb250ZXh0Lm9wdGlvbnMuYWRkUzNXcmFwcGVyKSB7XG4gICAgICAgIGdlbmVyYXRvci5wcmludE9uTmV3bGluZShgXFxuJHtzM1dyYXBwZXJDb2RlfWApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgaW5wdXRGaWxlUGF0aHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAgIE9iamVjdC52YWx1ZXMoY29udGV4dC5vcGVyYXRpb25zKS5mb3JFYWNoKG9wZXJhdGlvbiA9PiB7XG4gICAgICBpbnB1dEZpbGVQYXRocy5hZGQob3BlcmF0aW9uLmZpbGVQYXRoKTtcbiAgICB9KTtcblxuICAgIE9iamVjdC52YWx1ZXMoY29udGV4dC5mcmFnbWVudHMpLmZvckVhY2goZnJhZ21lbnQgPT4ge1xuICAgICAgaW5wdXRGaWxlUGF0aHMuYWRkKGZyYWdtZW50LmZpbGVQYXRoKTtcbiAgICB9KTtcblxuICAgIGZvciAoY29uc3QgaW5wdXRGaWxlUGF0aCBvZiBpbnB1dEZpbGVQYXRocykge1xuICAgICAgaWYgKG9ubHkgJiYgaW5wdXRGaWxlUGF0aCAhPT0gb25seSkgY29udGludWU7XG5cbiAgICAgIGdlbmVyYXRvci53aXRoaW5GaWxlKGAke3BhdGguYmFzZW5hbWUoaW5wdXRGaWxlUGF0aCl9LnN3aWZ0YCwgKCkgPT4ge1xuICAgICAgICBnZW5lcmF0b3IuZmlsZUhlYWRlcigpO1xuXG4gICAgICAgIGdlbmVyYXRvci5uYW1lc3BhY2VFeHRlbnNpb25EZWNsYXJhdGlvbihjb250ZXh0Lm9wdGlvbnMubmFtZXNwYWNlLCAoKSA9PiB7XG4gICAgICAgICAgT2JqZWN0LnZhbHVlcyhjb250ZXh0Lm9wZXJhdGlvbnMpLmZvckVhY2gob3BlcmF0aW9uID0+IHtcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24uZmlsZVBhdGggPT09IGlucHV0RmlsZVBhdGgpIHtcbiAgICAgICAgICAgICAgZ2VuZXJhdG9yLmNsYXNzRGVjbGFyYXRpb25Gb3JPcGVyYXRpb24ob3BlcmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIE9iamVjdC52YWx1ZXMoY29udGV4dC5mcmFnbWVudHMpLmZvckVhY2goZnJhZ21lbnQgPT4ge1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50LmZpbGVQYXRoID09PSBpbnB1dEZpbGVQYXRoKSB7XG4gICAgICAgICAgICAgIGdlbmVyYXRvci5zdHJ1Y3REZWNsYXJhdGlvbkZvckZyYWdtZW50KGZyYWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZ2VuZXJhdG9yLmZpbGVIZWFkZXIoKTtcblxuICAgIGdlbmVyYXRvci5uYW1lc3BhY2VEZWNsYXJhdGlvbihjb250ZXh0Lm9wdGlvbnMubmFtZXNwYWNlLCAoKSA9PiB7XG4gICAgICBjb250ZXh0LnR5cGVzVXNlZC5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgICBnZW5lcmF0b3IudHlwZURlY2xhcmF0aW9uRm9yR3JhcGhRTFR5cGUodHlwZSk7XG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LnZhbHVlcyhjb250ZXh0Lm9wZXJhdGlvbnMpLmZvckVhY2gob3BlcmF0aW9uID0+IHtcbiAgICAgICAgZ2VuZXJhdG9yLmNsYXNzRGVjbGFyYXRpb25Gb3JPcGVyYXRpb24ob3BlcmF0aW9uKTtcbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QudmFsdWVzKGNvbnRleHQuZnJhZ21lbnRzKS5mb3JFYWNoKGZyYWdtZW50ID0+IHtcbiAgICAgICAgZ2VuZXJhdG9yLnN0cnVjdERlY2xhcmF0aW9uRm9yRnJhZ21lbnQoZnJhZ21lbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAoY29udGV4dC5vcHRpb25zLmFkZFMzV3JhcHBlcikge1xuICAgICAgZ2VuZXJhdG9yLnByaW50T25OZXdsaW5lKGBcXG4ke3MzV3JhcHBlckNvZGV9YCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdlbmVyYXRvcjtcbn1cblxuZXhwb3J0IGNsYXNzIFN3aWZ0QVBJR2VuZXJhdG9yIGV4dGVuZHMgU3dpZnRHZW5lcmF0b3I8Q29tcGlsZXJDb250ZXh0PiB7XG4gIGhlbHBlcnM6IEhlbHBlcnM7XG5cbiAgY29uc3RydWN0b3IoY29udGV4dDogQ29tcGlsZXJDb250ZXh0KSB7XG4gICAgc3VwZXIoY29udGV4dCk7XG5cbiAgICB0aGlzLmhlbHBlcnMgPSBuZXcgSGVscGVycyhjb250ZXh0Lm9wdGlvbnMpO1xuICB9XG5cbiAgZmlsZUhlYWRlcigpIHtcbiAgICB0aGlzLnByaW50T25OZXdsaW5lKCcvLyAgVGhpcyBmaWxlIHdhcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBhbmQgc2hvdWxkIG5vdCBiZSBlZGl0ZWQuJyk7XG4gICAgdGhpcy5wcmludE5ld2xpbmUoKTtcbiAgICB0aGlzLnByaW50T25OZXdsaW5lKCdpbXBvcnQgQVdTQXBwU3luYycpO1xuICB9XG5cbiAgY2xhc3NEZWNsYXJhdGlvbkZvck9wZXJhdGlvbihvcGVyYXRpb246IE9wZXJhdGlvbikge1xuICAgIGNvbnN0IHsgb3BlcmF0aW9uTmFtZSwgb3BlcmF0aW9uVHlwZSwgdmFyaWFibGVzLCBzb3VyY2UsIHNlbGVjdGlvblNldCB9ID0gb3BlcmF0aW9uO1xuXG4gICAgbGV0IGNsYXNzTmFtZTtcbiAgICBsZXQgcHJvdG9jb2w7XG5cbiAgICBzd2l0Y2ggKG9wZXJhdGlvblR5cGUpIHtcbiAgICAgIGNhc2UgJ3F1ZXJ5JzpcbiAgICAgICAgY2xhc3NOYW1lID0gYCR7dGhpcy5oZWxwZXJzLm9wZXJhdGlvbkNsYXNzTmFtZShvcGVyYXRpb25OYW1lKX1RdWVyeWA7XG4gICAgICAgIHByb3RvY29sID0gJ0dyYXBoUUxRdWVyeSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbXV0YXRpb24nOlxuICAgICAgICBjbGFzc05hbWUgPSBgJHt0aGlzLmhlbHBlcnMub3BlcmF0aW9uQ2xhc3NOYW1lKG9wZXJhdGlvbk5hbWUpfU11dGF0aW9uYDtcbiAgICAgICAgcHJvdG9jb2wgPSAnR3JhcGhRTE11dGF0aW9uJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdWJzY3JpcHRpb24nOlxuICAgICAgICBjbGFzc05hbWUgPSBgJHt0aGlzLmhlbHBlcnMub3BlcmF0aW9uQ2xhc3NOYW1lKG9wZXJhdGlvbk5hbWUpfVN1YnNjcmlwdGlvbmA7XG4gICAgICAgIHByb3RvY29sID0gJ0dyYXBoUUxTdWJzY3JpcHRpb24nO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoYFVuc3VwcG9ydGVkIG9wZXJhdGlvbiB0eXBlIFwiJHtvcGVyYXRpb25UeXBlfVwiYCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGFzc0RlY2xhcmF0aW9uKFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIG1vZGlmaWVyczogWydwdWJsaWMnLCAnZmluYWwnXSxcbiAgICAgICAgYWRvcHRlZFByb3RvY29sczogW3Byb3RvY29sXVxuICAgICAgfSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoJ3B1YmxpYyBzdGF0aWMgbGV0IG9wZXJhdGlvblN0cmluZyA9Jyk7XG4gICAgICAgICAgdGhpcy53aXRoSW5kZW50KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubXVsdGlsaW5lU3RyaW5nKHNvdXJjZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmcmFnbWVudHNSZWZlcmVuY2VkID0gY29sbGVjdEZyYWdtZW50c1JlZmVyZW5jZWQoXG4gICAgICAgICAgb3BlcmF0aW9uLnNlbGVjdGlvblNldCxcbiAgICAgICAgICB0aGlzLmNvbnRleHQuZnJhZ21lbnRzXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5vcHRpb25zLmdlbmVyYXRlT3BlcmF0aW9uSWRzKSB7XG4gICAgICAgICAgY29uc3QgeyBvcGVyYXRpb25JZCB9ID0gZ2VuZXJhdGVPcGVyYXRpb25JZChcbiAgICAgICAgICAgIG9wZXJhdGlvbixcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5mcmFnbWVudHMsXG4gICAgICAgICAgICBmcmFnbWVudHNSZWZlcmVuY2VkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBvcGVyYXRpb24ub3BlcmF0aW9uSWQgPSBvcGVyYXRpb25JZDtcbiAgICAgICAgICB0aGlzLnByaW50TmV3bGluZUlmTmVlZGVkKCk7XG4gICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgcHVibGljIHN0YXRpYyBsZXQgb3BlcmF0aW9uSWRlbnRpZmllcjogU3RyaW5nPyA9IFwiJHtvcGVyYXRpb25JZH1cImApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZyYWdtZW50c1JlZmVyZW5jZWQuc2l6ZSA+IDApIHtcbiAgICAgICAgICB0aGlzLnByaW50TmV3bGluZUlmTmVlZGVkKCk7XG4gICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZSgncHVibGljIHN0YXRpYyB2YXIgcmVxdWVzdFN0cmluZzogU3RyaW5nIHsgcmV0dXJuIG9wZXJhdGlvblN0cmluZycpO1xuICAgICAgICAgIGZyYWdtZW50c1JlZmVyZW5jZWQuZm9yRWFjaChmcmFnbWVudE5hbWUgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcmludChcbiAgICAgICAgICAgICAgYC5hcHBlbmRpbmcoJHt0aGlzLmhlbHBlcnMuc3RydWN0TmFtZUZvckZyYWdtZW50TmFtZShmcmFnbWVudE5hbWUpfS5mcmFnbWVudFN0cmluZylgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMucHJpbnQoJyB9Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByaW50TmV3bGluZUlmTmVlZGVkKCk7XG5cbiAgICAgICAgaWYgKHZhcmlhYmxlcyAmJiB2YXJpYWJsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB2YXJpYWJsZXMubWFwKCh7IG5hbWUsIHR5cGUgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHlwZU5hbWUgPSB0aGlzLmhlbHBlcnMudHlwZU5hbWVGcm9tR3JhcGhRTFR5cGUodHlwZSk7XG4gICAgICAgICAgICBjb25zdCBpc09wdGlvbmFsID0gIShcbiAgICAgICAgICAgICAgaXNOb25OdWxsVHlwZSh0eXBlKSB8fFxuICAgICAgICAgICAgICAoaXNMaXN0VHlwZSh0eXBlKSAmJiBpc05vbk51bGxUeXBlKHR5cGUub2ZUeXBlKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lLCBwcm9wZXJ0eU5hbWU6IG5hbWUsIHR5cGUsIHR5cGVOYW1lLCBpc09wdGlvbmFsIH07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aGlzLnByb3BlcnR5RGVjbGFyYXRpb25zKHByb3BlcnRpZXMpO1xuXG4gICAgICAgICAgdGhpcy5wcmludE5ld2xpbmVJZk5lZWRlZCgpO1xuICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZXJEZWNsYXJhdGlvbkZvclByb3BlcnRpZXMocHJvcGVydGllcyk7XG5cbiAgICAgICAgICB0aGlzLnByaW50TmV3bGluZUlmTmVlZGVkKCk7XG4gICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgcHVibGljIHZhciB2YXJpYWJsZXM6IEdyYXBoUUxNYXA/YCk7XG4gICAgICAgICAgdGhpcy53aXRoaW5CbG9jaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKFxuICAgICAgICAgICAgICB3cmFwKFxuICAgICAgICAgICAgICAgIGByZXR1cm4gW2AsXG4gICAgICAgICAgICAgICAgam9pbihcbiAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMubWFwKFxuICAgICAgICAgICAgICAgICAgICAoeyBuYW1lLCBwcm9wZXJ0eU5hbWUgfSkgPT5cbiAgICAgICAgICAgICAgICAgICAgICBgXCIke25hbWV9XCI6ICR7ZXNjYXBlSWRlbnRpZmllcklmTmVlZGVkKHByb3BlcnR5TmFtZSl9YFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICcsICdcbiAgICAgICAgICAgICAgICApIHx8ICc6JyxcbiAgICAgICAgICAgICAgICBgXWBcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmluaXRpYWxpemVyRGVjbGFyYXRpb25Gb3JQcm9wZXJ0aWVzKFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RydWN0RGVjbGFyYXRpb25Gb3JTZWxlY3Rpb25TZXQoe1xuICAgICAgICAgIHN0cnVjdE5hbWU6ICdEYXRhJyxcbiAgICAgICAgICBzZWxlY3Rpb25TZXRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIHN0cnVjdERlY2xhcmF0aW9uRm9yRnJhZ21lbnQoeyBmcmFnbWVudE5hbWUsIHNlbGVjdGlvblNldCwgc291cmNlIH06IEZyYWdtZW50KSB7XG4gICAgY29uc3Qgc3RydWN0TmFtZSA9IHRoaXMuaGVscGVycy5zdHJ1Y3ROYW1lRm9yRnJhZ21lbnROYW1lKGZyYWdtZW50TmFtZSk7XG5cbiAgICB0aGlzLnN0cnVjdERlY2xhcmF0aW9uRm9yU2VsZWN0aW9uU2V0KFxuICAgICAge1xuICAgICAgICBzdHJ1Y3ROYW1lLFxuICAgICAgICBhZG9wdGVkUHJvdG9jb2xzOiBbJ0dyYXBoUUxGcmFnbWVudCddLFxuICAgICAgICBzZWxlY3Rpb25TZXRcbiAgICAgIH0sXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKCdwdWJsaWMgc3RhdGljIGxldCBmcmFnbWVudFN0cmluZyA9Jyk7XG4gICAgICAgICAgdGhpcy53aXRoSW5kZW50KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubXVsdGlsaW5lU3RyaW5nKHNvdXJjZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgc3RydWN0RGVjbGFyYXRpb25Gb3JTZWxlY3Rpb25TZXQoXG4gICAge1xuICAgICAgc3RydWN0TmFtZSxcbiAgICAgIGFkb3B0ZWRQcm90b2NvbHMgPSBbJ0dyYXBoUUxTZWxlY3Rpb25TZXQnXSxcbiAgICAgIHNlbGVjdGlvblNldFxuICAgIH06IHtcbiAgICAgIHN0cnVjdE5hbWU6IHN0cmluZztcbiAgICAgIGFkb3B0ZWRQcm90b2NvbHM/OiBzdHJpbmdbXTtcbiAgICAgIHNlbGVjdGlvblNldDogU2VsZWN0aW9uU2V0O1xuICAgIH0sXG4gICAgYmVmb3JlPzogRnVuY3Rpb25cbiAgKSB7XG4gICAgY29uc3QgdHlwZUNhc2UgPSB0eXBlQ2FzZUZvclNlbGVjdGlvblNldChcbiAgICAgIHNlbGVjdGlvblNldCxcbiAgICAgIHRoaXMuY29udGV4dC5vcHRpb25zLm1lcmdlSW5GaWVsZHNGcm9tRnJhZ21lbnRTcHJlYWRzXG4gICAgKTtcblxuICAgIHRoaXMuc3RydWN0RGVjbGFyYXRpb25Gb3JWYXJpYW50KFxuICAgICAge1xuICAgICAgICBzdHJ1Y3ROYW1lLFxuICAgICAgICBhZG9wdGVkUHJvdG9jb2xzLFxuICAgICAgICB2YXJpYW50OiB0eXBlQ2FzZS5kZWZhdWx0LFxuICAgICAgICB0eXBlQ2FzZVxuICAgICAgfSxcbiAgICAgIGJlZm9yZSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgY29uc3QgdmFyaWFudHMgPSB0eXBlQ2FzZS52YXJpYW50cy5tYXAodGhpcy5oZWxwZXJzLnByb3BlcnR5RnJvbVZhcmlhbnQsIHRoaXMuaGVscGVycyk7XG5cbiAgICAgICAgZm9yIChjb25zdCB2YXJpYW50IG9mIHZhcmlhbnRzKSB7XG4gICAgICAgICAgdGhpcy5wcm9wZXJ0eURlY2xhcmF0aW9uRm9yVmFyaWFudCh2YXJpYW50KTtcblxuICAgICAgICAgIHRoaXMuc3RydWN0RGVjbGFyYXRpb25Gb3JWYXJpYW50KHtcbiAgICAgICAgICAgIHN0cnVjdE5hbWU6IHZhcmlhbnQuc3RydWN0TmFtZSxcbiAgICAgICAgICAgIHZhcmlhbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH1cblxuICBzdHJ1Y3REZWNsYXJhdGlvbkZvclZhcmlhbnQoXG4gICAge1xuICAgICAgc3RydWN0TmFtZSxcbiAgICAgIGFkb3B0ZWRQcm90b2NvbHMgPSBbJ0dyYXBoUUxTZWxlY3Rpb25TZXQnXSxcbiAgICAgIHZhcmlhbnQsXG4gICAgICB0eXBlQ2FzZVxuICAgIH06IHtcbiAgICAgIHN0cnVjdE5hbWU6IHN0cmluZztcbiAgICAgIGFkb3B0ZWRQcm90b2NvbHM/OiBzdHJpbmdbXTtcbiAgICAgIHZhcmlhbnQ6IFZhcmlhbnQ7XG4gICAgICB0eXBlQ2FzZT86IFR5cGVDYXNlO1xuICAgIH0sXG4gICAgYmVmb3JlPzogRnVuY3Rpb24sXG4gICAgYWZ0ZXI/OiBGdW5jdGlvblxuICApIHtcbiAgICB0aGlzLnN0cnVjdERlY2xhcmF0aW9uKHsgc3RydWN0TmFtZSwgYWRvcHRlZFByb3RvY29scyB9LCAoKSA9PiB7XG4gICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgIGJlZm9yZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByaW50TmV3bGluZUlmTmVlZGVkKCk7XG4gICAgICB0aGlzLnByaW50T25OZXdsaW5lKCdwdWJsaWMgc3RhdGljIGxldCBwb3NzaWJsZVR5cGVzID0gWycpO1xuICAgICAgdGhpcy5wcmludChqb2luKHZhcmlhbnQucG9zc2libGVUeXBlcy5tYXAodHlwZSA9PiBgXCIke3R5cGUubmFtZX1cImApLCAnLCAnKSk7XG4gICAgICB0aGlzLnByaW50KCddJyk7XG5cbiAgICAgIHRoaXMucHJpbnROZXdsaW5lSWZOZWVkZWQoKTtcbiAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoJ3B1YmxpYyBzdGF0aWMgbGV0IHNlbGVjdGlvbnM6IFtHcmFwaFFMU2VsZWN0aW9uXSA9ICcpO1xuICAgICAgaWYgKHR5cGVDYXNlKSB7XG4gICAgICAgIHRoaXMudHlwZUNhc2VJbml0aWFsaXphdGlvbih0eXBlQ2FzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNldEluaXRpYWxpemF0aW9uKHZhcmlhbnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByaW50TmV3bGluZUlmTmVlZGVkKCk7XG5cbiAgICAgIHRoaXMucHJvcGVydHlEZWNsYXJhdGlvbih7XG4gICAgICAgIHByb3BlcnR5TmFtZTogJ3NuYXBzaG90JyxcbiAgICAgICAgdHlwZU5hbWU6ICdTbmFwc2hvdCdcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnByaW50TmV3bGluZUlmTmVlZGVkKCk7XG4gICAgICB0aGlzLnByaW50T25OZXdsaW5lKCdwdWJsaWMgaW5pdChzbmFwc2hvdDogU25hcHNob3QpJyk7XG4gICAgICB0aGlzLndpdGhpbkJsb2NrKCgpID0+IHtcbiAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgc2VsZi5zbmFwc2hvdCA9IHNuYXBzaG90YCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVDYXNlKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZXJzRm9yVHlwZUNhc2UodHlwZUNhc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplcnNGb3JWYXJpYW50KHZhcmlhbnQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmaWVsZHMgPSBjb2xsZWN0QW5kTWVyZ2VGaWVsZHMoXG4gICAgICAgIHZhcmlhbnQsXG4gICAgICAgIHRoaXMuY29udGV4dC5vcHRpb25zLm1lcmdlSW5GaWVsZHNGcm9tRnJhZ21lbnRTcHJlYWRzXG4gICAgICApLm1hcChmaWVsZCA9PiB0aGlzLmhlbHBlcnMucHJvcGVydHlGcm9tRmllbGQoZmllbGQgYXMgRmllbGQpKTtcblxuICAgICAgY29uc3QgZnJhZ21lbnRTcHJlYWRzID0gdmFyaWFudC5mcmFnbWVudFNwcmVhZHMubWFwKGZyYWdtZW50U3ByZWFkID0+IHtcbiAgICAgICAgY29uc3QgaXNDb25kaXRpb25hbCA9IHZhcmlhbnQucG9zc2libGVUeXBlcy5zb21lKFxuICAgICAgICAgIHR5cGUgPT4gIWZyYWdtZW50U3ByZWFkLnNlbGVjdGlvblNldC5wb3NzaWJsZVR5cGVzLmluY2x1ZGVzKHR5cGUpXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaGVscGVycy5wcm9wZXJ0eUZyb21GcmFnbWVudFNwcmVhZChmcmFnbWVudFNwcmVhZCwgaXNDb25kaXRpb25hbCk7XG4gICAgICB9KTtcblxuICAgICAgZmllbGRzLmZvckVhY2godGhpcy5wcm9wZXJ0eURlY2xhcmF0aW9uRm9yRmllbGQsIHRoaXMpO1xuXG4gICAgICBpZiAoZnJhZ21lbnRTcHJlYWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5wcmludE5ld2xpbmVJZk5lZWRlZCgpO1xuICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKGBwdWJsaWMgdmFyIGZyYWdtZW50czogRnJhZ21lbnRzYCk7XG4gICAgICAgIHRoaXMud2l0aGluQmxvY2soKCkgPT4ge1xuICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoJ2dldCcpO1xuICAgICAgICAgIHRoaXMud2l0aGluQmxvY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgcmV0dXJuIEZyYWdtZW50cyhzbmFwc2hvdDogc25hcHNob3QpYCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZSgnc2V0Jyk7XG4gICAgICAgICAgdGhpcy53aXRoaW5CbG9jaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKGBzbmFwc2hvdCArPSBuZXdWYWx1ZS5zbmFwc2hvdGApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnN0cnVjdERlY2xhcmF0aW9uKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0cnVjdE5hbWU6ICdGcmFnbWVudHMnXG4gICAgICAgICAgfSxcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnR5RGVjbGFyYXRpb24oe1xuICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWU6ICdzbmFwc2hvdCcsXG4gICAgICAgICAgICAgIHR5cGVOYW1lOiAnU25hcHNob3QnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBmcmFnbWVudFNwcmVhZCBvZiBmcmFnbWVudFNwcmVhZHMpIHtcbiAgICAgICAgICAgICAgY29uc3QgeyBwcm9wZXJ0eU5hbWUsIHR5cGVOYW1lLCBzdHJ1Y3ROYW1lLCBpc0NvbmRpdGlvbmFsIH0gPSBmcmFnbWVudFNwcmVhZDtcblxuICAgICAgICAgICAgICB0aGlzLnByaW50TmV3bGluZUlmTmVlZGVkKCk7XG4gICAgICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoXG4gICAgICAgICAgICAgICAgYHB1YmxpYyB2YXIgJHtlc2NhcGVJZGVudGlmaWVySWZOZWVkZWQocHJvcGVydHlOYW1lKX06ICR7dHlwZU5hbWV9YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0aGlzLndpdGhpbkJsb2NrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKCdnZXQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLndpdGhpbkJsb2NrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChpc0NvbmRpdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoXG4gICAgICAgICAgICAgICAgICAgICAgYGlmICEke3N0cnVjdE5hbWV9LnBvc3NpYmxlVHlwZXMuY29udGFpbnMoc25hcHNob3RbXCJfX3R5cGVuYW1lXCJdISBhcyEgU3RyaW5nKSB7IHJldHVybiBuaWwgfWBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoYHJldHVybiAke3N0cnVjdE5hbWV9KHNuYXBzaG90OiBzbmFwc2hvdClgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKCdzZXQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLndpdGhpbkJsb2NrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChpc0NvbmRpdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoYGd1YXJkIGxldCBuZXdWYWx1ZSA9IG5ld1ZhbHVlIGVsc2UgeyByZXR1cm4gfWApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKGBzbmFwc2hvdCArPSBuZXdWYWx1ZS5zbmFwc2hvdGApO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgc25hcHNob3QgKz0gbmV3VmFsdWUuc25hcHNob3RgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICBpZiAoaXNDb21wb3NpdGVUeXBlKGdldE5hbWVkVHlwZShmaWVsZC50eXBlKSkgJiYgZmllbGQuc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgICAgdGhpcy5zdHJ1Y3REZWNsYXJhdGlvbkZvclNlbGVjdGlvblNldCh7XG4gICAgICAgICAgICBzdHJ1Y3ROYW1lOiBmaWVsZC5zdHJ1Y3ROYW1lLFxuICAgICAgICAgICAgc2VsZWN0aW9uU2V0OiBmaWVsZC5zZWxlY3Rpb25TZXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgYWZ0ZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGluaXRpYWxpemVyc0ZvclR5cGVDYXNlKHR5cGVDYXNlOiBUeXBlQ2FzZSkge1xuICAgIGNvbnN0IHZhcmlhbnRzID0gdHlwZUNhc2UudmFyaWFudHM7XG5cbiAgICBpZiAodmFyaWFudHMubGVuZ3RoID09IDApIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZXJzRm9yVmFyaWFudCh0eXBlQ2FzZS5kZWZhdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVtYWluZGVyID0gdHlwZUNhc2UucmVtYWluZGVyO1xuICAgICAgZm9yIChjb25zdCB2YXJpYW50IG9mIHJlbWFpbmRlciA/IFtyZW1haW5kZXIsIC4uLnZhcmlhbnRzXSA6IHZhcmlhbnRzKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZXJzRm9yVmFyaWFudChcbiAgICAgICAgICB2YXJpYW50LFxuICAgICAgICAgIHZhcmlhbnQgPT09IHJlbWFpbmRlciA/IHVuZGVmaW5lZCA6IHRoaXMuaGVscGVycy5zdHJ1Y3ROYW1lRm9yVmFyaWFudCh2YXJpYW50KSxcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGluaXRpYWxpemVyc0ZvclZhcmlhbnQoXG4gICAgdmFyaWFudDogVmFyaWFudCxcbiAgICBuYW1lc3BhY2U/OiBzdHJpbmcsXG4gICAgdXNlSW5pdGlhbGl6ZXJJZlBvc3NpYmxlOiBib29sZWFuID0gdHJ1ZVxuICApIHtcbiAgICBpZiAodXNlSW5pdGlhbGl6ZXJJZlBvc3NpYmxlICYmIHZhcmlhbnQucG9zc2libGVUeXBlcy5sZW5ndGggPT0gMSkge1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHRoaXMuaGVscGVycy5wcm9wZXJ0aWVzRm9yU2VsZWN0aW9uU2V0KHZhcmlhbnQpO1xuICAgICAgaWYgKCFwcm9wZXJ0aWVzKSByZXR1cm47XG5cbiAgICAgIHRoaXMucHJpbnROZXdsaW5lSWZOZWVkZWQoKTtcbiAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoYHB1YmxpYyBpbml0YCk7XG5cbiAgICAgIHRoaXMucGFyYW1ldGVyc0ZvclByb3BlcnRpZXMocHJvcGVydGllcyk7XG5cbiAgICAgIHRoaXMud2l0aGluQmxvY2soKCkgPT4ge1xuICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKFxuICAgICAgICAgIHdyYXAoXG4gICAgICAgICAgICBgc2VsZi5pbml0KHNuYXBzaG90OiBbYCxcbiAgICAgICAgICAgIGpvaW4oXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBgXCJfX3R5cGVuYW1lXCI6IFwiJHt2YXJpYW50LnBvc3NpYmxlVHlwZXNbMF19XCJgLFxuICAgICAgICAgICAgICAgIC4uLnByb3BlcnRpZXMubWFwKHRoaXMucHJvcGVydHlBc3NpZ25tZW50Rm9yRmllbGQsIHRoaXMpXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICcsICdcbiAgICAgICAgICAgICkgfHwgJzonLFxuICAgICAgICAgICAgYF0pYFxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdHJ1Y3ROYW1lID0gdGhpcy5zY29wZS50eXBlTmFtZTtcblxuICAgICAgZm9yIChjb25zdCBwb3NzaWJsZVR5cGUgb2YgdmFyaWFudC5wb3NzaWJsZVR5cGVzKSB7XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB0aGlzLmhlbHBlcnMucHJvcGVydGllc0ZvclNlbGVjdGlvblNldChcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwb3NzaWJsZVR5cGVzOiBbcG9zc2libGVUeXBlXSxcbiAgICAgICAgICAgIHNlbGVjdGlvbnM6IHZhcmlhbnQuc2VsZWN0aW9uc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbmFtZXNwYWNlXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCFwcm9wZXJ0aWVzKSBjb250aW51ZTtcblxuICAgICAgICB0aGlzLnByaW50TmV3bGluZUlmTmVlZGVkKCk7XG4gICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoYHB1YmxpYyBzdGF0aWMgZnVuYyBtYWtlJHtwb3NzaWJsZVR5cGV9YCk7XG5cbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzRm9yUHJvcGVydGllcyhwcm9wZXJ0aWVzKTtcblxuICAgICAgICB0aGlzLnByaW50KGAgLT4gJHtzdHJ1Y3ROYW1lfWApO1xuXG4gICAgICAgIHRoaXMud2l0aGluQmxvY2soKCkgPT4ge1xuICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoXG4gICAgICAgICAgICB3cmFwKFxuICAgICAgICAgICAgICBgcmV0dXJuICR7c3RydWN0TmFtZX0oc25hcHNob3Q6IFtgLFxuICAgICAgICAgICAgICBqb2luKFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgIGBcIl9fdHlwZW5hbWVcIjogXCIke3Bvc3NpYmxlVHlwZX1cImAsXG4gICAgICAgICAgICAgICAgICAuLi5wcm9wZXJ0aWVzLm1hcCh0aGlzLnByb3BlcnR5QXNzaWdubWVudEZvckZpZWxkLCB0aGlzKVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgJywgJ1xuICAgICAgICAgICAgICApIHx8ICc6JyxcbiAgICAgICAgICAgICAgYF0pYFxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3BlcnR5QXNzaWdubWVudEZvckZpZWxkKGZpZWxkOiB7XG4gICAgcmVzcG9uc2VLZXk6IHN0cmluZztcbiAgICBwcm9wZXJ0eU5hbWU6IHN0cmluZztcbiAgICB0eXBlOiBHcmFwaFFMVHlwZTtcbiAgfSkge1xuICAgIGNvbnN0IHsgcmVzcG9uc2VLZXksIHByb3BlcnR5TmFtZSwgdHlwZSB9ID0gZmllbGQ7XG4gICAgY29uc3QgdmFsdWVFeHByZXNzaW9uID0gaXNDb21wb3NpdGVUeXBlKGdldE5hbWVkVHlwZSh0eXBlKSlcbiAgICAgID8gdGhpcy5oZWxwZXJzLm1hcEV4cHJlc3Npb25Gb3JUeXBlKFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgaWRlbnRpZmllciA9PiBgJHtpZGVudGlmaWVyfS5zbmFwc2hvdGAsXG4gICAgICAgICAgZXNjYXBlSWRlbnRpZmllcklmTmVlZGVkKHByb3BlcnR5TmFtZSlcbiAgICAgICAgKVxuICAgICAgOiBlc2NhcGVJZGVudGlmaWVySWZOZWVkZWQocHJvcGVydHlOYW1lKTtcbiAgICByZXR1cm4gYFwiJHtyZXNwb25zZUtleX1cIjogJHt2YWx1ZUV4cHJlc3Npb259YDtcbiAgfVxuXG4gIHByb3BlcnR5RGVjbGFyYXRpb25Gb3JGaWVsZChmaWVsZDogRmllbGQgJiBQcm9wZXJ0eSkge1xuICAgIGNvbnN0IHsgcmVzcG9uc2VLZXksIHByb3BlcnR5TmFtZSwgdHlwZU5hbWUsIHR5cGUsIGlzT3B0aW9uYWwgfSA9IGZpZWxkO1xuXG4gICAgY29uc3QgdW5tb2RpZmllZEZpZWxkVHlwZSA9IGdldE5hbWVkVHlwZSh0eXBlKTtcblxuICAgIHRoaXMucHJpbnROZXdsaW5lSWZOZWVkZWQoKTtcblxuICAgIHRoaXMuY29tbWVudChmaWVsZC5kZXNjcmlwdGlvbik7XG4gICAgdGhpcy5kZXByZWNhdGlvbkF0dHJpYnV0ZXMoZmllbGQuaXNEZXByZWNhdGVkLCBmaWVsZC5kZXByZWNhdGlvblJlYXNvbik7XG5cbiAgICB0aGlzLnByaW50T25OZXdsaW5lKGBwdWJsaWMgdmFyICR7ZXNjYXBlSWRlbnRpZmllcklmTmVlZGVkKHByb3BlcnR5TmFtZSl9OiAke3R5cGVOYW1lfWApO1xuICAgIHRoaXMud2l0aGluQmxvY2soKCkgPT4ge1xuICAgICAgaWYgKGlzQ29tcG9zaXRlVHlwZSh1bm1vZGlmaWVkRmllbGRUeXBlKSkge1xuICAgICAgICBjb25zdCBzdHJ1Y3ROYW1lID0gZXNjYXBlSWRlbnRpZmllcklmTmVlZGVkKFxuICAgICAgICAgIHRoaXMuaGVscGVycy5zdHJ1Y3ROYW1lRm9yUHJvcGVydHlOYW1lKHByb3BlcnR5TmFtZSlcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaXNMaXN0KHR5cGUpKSB7XG4gICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZSgnZ2V0Jyk7XG4gICAgICAgICAgdGhpcy53aXRoaW5CbG9jaygoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzbmFwc2hvdFR5cGVOYW1lID0gdGhpcy5oZWxwZXJzLnR5cGVOYW1lRnJvbUdyYXBoUUxUeXBlKHR5cGUsICdTbmFwc2hvdCcsIGZhbHNlKTtcbiAgICAgICAgICAgIGxldCBnZXR0ZXI7XG4gICAgICAgICAgICBpZiAoaXNPcHRpb25hbCkge1xuICAgICAgICAgICAgICBnZXR0ZXIgPSBgcmV0dXJuIChzbmFwc2hvdFtcIiR7cmVzcG9uc2VLZXl9XCJdIGFzPyAke3NuYXBzaG90VHlwZU5hbWV9KWA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBnZXR0ZXIgPSBgcmV0dXJuIChzbmFwc2hvdFtcIiR7cmVzcG9uc2VLZXl9XCJdIGFzISAke3NuYXBzaG90VHlwZU5hbWV9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZXR0ZXIgKz0gdGhpcy5oZWxwZXJzLm1hcEV4cHJlc3Npb25Gb3JUeXBlKFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBpZGVudGlmaWVyID0+IGAke3N0cnVjdE5hbWV9KHNuYXBzaG90OiAke2lkZW50aWZpZXJ9KWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKGdldHRlcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZSgnc2V0Jyk7XG4gICAgICAgICAgdGhpcy53aXRoaW5CbG9jaygoKSA9PiB7XG4gICAgICAgICAgICBsZXQgbmV3VmFsdWVFeHByZXNzaW9uID0gdGhpcy5oZWxwZXJzLm1hcEV4cHJlc3Npb25Gb3JUeXBlKFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBpZGVudGlmaWVyID0+IGAke2lkZW50aWZpZXJ9LnNuYXBzaG90YCxcbiAgICAgICAgICAgICAgJ25ld1ZhbHVlJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoXG4gICAgICAgICAgICAgIGBzbmFwc2hvdC51cGRhdGVWYWx1ZSgke25ld1ZhbHVlRXhwcmVzc2lvbn0sIGZvcktleTogXCIke3Jlc3BvbnNlS2V5fVwiKWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZSgnZ2V0Jyk7XG4gICAgICAgICAgdGhpcy53aXRoaW5CbG9jaygoKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNPcHRpb25hbCkge1xuICAgICAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKFxuICAgICAgICAgICAgICAgIGByZXR1cm4gKHNuYXBzaG90W1wiJHtyZXNwb25zZUtleX1cIl0gYXM/IFNuYXBzaG90KS5mbGF0TWFwIHsgJHtzdHJ1Y3ROYW1lfShzbmFwc2hvdDogJDApIH1gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKFxuICAgICAgICAgICAgICAgIGByZXR1cm4gJHtzdHJ1Y3ROYW1lfShzbmFwc2hvdDogc25hcHNob3RbXCIke3Jlc3BvbnNlS2V5fVwiXSEgYXMhIFNuYXBzaG90KWBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKCdzZXQnKTtcbiAgICAgICAgICB0aGlzLndpdGhpbkJsb2NrKCgpID0+IHtcbiAgICAgICAgICAgIGxldCBuZXdWYWx1ZUV4cHJlc3Npb247XG4gICAgICAgICAgICBpZiAoaXNPcHRpb25hbCkge1xuICAgICAgICAgICAgICBuZXdWYWx1ZUV4cHJlc3Npb24gPSAnbmV3VmFsdWU/LnNuYXBzaG90JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld1ZhbHVlRXhwcmVzc2lvbiA9ICduZXdWYWx1ZS5zbmFwc2hvdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKFxuICAgICAgICAgICAgICBgc25hcHNob3QudXBkYXRlVmFsdWUoJHtuZXdWYWx1ZUV4cHJlc3Npb259LCBmb3JLZXk6IFwiJHtyZXNwb25zZUtleX1cIilgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKCdnZXQnKTtcbiAgICAgICAgdGhpcy53aXRoaW5CbG9jaygoKSA9PiB7XG4gICAgICAgICAgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoYHJldHVybiBzbmFwc2hvdFtcIiR7cmVzcG9uc2VLZXl9XCJdIGFzPyAke3R5cGVOYW1lLnNsaWNlKDAsIC0xKX1gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgcmV0dXJuIHNuYXBzaG90W1wiJHtyZXNwb25zZUtleX1cIl0hIGFzISAke3R5cGVOYW1lfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoJ3NldCcpO1xuICAgICAgICB0aGlzLndpdGhpbkJsb2NrKCgpID0+IHtcbiAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKGBzbmFwc2hvdC51cGRhdGVWYWx1ZShuZXdWYWx1ZSwgZm9yS2V5OiBcIiR7cmVzcG9uc2VLZXl9XCIpYCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHJvcGVydHlEZWNsYXJhdGlvbkZvclZhcmlhbnQodmFyaWFudDogUHJvcGVydHkgJiBTdHJ1Y3QpIHtcbiAgICBjb25zdCB7IHByb3BlcnR5TmFtZSwgdHlwZU5hbWUsIHN0cnVjdE5hbWUgfSA9IHZhcmlhbnQ7XG5cbiAgICB0aGlzLnByaW50TmV3bGluZUlmTmVlZGVkKCk7XG4gICAgdGhpcy5wcmludE9uTmV3bGluZShgcHVibGljIHZhciAke2VzY2FwZUlkZW50aWZpZXJJZk5lZWRlZChwcm9wZXJ0eU5hbWUpfTogJHt0eXBlTmFtZX1gKTtcbiAgICB0aGlzLndpdGhpbkJsb2NrKCgpID0+IHtcbiAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoJ2dldCcpO1xuICAgICAgdGhpcy53aXRoaW5CbG9jaygoKSA9PiB7XG4gICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoYGlmICEke3N0cnVjdE5hbWV9LnBvc3NpYmxlVHlwZXMuY29udGFpbnMoX190eXBlbmFtZSkgeyByZXR1cm4gbmlsIH1gKTtcbiAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgcmV0dXJuICR7c3RydWN0TmFtZX0oc25hcHNob3Q6IHNuYXBzaG90KWApO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnByaW50T25OZXdsaW5lKCdzZXQnKTtcbiAgICAgIHRoaXMud2l0aGluQmxvY2soKCkgPT4ge1xuICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKGBndWFyZCBsZXQgbmV3VmFsdWUgPSBuZXdWYWx1ZSBlbHNlIHsgcmV0dXJuIH1gKTtcbiAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgc25hcHNob3QgPSBuZXdWYWx1ZS5zbmFwc2hvdGApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBpbml0aWFsaXplckRlY2xhcmF0aW9uRm9yUHJvcGVydGllcyhwcm9wZXJ0aWVzOiBQcm9wZXJ0eVtdKSB7XG4gICAgdGhpcy5wcmludE9uTmV3bGluZShgcHVibGljIGluaXRgKTtcbiAgICB0aGlzLnBhcmFtZXRlcnNGb3JQcm9wZXJ0aWVzKHByb3BlcnRpZXMpO1xuXG4gICAgdGhpcy53aXRoaW5CbG9jaygoKSA9PiB7XG4gICAgICBwcm9wZXJ0aWVzLmZvckVhY2goKHsgcHJvcGVydHlOYW1lIH0pID0+IHtcbiAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgc2VsZi4ke3Byb3BlcnR5TmFtZX0gPSAke2VzY2FwZUlkZW50aWZpZXJJZk5lZWRlZChwcm9wZXJ0eU5hbWUpfWApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBwYXJhbWV0ZXJzRm9yUHJvcGVydGllcyhwcm9wZXJ0aWVzOiBQcm9wZXJ0eVtdKSB7XG4gICAgdGhpcy5wcmludCgnKCcpO1xuICAgIHRoaXMucHJpbnQoXG4gICAgICBqb2luKFxuICAgICAgICBwcm9wZXJ0aWVzLm1hcCgoeyBwcm9wZXJ0eU5hbWUsIHR5cGVOYW1lLCBpc09wdGlvbmFsIH0pID0+XG4gICAgICAgICAgam9pbihbYCR7ZXNjYXBlSWRlbnRpZmllcklmTmVlZGVkKHByb3BlcnR5TmFtZSl9OiAke3R5cGVOYW1lfWAsIGlzT3B0aW9uYWwgJiYgJyA9IG5pbCddKVxuICAgICAgICApLFxuICAgICAgICAnLCAnXG4gICAgICApXG4gICAgKTtcbiAgICB0aGlzLnByaW50KCcpJyk7XG4gIH1cblxuICB0eXBlQ2FzZUluaXRpYWxpemF0aW9uKHR5cGVDYXNlOiBUeXBlQ2FzZSkge1xuICAgIGlmICh0eXBlQ2FzZS52YXJpYW50cy5sZW5ndGggPCAxKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvblNldEluaXRpYWxpemF0aW9uKHR5cGVDYXNlLmRlZmF1bHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucHJpbnQoJ1snKTtcbiAgICB0aGlzLndpdGhJbmRlbnQoKCkgPT4ge1xuICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgR3JhcGhRTFR5cGVDYXNlKGApO1xuICAgICAgdGhpcy53aXRoSW5kZW50KCgpID0+IHtcbiAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgdmFyaWFudHM6IFtgKTtcbiAgICAgICAgdGhpcy5wcmludChcbiAgICAgICAgICB0eXBlQ2FzZS52YXJpYW50c1xuICAgICAgICAgICAgLmZsYXRNYXAodmFyaWFudCA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHN0cnVjdE5hbWUgPSB0aGlzLmhlbHBlcnMuc3RydWN0TmFtZUZvclZhcmlhbnQodmFyaWFudCk7XG4gICAgICAgICAgICAgIHJldHVybiB2YXJpYW50LnBvc3NpYmxlVHlwZXMubWFwKHR5cGUgPT4gYFwiJHt0eXBlfVwiOiAke3N0cnVjdE5hbWV9LnNlbGVjdGlvbnNgKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignLCAnKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnByaW50KCddLCcpO1xuICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKGBkZWZhdWx0OiBgKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXRJbml0aWFsaXphdGlvbih0eXBlQ2FzZS5kZWZhdWx0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcmludE9uTmV3bGluZSgnKScpO1xuICAgIH0pO1xuICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoJ10nKTtcbiAgfVxuXG4gIHNlbGVjdGlvblNldEluaXRpYWxpemF0aW9uKHNlbGVjdGlvblNldDogU2VsZWN0aW9uU2V0KSB7XG4gICAgdGhpcy5wcmludCgnWycpO1xuICAgIHRoaXMud2l0aEluZGVudCgoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHNlbGVjdGlvbiBvZiBzZWxlY3Rpb25TZXQuc2VsZWN0aW9ucykge1xuICAgICAgICBzd2l0Y2ggKHNlbGVjdGlvbi5raW5kKSB7XG4gICAgICAgICAgY2FzZSAnRmllbGQnOiB7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIGFsaWFzLCBhcmdzLCB0eXBlIH0gPSBzZWxlY3Rpb247XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUtleSA9IHNlbGVjdGlvbi5hbGlhcyB8fCBzZWxlY3Rpb24ubmFtZTtcbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdE5hbWUgPSB0aGlzLmhlbHBlcnMuc3RydWN0TmFtZUZvclByb3BlcnR5TmFtZShyZXNwb25zZUtleSk7XG5cbiAgICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoYEdyYXBoUUxGaWVsZChgKTtcbiAgICAgICAgICAgIHRoaXMucHJpbnQoXG4gICAgICAgICAgICAgIGpvaW4oXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgYFwiJHtuYW1lfVwiYCxcbiAgICAgICAgICAgICAgICAgIGFsaWFzID8gYGFsaWFzOiBcIiR7YWxpYXN9XCJgIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgIGFyZ3MgJiZcbiAgICAgICAgICAgICAgICAgICAgYXJncy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgYGFyZ3VtZW50czogJHt0aGlzLmhlbHBlcnMuZGljdGlvbmFyeUxpdGVyYWxGb3JGaWVsZEFyZ3VtZW50cyhhcmdzKX1gLFxuICAgICAgICAgICAgICAgICAgYHR5cGU6ICR7dGhpcy5oZWxwZXJzLmZpZWxkVHlwZUVudW0odHlwZSwgc3RydWN0TmFtZSl9YFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgJywgJ1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5wcmludCgnKSwnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdCb29sZWFuQ29uZGl0aW9uJzpcbiAgICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoYEdyYXBoUUxCb29sZWFuQ29uZGl0aW9uKGApO1xuICAgICAgICAgICAgdGhpcy5wcmludChcbiAgICAgICAgICAgICAgam9pbihcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICBgdmFyaWFibGVOYW1lOiBcIiR7c2VsZWN0aW9uLnZhcmlhYmxlTmFtZX1cImAsXG4gICAgICAgICAgICAgICAgICBgaW52ZXJ0ZWQ6ICR7c2VsZWN0aW9uLmludmVydGVkfWAsXG4gICAgICAgICAgICAgICAgICAnc2VsZWN0aW9uczogJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgJywgJ1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXRJbml0aWFsaXphdGlvbihzZWxlY3Rpb24uc2VsZWN0aW9uU2V0KTtcbiAgICAgICAgICAgIHRoaXMucHJpbnQoJyksJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdUeXBlQ29uZGl0aW9uJzoge1xuICAgICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgR3JhcGhRTFR5cGVDb25kaXRpb24oYCk7XG4gICAgICAgICAgICB0aGlzLnByaW50KFxuICAgICAgICAgICAgICBqb2luKFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgIGBwb3NzaWJsZVR5cGVzOiBbJHtqb2luKFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24uc2VsZWN0aW9uU2V0LnBvc3NpYmxlVHlwZXMubWFwKHR5cGUgPT4gYFwiJHt0eXBlLm5hbWV9XCJgKSxcbiAgICAgICAgICAgICAgICAgICAgJywgJ1xuICAgICAgICAgICAgICAgICAgKX1dYCxcbiAgICAgICAgICAgICAgICAgICdzZWxlY3Rpb25zOiAnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAnLCAnXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblNldEluaXRpYWxpemF0aW9uKHNlbGVjdGlvbi5zZWxlY3Rpb25TZXQpO1xuICAgICAgICAgICAgdGhpcy5wcmludCgnKSwnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdGcmFnbWVudFNwcmVhZCc6IHtcbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdE5hbWUgPSB0aGlzLmhlbHBlcnMuc3RydWN0TmFtZUZvckZyYWdtZW50TmFtZShzZWxlY3Rpb24uZnJhZ21lbnROYW1lKTtcbiAgICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoYEdyYXBoUUxGcmFnbWVudFNwcmVhZCgke3N0cnVjdE5hbWV9LnNlbGYpLGApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5wcmludE9uTmV3bGluZSgnXScpO1xuICB9XG5cbiAgdHlwZURlY2xhcmF0aW9uRm9yR3JhcGhRTFR5cGUodHlwZTogR3JhcGhRTFR5cGUpIHtcbiAgICBpZiAodHlwZSBpbnN0YW5jZW9mIEdyYXBoUUxFbnVtVHlwZSkge1xuICAgICAgdGhpcy5lbnVtZXJhdGlvbkRlY2xhcmF0aW9uKHR5cGUpO1xuICAgIH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIEdyYXBoUUxJbnB1dE9iamVjdFR5cGUpIHtcbiAgICAgIHRoaXMuc3RydWN0RGVjbGFyYXRpb25Gb3JJbnB1dE9iamVjdFR5cGUodHlwZSk7XG4gICAgfVxuICB9XG5cbiAgZW51bWVyYXRpb25EZWNsYXJhdGlvbih0eXBlOiBHcmFwaFFMRW51bVR5cGUpIHtcbiAgICBjb25zdCB7IG5hbWUsIGRlc2NyaXB0aW9uIH0gPSB0eXBlO1xuICAgIGNvbnN0IHZhbHVlcyA9IHR5cGUuZ2V0VmFsdWVzKCk7XG5cbiAgICB0aGlzLnByaW50TmV3bGluZUlmTmVlZGVkKCk7XG4gICAgdGhpcy5jb21tZW50KGRlc2NyaXB0aW9uIHx8IHVuZGVmaW5lZCk7XG4gICAgdGhpcy5wcmludE9uTmV3bGluZShcbiAgICAgIGBwdWJsaWMgZW51bSAke25hbWV9OiBSYXdSZXByZXNlbnRhYmxlLCBFcXVhdGFibGUsIEpTT05EZWNvZGFibGUsIEpTT05FbmNvZGFibGVgXG4gICAgKTtcbiAgICB0aGlzLndpdGhpbkJsb2NrKCgpID0+IHtcbiAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoJ3B1YmxpYyB0eXBlYWxpYXMgUmF3VmFsdWUgPSBTdHJpbmcnKTtcblxuICAgICAgdmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICB0aGlzLmNvbW1lbnQodmFsdWUuZGVzY3JpcHRpb24gfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5kZXByZWNhdGlvbkF0dHJpYnV0ZXModmFsdWUuaXNEZXByZWNhdGVkLCB2YWx1ZS5kZXByZWNhdGlvblJlYXNvbiB8fCB1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKFxuICAgICAgICAgIGBjYXNlICR7ZXNjYXBlSWRlbnRpZmllcklmTmVlZGVkKHRoaXMuaGVscGVycy5lbnVtQ2FzZU5hbWUodmFsdWUubmFtZSkpfWBcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb21tZW50KCdBdXRvIGdlbmVyYXRlZCBjb25zdGFudCBmb3IgdW5rbm93biBlbnVtIHZhbHVlcycpO1xuICAgICAgdGhpcy5wcmludE9uTmV3bGluZSgnY2FzZSB1bmtub3duKFJhd1ZhbHVlKScpO1xuXG4gICAgICB0aGlzLnByaW50TmV3bGluZUlmTmVlZGVkKCk7XG4gICAgICB0aGlzLnByaW50T25OZXdsaW5lKCdwdWJsaWMgaW5pdD8ocmF3VmFsdWU6IFJhd1ZhbHVlKScpO1xuICAgICAgdGhpcy53aXRoaW5CbG9jaygoKSA9PiB7XG4gICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoJ3N3aXRjaCByYXdWYWx1ZScpO1xuICAgICAgICB0aGlzLndpdGhpbkJsb2NrKCgpID0+IHtcbiAgICAgICAgICB2YWx1ZXMuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKFxuICAgICAgICAgICAgICBgY2FzZSBcIiR7dmFsdWUudmFsdWV9XCI6IHNlbGYgPSAke2VzY2FwZUlkZW50aWZpZXJJZk5lZWRlZChcbiAgICAgICAgICAgICAgICB0aGlzLmhlbHBlcnMuZW51bURvdENhc2VOYW1lKHZhbHVlLm5hbWUpXG4gICAgICAgICAgICAgICl9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKGBkZWZhdWx0OiBzZWxmID0gLnVua25vd24ocmF3VmFsdWUpYCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMucHJpbnROZXdsaW5lSWZOZWVkZWQoKTtcbiAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoJ3B1YmxpYyB2YXIgcmF3VmFsdWU6IFJhd1ZhbHVlJyk7XG4gICAgICB0aGlzLndpdGhpbkJsb2NrKCgpID0+IHtcbiAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZSgnc3dpdGNoIHNlbGYnKTtcbiAgICAgICAgdGhpcy53aXRoaW5CbG9jaygoKSA9PiB7XG4gICAgICAgICAgdmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShcbiAgICAgICAgICAgICAgYGNhc2UgJHtlc2NhcGVJZGVudGlmaWVySWZOZWVkZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5oZWxwZXJzLmVudW1Eb3RDYXNlTmFtZSh2YWx1ZS5uYW1lKVxuICAgICAgICAgICAgICApfTogcmV0dXJuIFwiJHt2YWx1ZS52YWx1ZX1cImBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgY2FzZSAudW5rbm93bihsZXQgdmFsdWUpOiByZXR1cm4gdmFsdWVgKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5wcmludE5ld2xpbmVJZk5lZWRlZCgpO1xuICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgcHVibGljIHN0YXRpYyBmdW5jID09IChsaHM6ICR7bmFtZX0sIHJoczogJHtuYW1lfSkgLT4gQm9vbGApO1xuICAgICAgdGhpcy53aXRoaW5CbG9jaygoKSA9PiB7XG4gICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoJ3N3aXRjaCAobGhzLCByaHMpJyk7XG4gICAgICAgIHRoaXMud2l0aGluQmxvY2soKCkgPT4ge1xuICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVudW1Eb3RDYXNlTmFtZSA9IGVzY2FwZUlkZW50aWZpZXJJZk5lZWRlZChcbiAgICAgICAgICAgICAgdGhpcy5oZWxwZXJzLmVudW1Eb3RDYXNlTmFtZSh2YWx1ZS5uYW1lKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHR1cGxlID0gYCgke2VudW1Eb3RDYXNlTmFtZX0sICR7ZW51bURvdENhc2VOYW1lfSlgO1xuICAgICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgY2FzZSAke3R1cGxlfTogcmV0dXJuIHRydWVgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKFxuICAgICAgICAgICAgYGNhc2UgKC51bmtub3duKGxldCBsaHNWYWx1ZSksIC51bmtub3duKGxldCByaHNWYWx1ZSkpOiByZXR1cm4gbGhzVmFsdWUgPT0gcmhzVmFsdWVgXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKGBkZWZhdWx0OiByZXR1cm4gZmFsc2VgKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0cnVjdERlY2xhcmF0aW9uRm9ySW5wdXRPYmplY3RUeXBlKHR5cGU6IEdyYXBoUUxJbnB1dE9iamVjdFR5cGUpIHtcbiAgICBjb25zdCB7IG5hbWU6IHN0cnVjdE5hbWUsIGRlc2NyaXB0aW9uIH0gPSB0eXBlO1xuICAgIGNvbnN0IGFkb3B0ZWRQcm90b2NvbHMgPSBbJ0dyYXBoUUxNYXBDb252ZXJ0aWJsZSddO1xuICAgIGNvbnN0IGZpZWxkcyA9IE9iamVjdC52YWx1ZXModHlwZS5nZXRGaWVsZHMoKSk7XG5cbiAgICBsZXQgcHJvcGVydGllcyA9IGZpZWxkcy5tYXAodGhpcy5oZWxwZXJzLnByb3BlcnR5RnJvbUlucHV0RmllbGQsIHRoaXMuaGVscGVycyk7XG5cbiAgICAvLyBGaWxlIGlucHV0IHNob3VsZCBoYXZlIGxvY2FsVXJpIGFuZCBtaW1lVHlwZSB3aGljaCBpcyB1c2VkIG9ubHkgaW4gY2xpZW50XG4gICAgaWYgKGlzUzNGaWVsZCh0eXBlKSkge1xuICAgICAgcHJvcGVydGllcyA9IFtcbiAgICAgICAgLi4ucHJvcGVydGllcyxcbiAgICAgICAge1xuICAgICAgICAgIHByb3BlcnR5TmFtZTogJ2xvY2FsVXJpJyxcbiAgICAgICAgICBuYW1lOiAnbG9jYWxVcmknLFxuICAgICAgICAgIHR5cGVOYW1lOiAnU3RyaW5nJyxcbiAgICAgICAgICBpc09wdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJycsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBwcm9wZXJ0eU5hbWU6ICdtaW1lVHlwZScsXG4gICAgICAgICAgbmFtZTogJ21pbWVUeXBlJyxcbiAgICAgICAgICB0eXBlTmFtZTogJ1N0cmluZycsXG4gICAgICAgICAgaXNPcHRpb25hbDogZmFsc2UsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICcnLFxuICAgICAgICB9LFxuICAgICAgXTtcbiAgICB9XG5cbiAgICB0aGlzLnN0cnVjdERlY2xhcmF0aW9uKFxuICAgICAgeyBzdHJ1Y3ROYW1lLCBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24gfHwgdW5kZWZpbmVkLCBhZG9wdGVkUHJvdG9jb2xzIH0sXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoYHB1YmxpYyB2YXIgZ3JhcGhRTE1hcDogR3JhcGhRTE1hcGApO1xuXG4gICAgICAgIHRoaXMucHJpbnROZXdsaW5lSWZOZWVkZWQoKTtcbiAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgcHVibGljIGluaXRgKTtcbiAgICAgICAgdGhpcy5wcmludCgnKCcpO1xuICAgICAgICB0aGlzLnByaW50KFxuICAgICAgICAgIGpvaW4oXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLm1hcCgoeyBwcm9wZXJ0eU5hbWUsIHR5cGVOYW1lLCBpc09wdGlvbmFsIH0pID0+XG4gICAgICAgICAgICAgIGpvaW4oW1xuICAgICAgICAgICAgICAgIGAke2VzY2FwZUlkZW50aWZpZXJJZk5lZWRlZChwcm9wZXJ0eU5hbWUpfTogJHt0eXBlTmFtZX1gLFxuICAgICAgICAgICAgICAgIGlzT3B0aW9uYWwgJiYgJyA9IG5pbCdcbiAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAnLCAnXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnByaW50KCcpJyk7XG5cbiAgICAgICAgdGhpcy53aXRoaW5CbG9jaygoKSA9PiB7XG4gICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShcbiAgICAgICAgICAgIHdyYXAoXG4gICAgICAgICAgICAgIGBncmFwaFFMTWFwID0gW2AsXG4gICAgICAgICAgICAgIGpvaW4oXG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5tYXAoXG4gICAgICAgICAgICAgICAgICAoeyBuYW1lLCBwcm9wZXJ0eU5hbWUgfSkgPT4gYFwiJHtuYW1lfVwiOiAke2VzY2FwZUlkZW50aWZpZXJJZk5lZWRlZChwcm9wZXJ0eU5hbWUpfWBcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICcsICdcbiAgICAgICAgICAgICAgKSB8fCAnOicsXG4gICAgICAgICAgICAgIGBdYFxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAoY29uc3QgeyBwcm9wZXJ0eU5hbWUsIHR5cGVOYW1lLCBkZXNjcmlwdGlvbiB9IG9mIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICB0aGlzLnByaW50TmV3bGluZUlmTmVlZGVkKCk7XG4gICAgICAgICAgdGhpcy5jb21tZW50KGRlc2NyaXB0aW9uIHx8IHVuZGVmaW5lZCk7XG4gICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgcHVibGljIHZhciAke2VzY2FwZUlkZW50aWZpZXJJZk5lZWRlZChwcm9wZXJ0eU5hbWUpfTogJHt0eXBlTmFtZX1gKTtcbiAgICAgICAgICB0aGlzLndpdGhpbkJsb2NrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoJ2dldCcpO1xuICAgICAgICAgICAgdGhpcy53aXRoaW5CbG9jaygoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoYHJldHVybiBncmFwaFFMTWFwW1wiJHtwcm9wZXJ0eU5hbWV9XCJdIGFzISAke3R5cGVOYW1lfWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKCdzZXQnKTtcbiAgICAgICAgICAgIHRoaXMud2l0aGluQmxvY2soKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKGBncmFwaFFMTWFwLnVwZGF0ZVZhbHVlKG5ld1ZhbHVlLCBmb3JLZXk6IFwiJHtwcm9wZXJ0eU5hbWV9XCIpYCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH1cbn1cbiJdfQ==");"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const graphql_1 = require("graphql");
const printing_1 = require("../utilities/printing");
const language_1 = require("./language");
const helpers_1 = require("./helpers");
const s3Wrapper_1 = require("./s3Wrapper");
const graphql_2 = require("../utilities/graphql");
const typeCase_1 = require("../compiler/visitors/typeCase");
const collectFragmentsReferenced_1 = require("../compiler/visitors/collectFragmentsReferenced");
const generateOperationId_1 = require("../compiler/visitors/generateOperationId");
const collectAndMergeFields_1 = require("../compiler/visitors/collectAndMergeFields");
require("../utilities/array");
const complextypes_1 = require("../utilities/complextypes");
function generateSource(context, outputIndividualFiles, only) {
    const generator = new SwiftAPIGenerator(context);
    if (outputIndividualFiles) {
        generator.withinFile(`Types.graphql.swift`, () => {
            generator.fileHeader();
            generator.namespaceDeclaration(context.options.namespace, () => {
                context.typesUsed.forEach(type => {
                    generator.typeDeclarationForGraphQLType(type);
                });
            });
            if (context.options.addS3Wrapper) {
                generator.printOnNewline(`\n${s3Wrapper_1.s3WrapperCode}`);
            }
        });
        const inputFilePaths = new Set();
        Object.values(context.operations).forEach(operation => {
            inputFilePaths.add(operation.filePath);
        });
        Object.values(context.fragments).forEach(fragment => {
            inputFilePaths.add(fragment.filePath);
        });
        for (const inputFilePath of inputFilePaths) {
            if (only && inputFilePath !== only)
            continue;
            generator.withinFile(`${path.basename(inputFilePath)}.swift`, () => {
                generator.fileHeader();
                generator.namespaceExtensionDeclaration(context.options.namespace, () => {
                    Object.values(context.operations).forEach(operation => {
                        if (operation.filePath === inputFilePath) {
                            generator.classDeclarationForOperation(operation);
                        }
                    });
                    Object.values(context.fragments).forEach(fragment => {
                        if (fragment.filePath === inputFilePath) {
                            generator.structDeclarationForFragment(fragment);
                        }
                    });
                });
            });
        }
    } else
    {
        generator.fileHeader();
        generator.namespaceDeclaration(context.options.namespace, () => {
            context.typesUsed.forEach(type => {
                generator.typeDeclarationForGraphQLType(type);
            });
            Object.values(context.operations).forEach(operation => {
                generator.classDeclarationForOperation(operation);
            });
            Object.values(context.fragments).forEach(fragment => {
                generator.structDeclarationForFragment(fragment);
            });
        });
        if (context.options.addS3Wrapper) {
            generator.printOnNewline(`\n${s3Wrapper_1.s3WrapperCode}`);
        }
    }
    return generator;
}
exports.generateSource = generateSource;
class SwiftAPIGenerator extends language_1.SwiftGenerator {
    constructor(context) {
        super(context);
        this.helpers = new helpers_1.Helpers(context.options);
    }
    fileHeader() {
        this.printOnNewline('//  This file was automatically generated and should not be edited.');
        this.printNewline();
        this.printOnNewline('import AWSAppSync');
    }
    classDeclarationForOperation(operation) {
        const { operationName, operationType, variables, source, selectionSet } = operation;
        let className;
        let protocol;
        switch (operationType) {
            case 'query':
                className = `${this.helpers.operationClassName(operationName)}Query`;
                protocol = 'GraphQLQuery';
                break;
            case 'mutation':
                className = `${this.helpers.operationClassName(operationName)}Mutation`;
                protocol = 'GraphQLMutation';
                break;
            case 'subscription':
                className = `${this.helpers.operationClassName(operationName)}Subscription`;
                protocol = 'GraphQLSubscription';
                break;
            default:
                throw new graphql_1.GraphQLError(`Unsupported operation type "${operationType}"`);}

        this.classDeclaration({
            className,
            modifiers: ['public', 'final'],
            adoptedProtocols: [protocol] },
        () => {
            if (source) {
                this.printOnNewline('public static let operationString =');
                this.withIndent(() => {
                    this.multilineString(source);
                });
            }
            const fragmentsReferenced = collectFragmentsReferenced_1.collectFragmentsReferenced(operation.selectionSet, this.context.fragments);
            if (this.context.options.generateOperationIds) {
                const { operationId } = generateOperationId_1.generateOperationId(operation, this.context.fragments, fragmentsReferenced);
                operation.operationId = operationId;
                this.printNewlineIfNeeded();
                this.printOnNewline(`public static let operationIdentifier: String? = "${operationId}"`);
            }
            if (fragmentsReferenced.size > 0) {
                this.printNewlineIfNeeded();
                this.printOnNewline('public static var requestString: String { return operationString');
                fragmentsReferenced.forEach(fragmentName => {
                    this.print(`.appending(${this.helpers.structNameForFragmentName(fragmentName)}.fragmentString)`);
                });
                this.print(' }');
            }
            this.printNewlineIfNeeded();
            if (variables && variables.length > 0) {
                const properties = variables.map(({ name, type }) => {
                    const typeName = this.helpers.typeNameFromGraphQLType(type);
                    const isOptional = !(graphql_1.isNonNullType(type) ||
                    graphql_1.isListType(type) && graphql_1.isNonNullType(type.ofType));
                    return { name, propertyName: name, type, typeName, isOptional };
                });
                this.propertyDeclarations(properties);
                this.printNewlineIfNeeded();
                this.initializerDeclarationForProperties(properties);
                this.printNewlineIfNeeded();
                this.printOnNewline(`public var variables: GraphQLMap?`);
                this.withinBlock(() => {
                    this.printOnNewline(printing_1.wrap(`return [`, printing_1.join(properties.map(({ name, propertyName }) => `"${name}": ${language_1.escapeIdentifierIfNeeded(propertyName)}`), ', ') || ':', `]`));
                });
            } else
            {
                this.initializerDeclarationForProperties([]);
            }
            this.structDeclarationForSelectionSet({
                structName: 'Data',
                selectionSet });

        });
    }
    structDeclarationForFragment({ fragmentName, selectionSet, source }) {
        const structName = this.helpers.structNameForFragmentName(fragmentName);
        this.structDeclarationForSelectionSet({
            structName,
            adoptedProtocols: ['GraphQLFragment'],
            selectionSet },
        () => {
            if (source) {
                this.printOnNewline('public static let fragmentString =');
                this.withIndent(() => {
                    this.multilineString(source);
                });
            }
        });
    }
    structDeclarationForSelectionSet({ structName, adoptedProtocols = ['GraphQLSelectionSet'], selectionSet }, before) {
        const typeCase = typeCase_1.typeCaseForSelectionSet(selectionSet, this.context.options.mergeInFieldsFromFragmentSpreads);
        this.structDeclarationForVariant({
            structName,
            adoptedProtocols,
            variant: typeCase.default,
            typeCase },
        before, () => {
            const variants = typeCase.variants.map(this.helpers.propertyFromVariant, this.helpers);
            for (const variant of variants) {
                this.propertyDeclarationForVariant(variant);
                this.structDeclarationForVariant({
                    structName: variant.structName,
                    variant });

            }
        });
    }
    structDeclarationForVariant({ structName, adoptedProtocols = ['GraphQLSelectionSet'], variant, typeCase }, before, after) {
        this.structDeclaration({ structName, adoptedProtocols }, () => {
            if (before) {
                before();
            }
            this.printNewlineIfNeeded();
            this.printOnNewline('public static let possibleTypes = [');
            this.print(printing_1.join(variant.possibleTypes.map(type => `"${type.name}"`), ', '));
            this.print(']');
            this.printNewlineIfNeeded();
            this.printOnNewline('public static let selections: [GraphQLSelection] = ');
            if (typeCase) {
                this.typeCaseInitialization(typeCase);
            } else
            {
                this.selectionSetInitialization(variant);
            }
            this.printNewlineIfNeeded();
            this.propertyDeclaration({
                propertyName: 'snapshot',
                typeName: 'Snapshot' });

            this.printNewlineIfNeeded();
            this.printOnNewline('public init(snapshot: Snapshot)');
            this.withinBlock(() => {
                this.printOnNewline(`self.snapshot = snapshot`);
            });
            if (typeCase) {
                this.initializersForTypeCase(typeCase);
            } else
            {
                this.initializersForVariant(variant);
            }
            const fields = collectAndMergeFields_1.collectAndMergeFields(variant, this.context.options.mergeInFieldsFromFragmentSpreads).map(field => this.helpers.propertyFromField(field));
            const fragmentSpreads = variant.fragmentSpreads.map(fragmentSpread => {
                const isConditional = variant.possibleTypes.some(type => !fragmentSpread.selectionSet.possibleTypes.includes(type));
                return this.helpers.propertyFromFragmentSpread(fragmentSpread, isConditional);
            });
            fields.forEach(this.propertyDeclarationForField, this);
            if (fragmentSpreads.length > 0) {
                this.printNewlineIfNeeded();
                this.printOnNewline(`public var fragments: Fragments`);
                this.withinBlock(() => {
                    this.printOnNewline('get');
                    this.withinBlock(() => {
                        this.printOnNewline(`return Fragments(snapshot: snapshot)`);
                    });
                    this.printOnNewline('set');
                    this.withinBlock(() => {
                        this.printOnNewline(`snapshot += newValue.snapshot`);
                    });
                });
                this.structDeclaration({
                    structName: 'Fragments' },
                () => {
                    this.propertyDeclaration({
                        propertyName: 'snapshot',
                        typeName: 'Snapshot' });

                    for (const fragmentSpread of fragmentSpreads) {
                        const { propertyName, typeName, structName, isConditional } = fragmentSpread;
                        this.printNewlineIfNeeded();
                        this.printOnNewline(`public var ${language_1.escapeIdentifierIfNeeded(propertyName)}: ${typeName}`);
                        this.withinBlock(() => {
                            this.printOnNewline('get');
                            this.withinBlock(() => {
                                if (isConditional) {
                                    this.printOnNewline(`if !${structName}.possibleTypes.contains(snapshot["__typename"]! as! String) { return nil }`);
                                }
                                this.printOnNewline(`return ${structName}(snapshot: snapshot)`);
                            });
                            this.printOnNewline('set');
                            this.withinBlock(() => {
                                if (isConditional) {
                                    this.printOnNewline(`guard let newValue = newValue else { return }`);
                                    this.printOnNewline(`snapshot += newValue.snapshot`);
                                } else
                                {
                                    this.printOnNewline(`snapshot += newValue.snapshot`);
                                }
                            });
                        });
                    }
                });
            }
            for (const field of fields) {
                if (graphql_1.isCompositeType(graphql_1.getNamedType(field.type)) && field.selectionSet) {
                    this.structDeclarationForSelectionSet({
                        structName: field.structName,
                        selectionSet: field.selectionSet });

                }
            }
            if (after) {
                after();
            }
        });
    }
    initializersForTypeCase(typeCase) {
        const variants = typeCase.variants;
        if (variants.length == 0) {
            this.initializersForVariant(typeCase.default);
        } else
        {
            const remainder = typeCase.remainder;
            for (const variant of remainder ? [remainder, ...variants] : variants) {
                this.initializersForVariant(variant, variant === remainder ? undefined : this.helpers.structNameForVariant(variant), false);
            }
        }
    }
    initializersForVariant(variant, namespace, useInitializerIfPossible = true) {
        if (useInitializerIfPossible && variant.possibleTypes.length == 1) {
            const properties = this.helpers.propertiesForSelectionSet(variant);
            if (!properties)
            return;
            this.printNewlineIfNeeded();
            this.printOnNewline(`public init`);
            this.parametersForProperties(properties);
            this.withinBlock(() => {
                this.printOnNewline(printing_1.wrap(`self.init(snapshot: [`, printing_1.join([
                `"__typename": "${variant.possibleTypes[0]}"`,
                ...properties.map(this.propertyAssignmentForField, this)],
                ', ') || ':', `])`));
            });
        } else
        {
            const structName = this.scope.typeName;
            for (const possibleType of variant.possibleTypes) {
                const properties = this.helpers.propertiesForSelectionSet({
                    possibleTypes: [possibleType],
                    selections: variant.selections },
                namespace);
                if (!properties)
                continue;
                this.printNewlineIfNeeded();
                this.printOnNewline(`public static func make${possibleType}`);
                this.parametersForProperties(properties);
                this.print(` -> ${structName}`);
                this.withinBlock(() => {
                    this.printOnNewline(printing_1.wrap(`return ${structName}(snapshot: [`, printing_1.join([
                    `"__typename": "${possibleType}"`,
                    ...properties.map(this.propertyAssignmentForField, this)],
                    ', ') || ':', `])`));
                });
            }
        }
    }
    propertyAssignmentForField(field) {
        const { responseKey, propertyName, type } = field;
        const valueExpression = graphql_1.isCompositeType(graphql_1.getNamedType(type)) ?
        this.helpers.mapExpressionForType(type, identifier => `${identifier}.snapshot`, language_1.escapeIdentifierIfNeeded(propertyName)) :
        language_1.escapeIdentifierIfNeeded(propertyName);
        return `"${responseKey}": ${valueExpression}`;
    }
    propertyDeclarationForField(field) {
        const { responseKey, propertyName, typeName, type, isOptional } = field;
        const unmodifiedFieldType = graphql_1.getNamedType(type);
        this.printNewlineIfNeeded();
        this.comment(field.description);
        this.deprecationAttributes(field.isDeprecated, field.deprecationReason);
        this.printOnNewline(`public var ${language_1.escapeIdentifierIfNeeded(propertyName)}: ${typeName}`);
        this.withinBlock(() => {
            if (graphql_1.isCompositeType(unmodifiedFieldType)) {
                const structName = language_1.escapeIdentifierIfNeeded(this.helpers.structNameForPropertyName(propertyName));
                if (graphql_2.isList(type)) {
                    this.printOnNewline('get');
                    this.withinBlock(() => {
                        const snapshotTypeName = this.helpers.typeNameFromGraphQLType(type, 'Snapshot', false);
                        let getter;
                        if (isOptional) {
                            getter = `return (snapshot["${responseKey}"] as? ${snapshotTypeName})`;
                        } else
                        {
                            getter = `return (snapshot["${responseKey}"] as! ${snapshotTypeName})`;
                        }
                        getter += this.helpers.mapExpressionForType(type, identifier => `${structName}(snapshot: ${identifier})`);
                        this.printOnNewline(getter);
                    });
                    this.printOnNewline('set');
                    this.withinBlock(() => {
                        let newValueExpression = this.helpers.mapExpressionForType(type, identifier => `${identifier}.snapshot`, 'newValue');
                        this.printOnNewline(`snapshot.updateValue(${newValueExpression}, forKey: "${responseKey}")`);
                    });
                } else
                {
                    this.printOnNewline('get');
                    this.withinBlock(() => {
                        if (isOptional) {
                            this.printOnNewline(`return (snapshot["${responseKey}"] as? Snapshot).flatMap { ${structName}(snapshot: $0) }`);
                        } else
                        {
                            this.printOnNewline(`return ${structName}(snapshot: snapshot["${responseKey}"]! as! Snapshot)`);
                        }
                    });
                    this.printOnNewline('set');
                    this.withinBlock(() => {
                        let newValueExpression;
                        if (isOptional) {
                            newValueExpression = 'newValue?.snapshot';
                        } else
                        {
                            newValueExpression = 'newValue.snapshot';
                        }
                        this.printOnNewline(`snapshot.updateValue(${newValueExpression}, forKey: "${responseKey}")`);
                    });
                }
            } else
            {
                this.printOnNewline('get');
                this.withinBlock(() => {
                    if (isOptional) {
                        this.printOnNewline(`return snapshot["${responseKey}"] as? ${typeName.slice(0, -1)}`);
                    } else
                    {
                        this.printOnNewline(`return snapshot["${responseKey}"]! as! ${typeName}`);
                    }
                });
                this.printOnNewline('set');
                this.withinBlock(() => {
                    this.printOnNewline(`snapshot.updateValue(newValue, forKey: "${responseKey}")`);
                });
            }
        });
    }
    propertyDeclarationForVariant(variant) {
        const { propertyName, typeName, structName } = variant;
        this.printNewlineIfNeeded();
        this.printOnNewline(`public var ${language_1.escapeIdentifierIfNeeded(propertyName)}: ${typeName}`);
        this.withinBlock(() => {
            this.printOnNewline('get');
            this.withinBlock(() => {
                this.printOnNewline(`if !${structName}.possibleTypes.contains(__typename) { return nil }`);
                this.printOnNewline(`return ${structName}(snapshot: snapshot)`);
            });
            this.printOnNewline('set');
            this.withinBlock(() => {
                this.printOnNewline(`guard let newValue = newValue else { return }`);
                this.printOnNewline(`snapshot = newValue.snapshot`);
            });
        });
    }
    initializerDeclarationForProperties(properties) {
        this.printOnNewline(`public init`);
        this.parametersForProperties(properties);
        this.withinBlock(() => {
            properties.forEach(({ propertyName }) => {
                this.printOnNewline(`self.${propertyName} = ${language_1.escapeIdentifierIfNeeded(propertyName)}`);
            });
        });
    }
    parametersForProperties(properties) {
        this.print('(');
        this.print(printing_1.join(properties.map(({ propertyName, typeName, isOptional }) => printing_1.join([`${language_1.escapeIdentifierIfNeeded(propertyName)}: ${typeName}`, isOptional && ' = nil'])), ', '));
        this.print(')');
    }
    typeCaseInitialization(typeCase) {
        if (typeCase.variants.length < 1) {
            this.selectionSetInitialization(typeCase.default);
            return;
        }
        this.print('[');
        this.withIndent(() => {
            this.printOnNewline(`GraphQLTypeCase(`);
            this.withIndent(() => {
                this.printOnNewline(`variants: [`);
                this.print(typeCase.variants.
                flatMap(variant => {
                    const structName = this.helpers.structNameForVariant(variant);
                    return variant.possibleTypes.map(type => `"${type}": ${structName}.selections`);
                }).
                join(', '));
                this.print('],');
                this.printOnNewline(`default: `);
                this.selectionSetInitialization(typeCase.default);
            });
            this.printOnNewline(')');
        });
        this.printOnNewline(']');
    }
    selectionSetInitialization(selectionSet) {
        this.print('[');
        this.withIndent(() => {
            for (const selection of selectionSet.selections) {
                switch (selection.kind) {
                    case 'Field':{
                            const { name, alias, args, type } = selection;
                            const responseKey = selection.alias || selection.name;
                            const structName = this.helpers.structNameForPropertyName(responseKey);
                            this.printOnNewline(`GraphQLField(`);
                            this.print(printing_1.join([
                            `"${name}"`,
                            alias ? `alias: "${alias}"` : null,
                            args &&
                            args.length &&
                            `arguments: ${this.helpers.dictionaryLiteralForFieldArguments(args)}`,
                            `type: ${this.helpers.fieldTypeEnum(type, structName)}`],
                            ', '));
                            this.print('),');
                            break;
                        }
                    case 'BooleanCondition':
                        this.printOnNewline(`GraphQLBooleanCondition(`);
                        this.print(printing_1.join([
                        `variableName: "${selection.variableName}"`,
                        `inverted: ${selection.inverted}`,
                        'selections: '],
                        ', '));
                        this.selectionSetInitialization(selection.selectionSet);
                        this.print('),');
                        break;
                    case 'TypeCondition':{
                            this.printOnNewline(`GraphQLTypeCondition(`);
                            this.print(printing_1.join([
                            `possibleTypes: [${printing_1.join(selection.selectionSet.possibleTypes.map(type => `"${type.name}"`), ', ')}]`,
                            'selections: '],
                            ', '));
                            this.selectionSetInitialization(selection.selectionSet);
                            this.print('),');
                            break;
                        }
                    case 'FragmentSpread':{
                            const structName = this.helpers.structNameForFragmentName(selection.fragmentName);
                            this.printOnNewline(`GraphQLFragmentSpread(${structName}.self),`);
                            break;
                        }}

            }
        });
        this.printOnNewline(']');
    }
    typeDeclarationForGraphQLType(type) {
        if (type instanceof graphql_1.GraphQLEnumType) {
            this.enumerationDeclaration(type);
        } else
        if (type instanceof graphql_1.GraphQLInputObjectType) {
            this.structDeclarationForInputObjectType(type);
        }
    }
    enumerationDeclaration(type) {
        const { name, description } = type;
        const values = type.getValues();
        this.printNewlineIfNeeded();
        this.comment(description || undefined);
        this.printOnNewline(`public enum ${name}: RawRepresentable, Equatable, JSONDecodable, JSONEncodable`);
        this.withinBlock(() => {
            this.printOnNewline('public typealias RawValue = String');
            values.forEach(value => {
                this.comment(value.description || undefined);
                this.deprecationAttributes(value.isDeprecated, value.deprecationReason || undefined);
                this.printOnNewline(`case ${language_1.escapeIdentifierIfNeeded(this.helpers.enumCaseName(value.name))}`);
            });
            this.comment('Auto generated constant for unknown enum values');
            this.printOnNewline('case unknown(RawValue)');
            this.printNewlineIfNeeded();
            this.printOnNewline('public init?(rawValue: RawValue)');
            this.withinBlock(() => {
                this.printOnNewline('switch rawValue');
                this.withinBlock(() => {
                    values.forEach(value => {
                        this.printOnNewline(`case "${value.value}": self = ${language_1.escapeIdentifierIfNeeded(this.helpers.enumDotCaseName(value.name))}`);
                    });
                    this.printOnNewline(`default: self = .unknown(rawValue)`);
                });
            });
            this.printNewlineIfNeeded();
            this.printOnNewline('public var rawValue: RawValue');
            this.withinBlock(() => {
                this.printOnNewline('switch self');
                this.withinBlock(() => {
                    values.forEach(value => {
                        this.printOnNewline(`case ${language_1.escapeIdentifierIfNeeded(this.helpers.enumDotCaseName(value.name))}: return "${value.value}"`);
                    });
                    this.printOnNewline(`case .unknown(let value): return value`);
                });
            });
            this.printNewlineIfNeeded();
            this.printOnNewline(`public static func == (lhs: ${name}, rhs: ${name}) -> Bool`);
            this.withinBlock(() => {
                this.printOnNewline('switch (lhs, rhs)');
                this.withinBlock(() => {
                    values.forEach(value => {
                        const enumDotCaseName = language_1.escapeIdentifierIfNeeded(this.helpers.enumDotCaseName(value.name));
                        const tuple = `(${enumDotCaseName}, ${enumDotCaseName})`;
                        this.printOnNewline(`case ${tuple}: return true`);
                    });
                    this.printOnNewline(`case (.unknown(let lhsValue), .unknown(let rhsValue)): return lhsValue == rhsValue`);
                    this.printOnNewline(`default: return false`);
                });
            });
        });
    }
    structDeclarationForInputObjectType(type) {
        const { name: structName, description } = type;
        const adoptedProtocols = ['GraphQLMapConvertible'];
        const fields = Object.values(type.getFields());
        let properties = fields.map(this.helpers.propertyFromInputField, this.helpers);
        if (complextypes_1.isS3Field(type)) {
            properties = [
            ...properties,
            {
                propertyName: 'localUri',
                name: 'localUri',
                typeName: 'String',
                isOptional: false,
                description: '' },

            {
                propertyName: 'mimeType',
                name: 'mimeType',
                typeName: 'String',
                isOptional: false,
                description: '' }];


        }
        this.structDeclaration({ structName, description: description || undefined, adoptedProtocols }, () => {
            this.printOnNewline(`public var graphQLMap: GraphQLMap`);
            this.printNewlineIfNeeded();
            this.printOnNewline(`public init`);
            this.print('(');
            this.print(printing_1.join(properties.map(({ propertyName, typeName, isOptional }) => printing_1.join([
            `${language_1.escapeIdentifierIfNeeded(propertyName)}: ${typeName}`,
            isOptional && ' = nil'])),
            ', '));
            this.print(')');
            this.withinBlock(() => {
                this.printOnNewline(printing_1.wrap(`graphQLMap = [`, printing_1.join(properties.map(({ name, propertyName }) => `"${name}": ${language_1.escapeIdentifierIfNeeded(propertyName)}`), ', ') || ':', `]`));
            });
            for (const { propertyName, typeName, description } of properties) {
                this.printNewlineIfNeeded();
                this.comment(description || undefined);
                this.printOnNewline(`public var ${language_1.escapeIdentifierIfNeeded(propertyName)}: ${typeName}`);
                this.withinBlock(() => {
                    this.printOnNewline('get');
                    this.withinBlock(() => {
                        this.printOnNewline(`return graphQLMap["${propertyName}"] as! ${typeName}`);
                    });
                    this.printOnNewline('set');
                    this.withinBlock(() => {
                        this.printOnNewline(`graphQLMap.updateValue(newValue, forKey: "${propertyName}")`);
                    });
                });
            }
        });
    }}

exports.SwiftAPIGenerator = SwiftAPIGenerator;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNwQix5QkFBSyxjQUFMLENBQW9CLEtBQXBCO0FBQ0EseUJBQUssV0FBTCxDQUFpQixNQUFLO0FBQ3BCLDZCQUFLLGNBQUwsQ0FBb0Isc0JBQXNCLFlBQVksVUFBVSxRQUFRLEVBQXhFO0FBQ0QscUJBRkQ7QUFHQSx5QkFBSyxjQUFMLENBQW9CLEtBQXBCO0FBQ0EseUJBQUssV0FBTCxDQUFpQixNQUFLO0FBQ3BCLDZCQUFLLGNBQUwsQ0FBb0IsNkNBQTZDLFlBQVksSUFBN0U7QUFDRCxxQkFGRDtBQUdELGlCQVREO0FBVUQ7QUFDRixTQW5ESDtBQXFERCxLQWx6Qm1FOztBQUF0RSxRQUFBLGlCQUFBLEdBQUEsaUJBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQge1xuICBHcmFwaFFMRXJyb3IsXG4gIEdyYXBoUUxUeXBlLFxuICBnZXROYW1lZFR5cGUsXG4gIGlzQ29tcG9zaXRlVHlwZSxcbiAgR3JhcGhRTEVudW1UeXBlLFxuICBpc05vbk51bGxUeXBlLFxuICBpc0xpc3RUeXBlLFxuICBHcmFwaFFMSW5wdXRPYmplY3RUeXBlXG59IGZyb20gJ2dyYXBocWwnO1xuXG5pbXBvcnQgeyBDb21waWxlckNvbnRleHQsIE9wZXJhdGlvbiwgRnJhZ21lbnQsIFNlbGVjdGlvblNldCwgRmllbGQgfSBmcm9tICcuLi9jb21waWxlcic7XG5cbmltcG9ydCB7IGpvaW4sIHdyYXAgfSBmcm9tICcuLi91dGlsaXRpZXMvcHJpbnRpbmcnO1xuXG5pbXBvcnQgeyBTd2lmdEdlbmVyYXRvciwgUHJvcGVydHksIGVzY2FwZUlkZW50aWZpZXJJZk5lZWRlZCwgU3RydWN0IH0gZnJvbSAnLi9sYW5ndWFnZSc7XG5pbXBvcnQgeyBIZWxwZXJzIH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7IHMzV3JhcHBlckNvZGUgfSBmcm9tICcuL3MzV3JhcHBlcic7XG5pbXBvcnQgeyBpc0xpc3QgfSBmcm9tICcuLi91dGlsaXRpZXMvZ3JhcGhxbCc7XG5cbmltcG9ydCB7IHR5cGVDYXNlRm9yU2VsZWN0aW9uU2V0LCBUeXBlQ2FzZSwgVmFyaWFudCB9IGZyb20gJy4uL2NvbXBpbGVyL3Zpc2l0b3JzL3R5cGVDYXNlJztcbmltcG9ydCB7IGNvbGxlY3RGcmFnbWVudHNSZWZlcmVuY2VkIH0gZnJvbSAnLi4vY29tcGlsZXIvdmlzaXRvcnMvY29sbGVjdEZyYWdtZW50c1JlZmVyZW5jZWQnO1xuaW1wb3J0IHsgZ2VuZXJhdGVPcGVyYXRpb25JZCB9IGZyb20gJy4uL2NvbXBpbGVyL3Zpc2l0b3JzL2dlbmVyYXRlT3BlcmF0aW9uSWQnO1xuaW1wb3J0IHsgY29sbGVjdEFuZE1lcmdlRmllbGRzIH0gZnJvbSAnLi4vY29tcGlsZXIvdmlzaXRvcnMvY29sbGVjdEFuZE1lcmdlRmllbGRzJztcblxuaW1wb3J0ICcuLi91dGlsaXRpZXMvYXJyYXknO1xuaW1wb3J0IHsgaXNTM0ZpZWxkIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2NvbXBsZXh0eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9ucyB7XG4gIG5hbWVzcGFjZT86IHN0cmluZztcbiAgcGFzc3Rocm91Z2hDdXN0b21TY2FsYXJzPzogYm9vbGVhbjtcbiAgY3VzdG9tU2NhbGFyc1ByZWZpeD86IHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlU291cmNlKFxuICBjb250ZXh0OiBDb21waWxlckNvbnRleHQsXG4gIG91dHB1dEluZGl2aWR1YWxGaWxlczogYm9vbGVhbixcbiAgb25seT86IHN0cmluZ1xuKTogU3dpZnRBUElHZW5lcmF0b3Ige1xuICBjb25zdCBnZW5lcmF0b3IgPSBuZXcgU3dpZnRBUElHZW5lcmF0b3IoY29udGV4dCk7XG5cbiAgaWYgKG91dHB1dEluZGl2aWR1YWxGaWxlcykge1xuICAgIGdlbmVyYXRvci53aXRoaW5GaWxlKGBUeXBlcy5ncmFwaHFsLnN3aWZ0YCwgKCkgPT4ge1xuICAgICAgZ2VuZXJhdG9yLmZpbGVIZWFkZXIoKTtcblxuICAgICAgZ2VuZXJhdG9yLm5hbWVzcGFjZURlY2xhcmF0aW9uKGNvbnRleHQub3B0aW9ucy5uYW1lc3BhY2UsICgpID0+IHtcbiAgICAgICAgY29udGV4dC50eXBlc1VzZWQuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgICAgICBnZW5lcmF0b3IudHlwZURlY2xhcmF0aW9uRm9yR3JhcGhRTFR5cGUodHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChjb250ZXh0Lm9wdGlvbnMuYWRkUzNXcmFwcGVyKSB7XG4gICAgICAgIGdlbmVyYXRvci5wcmludE9uTmV3bGluZShgXFxuJHtzM1dyYXBwZXJDb2RlfWApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgaW5wdXRGaWxlUGF0aHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAgIE9iamVjdC52YWx1ZXMoY29udGV4dC5vcGVyYXRpb25zKS5mb3JFYWNoKG9wZXJhdGlvbiA9PiB7XG4gICAgICBpbnB1dEZpbGVQYXRocy5hZGQob3BlcmF0aW9uLmZpbGVQYXRoKTtcbiAgICB9KTtcblxuICAgIE9iamVjdC52YWx1ZXMoY29udGV4dC5mcmFnbWVudHMpLmZvckVhY2goZnJhZ21lbnQgPT4ge1xuICAgICAgaW5wdXRGaWxlUGF0aHMuYWRkKGZyYWdtZW50LmZpbGVQYXRoKTtcbiAgICB9KTtcblxuICAgIGZvciAoY29uc3QgaW5wdXRGaWxlUGF0aCBvZiBpbnB1dEZpbGVQYXRocykge1xuICAgICAgaWYgKG9ubHkgJiYgaW5wdXRGaWxlUGF0aCAhPT0gb25seSkgY29udGludWU7XG5cbiAgICAgIGdlbmVyYXRvci53aXRoaW5GaWxlKGAke3BhdGguYmFzZW5hbWUoaW5wdXRGaWxlUGF0aCl9LnN3aWZ0YCwgKCkgPT4ge1xuICAgICAgICBnZW5lcmF0b3IuZmlsZUhlYWRlcigpO1xuXG4gICAgICAgIGdlbmVyYXRvci5uYW1lc3BhY2VFeHRlbnNpb25EZWNsYXJhdGlvbihjb250ZXh0Lm9wdGlvbnMubmFtZXNwYWNlLCAoKSA9PiB7XG4gICAgICAgICAgT2JqZWN0LnZhbHVlcyhjb250ZXh0Lm9wZXJhdGlvbnMpLmZvckVhY2gob3BlcmF0aW9uID0+IHtcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24uZmlsZVBhdGggPT09IGlucHV0RmlsZVBhdGgpIHtcbiAgICAgICAgICAgICAgZ2VuZXJhdG9yLmNsYXNzRGVjbGFyYXRpb25Gb3JPcGVyYXRpb24ob3BlcmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIE9iamVjdC52YWx1ZXMoY29udGV4dC5mcmFnbWVudHMpLmZvckVhY2goZnJhZ21lbnQgPT4ge1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50LmZpbGVQYXRoID09PSBpbnB1dEZpbGVQYXRoKSB7XG4gICAgICAgICAgICAgIGdlbmVyYXRvci5zdHJ1Y3REZWNsYXJhdGlvbkZvckZyYWdtZW50KGZyYWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZ2VuZXJhdG9yLmZpbGVIZWFkZXIoKTtcblxuICAgIGdlbmVyYXRvci5uYW1lc3BhY2VEZWNsYXJhdGlvbihjb250ZXh0Lm9wdGlvbnMubmFtZXNwYWNlLCAoKSA9PiB7XG4gICAgICBjb250ZXh0LnR5cGVzVXNlZC5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgICBnZW5lcmF0b3IudHlwZURlY2xhcmF0aW9uRm9yR3JhcGhRTFR5cGUodHlwZSk7XG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LnZhbHVlcyhjb250ZXh0Lm9wZXJhdGlvbnMpLmZvckVhY2gob3BlcmF0aW9uID0+IHtcbiAgICAgICAgZ2VuZXJhdG9yLmNsYXNzRGVjbGFyYXRpb25Gb3JPcGVyYXRpb24ob3BlcmF0aW9uKTtcbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QudmFsdWVzKGNvbnRleHQuZnJhZ21lbnRzKS5mb3JFYWNoKGZyYWdtZW50ID0+IHtcbiAgICAgICAgZ2VuZXJhdG9yLnN0cnVjdERlY2xhcmF0aW9uRm9yRnJhZ21lbnQoZnJhZ21lbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAoY29udGV4dC5vcHRpb25zLmFkZFMzV3JhcHBlcikge1xuICAgICAgZ2VuZXJhdG9yLnByaW50T25OZXdsaW5lKGBcXG4ke3MzV3JhcHBlckNvZGV9YCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdlbmVyYXRvcjtcbn1cblxuZXhwb3J0IGNsYXNzIFN3aWZ0QVBJR2VuZXJhdG9yIGV4dGVuZHMgU3dpZnRHZW5lcmF0b3I8Q29tcGlsZXJDb250ZXh0PiB7XG4gIGhlbHBlcnM6IEhlbHBlcnM7XG5cbiAgY29uc3RydWN0b3IoY29udGV4dDogQ29tcGlsZXJDb250ZXh0KSB7XG4gICAgc3VwZXIoY29udGV4dCk7XG5cbiAgICB0aGlzLmhlbHBlcnMgPSBuZXcgSGVscGVycyhjb250ZXh0Lm9wdGlvbnMpO1xuICB9XG5cbiAgZmlsZUhlYWRlcigpIHtcbiAgICB0aGlzLnByaW50T25OZXdsaW5lKCcvLyAgVGhpcyBmaWxlIHdhcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBhbmQgc2hvdWxkIG5vdCBiZSBlZGl0ZWQuJyk7XG4gICAgdGhpcy5wcmludE5ld2xpbmUoKTtcbiAgICB0aGlzLnByaW50T25OZXdsaW5lKCdpbXBvcnQgQVdTQXBwU3luYycpO1xuICB9XG5cbiAgY2xhc3NEZWNsYXJhdGlvbkZvck9wZXJhdGlvbihvcGVyYXRpb246IE9wZXJhdGlvbikge1xuICAgIGNvbnN0IHsgb3BlcmF0aW9uTmFtZSwgb3BlcmF0aW9uVHlwZSwgdmFyaWFibGVzLCBzb3VyY2UsIHNlbGVjdGlvblNldCB9ID0gb3BlcmF0aW9uO1xuXG4gICAgbGV0IGNsYXNzTmFtZTtcbiAgICBsZXQgcHJvdG9jb2w7XG5cbiAgICBzd2l0Y2ggKG9wZXJhdGlvblR5cGUpIHtcbiAgICAgIGNhc2UgJ3F1ZXJ5JzpcbiAgICAgICAgY2xhc3NOYW1lID0gYCR7dGhpcy5oZWxwZXJzLm9wZXJhdGlvbkNsYXNzTmFtZShvcGVyYXRpb25OYW1lKX1RdWVyeWA7XG4gICAgICAgIHByb3RvY29sID0gJ0dyYXBoUUxRdWVyeSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbXV0YXRpb24nOlxuICAgICAgICBjbGFzc05hbWUgPSBgJHt0aGlzLmhlbHBlcnMub3BlcmF0aW9uQ2xhc3NOYW1lKG9wZXJhdGlvbk5hbWUpfU11dGF0aW9uYDtcbiAgICAgICAgcHJvdG9jb2wgPSAnR3JhcGhRTE11dGF0aW9uJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdWJzY3JpcHRpb24nOlxuICAgICAgICBjbGFzc05hbWUgPSBgJHt0aGlzLmhlbHBlcnMub3BlcmF0aW9uQ2xhc3NOYW1lKG9wZXJhdGlvbk5hbWUpfVN1YnNjcmlwdGlvbmA7XG4gICAgICAgIHByb3RvY29sID0gJ0dyYXBoUUxTdWJzY3JpcHRpb24nO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoYFVuc3VwcG9ydGVkIG9wZXJhdGlvbiB0eXBlIFwiJHtvcGVyYXRpb25UeXBlfVwiYCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGFzc0RlY2xhcmF0aW9uKFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIG1vZGlmaWVyczogWydwdWJsaWMnLCAnZmluYWwnXSxcbiAgICAgICAgYWRvcHRlZFByb3RvY29sczogW3Byb3RvY29sXVxuICAgICAgfSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoJ3B1YmxpYyBzdGF0aWMgbGV0IG9wZXJhdGlvblN0cmluZyA9Jyk7XG4gICAgICAgICAgdGhpcy53aXRoSW5kZW50KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubXVsdGlsaW5lU3RyaW5nKHNvdXJjZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmcmFnbWVudHNSZWZlcmVuY2VkID0gY29sbGVjdEZyYWdtZW50c1JlZmVyZW5jZWQoXG4gICAgICAgICAgb3BlcmF0aW9uLnNlbGVjdGlvblNldCxcbiAgICAgICAgICB0aGlzLmNvbnRleHQuZnJhZ21lbnRzXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5vcHRpb25zLmdlbmVyYXRlT3BlcmF0aW9uSWRzKSB7XG4gICAgICAgICAgY29uc3QgeyBvcGVyYXRpb25JZCB9ID0gZ2VuZXJhdGVPcGVyYXRpb25JZChcbiAgICAgICAgICAgIG9wZXJhdGlvbixcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5mcmFnbWVudHMsXG4gICAgICAgICAgICBmcmFnbWVudHNSZWZlcmVuY2VkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBvcGVyYXRpb24ub3BlcmF0aW9uSWQgPSBvcGVyYXRpb25JZDtcbiAgICAgICAgICB0aGlzLnByaW50TmV3bGluZUlmTmVlZGVkKCk7XG4gICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgcHVibGljIHN0YXRpYyBsZXQgb3BlcmF0aW9uSWRlbnRpZmllcjogU3RyaW5nPyA9IFwiJHtvcGVyYXRpb25JZH1cImApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZyYWdtZW50c1JlZmVyZW5jZWQuc2l6ZSA+IDApIHtcbiAgICAgICAgICB0aGlzLnByaW50TmV3bGluZUlmTmVlZGVkKCk7XG4gICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZSgncHVibGljIHN0YXRpYyB2YXIgcmVxdWVzdFN0cmluZzogU3RyaW5nIHsgcmV0dXJuIG9wZXJhdGlvblN0cmluZycpO1xuICAgICAgICAgIGZyYWdtZW50c1JlZmVyZW5jZWQuZm9yRWFjaChmcmFnbWVudE5hbWUgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcmludChcbiAgICAgICAgICAgICAgYC5hcHBlbmRpbmcoJHt0aGlzLmhlbHBlcnMuc3RydWN0TmFtZUZvckZyYWdtZW50TmFtZShmcmFnbWVudE5hbWUpfS5mcmFnbWVudFN0cmluZylgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMucHJpbnQoJyB9Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByaW50TmV3bGluZUlmTmVlZGVkKCk7XG5cbiAgICAgICAgaWYgKHZhcmlhYmxlcyAmJiB2YXJpYWJsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB2YXJpYWJsZXMubWFwKCh7IG5hbWUsIHR5cGUgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHlwZU5hbWUgPSB0aGlzLmhlbHBlcnMudHlwZU5hbWVGcm9tR3JhcGhRTFR5cGUodHlwZSk7XG4gICAgICAgICAgICBjb25zdCBpc09wdGlvbmFsID0gIShcbiAgICAgICAgICAgICAgaXNOb25OdWxsVHlwZSh0eXBlKSB8fFxuICAgICAgICAgICAgICAoaXNMaXN0VHlwZSh0eXBlKSAmJiBpc05vbk51bGxUeXBlKHR5cGUub2ZUeXBlKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lLCBwcm9wZXJ0eU5hbWU6IG5hbWUsIHR5cGUsIHR5cGVOYW1lLCBpc09wdGlvbmFsIH07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aGlzLnByb3BlcnR5RGVjbGFyYXRpb25zKHByb3BlcnRpZXMpO1xuXG4gICAgICAgICAgdGhpcy5wcmludE5ld2xpbmVJZk5lZWRlZCgpO1xuICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZXJEZWNsYXJhdGlvbkZvclByb3BlcnRpZXMocHJvcGVydGllcyk7XG5cbiAgICAgICAgICB0aGlzLnByaW50TmV3bGluZUlmTmVlZGVkKCk7XG4gICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgcHVibGljIHZhciB2YXJpYWJsZXM6IEdyYXBoUUxNYXA/YCk7XG4gICAgICAgICAgdGhpcy53aXRoaW5CbG9jaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKFxuICAgICAgICAgICAgICB3cmFwKFxuICAgICAgICAgICAgICAgIGByZXR1cm4gW2AsXG4gICAgICAgICAgICAgICAgam9pbihcbiAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMubWFwKFxuICAgICAgICAgICAgICAgICAgICAoeyBuYW1lLCBwcm9wZXJ0eU5hbWUgfSkgPT5cbiAgICAgICAgICAgICAgICAgICAgICBgXCIke25hbWV9XCI6ICR7ZXNjYXBlSWRlbnRpZmllcklmTmVlZGVkKHByb3BlcnR5TmFtZSl9YFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICcsICdcbiAgICAgICAgICAgICAgICApIHx8ICc6JyxcbiAgICAgICAgICAgICAgICBgXWBcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmluaXRpYWxpemVyRGVjbGFyYXRpb25Gb3JQcm9wZXJ0aWVzKFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RydWN0RGVjbGFyYXRpb25Gb3JTZWxlY3Rpb25TZXQoe1xuICAgICAgICAgIHN0cnVjdE5hbWU6ICdEYXRhJyxcbiAgICAgICAgICBzZWxlY3Rpb25TZXRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIHN0cnVjdERlY2xhcmF0aW9uRm9yRnJhZ21lbnQoeyBmcmFnbWVudE5hbWUsIHNlbGVjdGlvblNldCwgc291cmNlIH06IEZyYWdtZW50KSB7XG4gICAgY29uc3Qgc3RydWN0TmFtZSA9IHRoaXMuaGVscGVycy5zdHJ1Y3ROYW1lRm9yRnJhZ21lbnROYW1lKGZyYWdtZW50TmFtZSk7XG5cbiAgICB0aGlzLnN0cnVjdERlY2xhcmF0aW9uRm9yU2VsZWN0aW9uU2V0KFxuICAgICAge1xuICAgICAgICBzdHJ1Y3ROYW1lLFxuICAgICAgICBhZG9wdGVkUHJvdG9jb2xzOiBbJ0dyYXBoUUxGcmFnbWVudCddLFxuICAgICAgICBzZWxlY3Rpb25TZXRcbiAgICAgIH0sXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKCdwdWJsaWMgc3RhdGljIGxldCBmcmFnbWVudFN0cmluZyA9Jyk7XG4gICAgICAgICAgdGhpcy53aXRoSW5kZW50KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubXVsdGlsaW5lU3RyaW5nKHNvdXJjZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgc3RydWN0RGVjbGFyYXRpb25Gb3JTZWxlY3Rpb25TZXQoXG4gICAge1xuICAgICAgc3RydWN0TmFtZSxcbiAgICAgIGFkb3B0ZWRQcm90b2NvbHMgPSBbJ0dyYXBoUUxTZWxlY3Rpb25TZXQnXSxcbiAgICAgIHNlbGVjdGlvblNldFxuICAgIH06IHtcbiAgICAgIHN0cnVjdE5hbWU6IHN0cmluZztcbiAgICAgIGFkb3B0ZWRQcm90b2NvbHM/OiBzdHJpbmdbXTtcbiAgICAgIHNlbGVjdGlvblNldDogU2VsZWN0aW9uU2V0O1xuICAgIH0sXG4gICAgYmVmb3JlPzogRnVuY3Rpb25cbiAgKSB7XG4gICAgY29uc3QgdHlwZUNhc2UgPSB0eXBlQ2FzZUZvclNlbGVjdGlvblNldChcbiAgICAgIHNlbGVjdGlvblNldCxcbiAgICAgIHRoaXMuY29udGV4dC5vcHRpb25zLm1lcmdlSW5GaWVsZHNGcm9tRnJhZ21lbnRTcHJlYWRzXG4gICAgKTtcblxuICAgIHRoaXMuc3RydWN0RGVjbGFyYXRpb25Gb3JWYXJpYW50KFxuICAgICAge1xuICAgICAgICBzdHJ1Y3ROYW1lLFxuICAgICAgICBhZG9wdGVkUHJvdG9jb2xzLFxuICAgICAgICB2YXJpYW50OiB0eXBlQ2FzZS5kZWZhdWx0LFxuICAgICAgICB0eXBlQ2FzZVxuICAgICAgfSxcbiAgICAgIGJlZm9yZSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgY29uc3QgdmFyaWFudHMgPSB0eXBlQ2FzZS52YXJpYW50cy5tYXAodGhpcy5oZWxwZXJzLnByb3BlcnR5RnJvbVZhcmlhbnQsIHRoaXMuaGVscGVycyk7XG5cbiAgICAgICAgZm9yIChjb25zdCB2YXJpYW50IG9mIHZhcmlhbnRzKSB7XG4gICAgICAgICAgdGhpcy5wcm9wZXJ0eURlY2xhcmF0aW9uRm9yVmFyaWFudCh2YXJpYW50KTtcblxuICAgICAgICAgIHRoaXMuc3RydWN0RGVjbGFyYXRpb25Gb3JWYXJpYW50KHtcbiAgICAgICAgICAgIHN0cnVjdE5hbWU6IHZhcmlhbnQuc3RydWN0TmFtZSxcbiAgICAgICAgICAgIHZhcmlhbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH1cblxuICBzdHJ1Y3REZWNsYXJhdGlvbkZvclZhcmlhbnQoXG4gICAge1xuICAgICAgc3RydWN0TmFtZSxcbiAgICAgIGFkb3B0ZWRQcm90b2NvbHMgPSBbJ0dyYXBoUUxTZWxlY3Rpb25TZXQnXSxcbiAgICAgIHZhcmlhbnQsXG4gICAgICB0eXBlQ2FzZVxuICAgIH06IHtcbiAgICAgIHN0cnVjdE5hbWU6IHN0cmluZztcbiAgICAgIGFkb3B0ZWRQcm90b2NvbHM/OiBzdHJpbmdbXTtcbiAgICAgIHZhcmlhbnQ6IFZhcmlhbnQ7XG4gICAgICB0eXBlQ2FzZT86IFR5cGVDYXNlO1xuICAgIH0sXG4gICAgYmVmb3JlPzogRnVuY3Rpb24sXG4gICAgYWZ0ZXI/OiBGdW5jdGlvblxuICApIHtcbiAgICB0aGlzLnN0cnVjdERlY2xhcmF0aW9uKHsgc3RydWN0TmFtZSwgYWRvcHRlZFByb3RvY29scyB9LCAoKSA9PiB7XG4gICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgIGJlZm9yZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByaW50TmV3bGluZUlmTmVlZGVkKCk7XG4gICAgICB0aGlzLnByaW50T25OZXdsaW5lKCdwdWJsaWMgc3RhdGljIGxldCBwb3NzaWJsZVR5cGVzID0gWycpO1xuICAgICAgdGhpcy5wcmludChqb2luKHZhcmlhbnQucG9zc2libGVUeXBlcy5tYXAodHlwZSA9PiBgXCIke3R5cGUubmFtZX1cImApLCAnLCAnKSk7XG4gICAgICB0aGlzLnByaW50KCddJyk7XG5cbiAgICAgIHRoaXMucHJpbnROZXdsaW5lSWZOZWVkZWQoKTtcbiAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoJ3B1YmxpYyBzdGF0aWMgbGV0IHNlbGVjdGlvbnM6IFtHcmFwaFFMU2VsZWN0aW9uXSA9ICcpO1xuICAgICAgaWYgKHR5cGVDYXNlKSB7XG4gICAgICAgIHRoaXMudHlwZUNhc2VJbml0aWFsaXphdGlvbih0eXBlQ2FzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNldEluaXRpYWxpemF0aW9uKHZhcmlhbnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByaW50TmV3bGluZUlmTmVlZGVkKCk7XG5cbiAgICAgIHRoaXMucHJvcGVydHlEZWNsYXJhdGlvbih7XG4gICAgICAgIHByb3BlcnR5TmFtZTogJ3NuYXBzaG90JyxcbiAgICAgICAgdHlwZU5hbWU6ICdTbmFwc2hvdCdcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnByaW50TmV3bGluZUlmTmVlZGVkKCk7XG4gICAgICB0aGlzLnByaW50T25OZXdsaW5lKCdwdWJsaWMgaW5pdChzbmFwc2hvdDogU25hcHNob3QpJyk7XG4gICAgICB0aGlzLndpdGhpbkJsb2NrKCgpID0+IHtcbiAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgc2VsZi5zbmFwc2hvdCA9IHNuYXBzaG90YCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVDYXNlKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZXJzRm9yVHlwZUNhc2UodHlwZUNhc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplcnNGb3JWYXJpYW50KHZhcmlhbnQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmaWVsZHMgPSBjb2xsZWN0QW5kTWVyZ2VGaWVsZHMoXG4gICAgICAgIHZhcmlhbnQsXG4gICAgICAgIHRoaXMuY29udGV4dC5vcHRpb25zLm1lcmdlSW5GaWVsZHNGcm9tRnJhZ21lbnRTcHJlYWRzXG4gICAgICApLm1hcChmaWVsZCA9PiB0aGlzLmhlbHBlcnMucHJvcGVydHlGcm9tRmllbGQoZmllbGQgYXMgRmllbGQpKTtcblxuICAgICAgY29uc3QgZnJhZ21lbnRTcHJlYWRzID0gdmFyaWFudC5mcmFnbWVudFNwcmVhZHMubWFwKGZyYWdtZW50U3ByZWFkID0+IHtcbiAgICAgICAgY29uc3QgaXNDb25kaXRpb25hbCA9IHZhcmlhbnQucG9zc2libGVUeXBlcy5zb21lKFxuICAgICAgICAgIHR5cGUgPT4gIWZyYWdtZW50U3ByZWFkLnNlbGVjdGlvblNldC5wb3NzaWJsZVR5cGVzLmluY2x1ZGVzKHR5cGUpXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaGVscGVycy5wcm9wZXJ0eUZyb21GcmFnbWVudFNwcmVhZChmcmFnbWVudFNwcmVhZCwgaXNDb25kaXRpb25hbCk7XG4gICAgICB9KTtcblxuICAgICAgZmllbGRzLmZvckVhY2godGhpcy5wcm9wZXJ0eURlY2xhcmF0aW9uRm9yRmllbGQsIHRoaXMpO1xuXG4gICAgICBpZiAoZnJhZ21lbnRTcHJlYWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5wcmludE5ld2xpbmVJZk5lZWRlZCgpO1xuICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKGBwdWJsaWMgdmFyIGZyYWdtZW50czogRnJhZ21lbnRzYCk7XG4gICAgICAgIHRoaXMud2l0aGluQmxvY2soKCkgPT4ge1xuICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoJ2dldCcpO1xuICAgICAgICAgIHRoaXMud2l0aGluQmxvY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgcmV0dXJuIEZyYWdtZW50cyhzbmFwc2hvdDogc25hcHNob3QpYCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZSgnc2V0Jyk7XG4gICAgICAgICAgdGhpcy53aXRoaW5CbG9jaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKGBzbmFwc2hvdCArPSBuZXdWYWx1ZS5zbmFwc2hvdGApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnN0cnVjdERlY2xhcmF0aW9uKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0cnVjdE5hbWU6ICdGcmFnbWVudHMnXG4gICAgICAgICAgfSxcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnR5RGVjbGFyYXRpb24oe1xuICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWU6ICdzbmFwc2hvdCcsXG4gICAgICAgICAgICAgIHR5cGVOYW1lOiAnU25hcHNob3QnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBmcmFnbWVudFNwcmVhZCBvZiBmcmFnbWVudFNwcmVhZHMpIHtcbiAgICAgICAgICAgICAgY29uc3QgeyBwcm9wZXJ0eU5hbWUsIHR5cGVOYW1lLCBzdHJ1Y3ROYW1lLCBpc0NvbmRpdGlvbmFsIH0gPSBmcmFnbWVudFNwcmVhZDtcblxuICAgICAgICAgICAgICB0aGlzLnByaW50TmV3bGluZUlmTmVlZGVkKCk7XG4gICAgICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoXG4gICAgICAgICAgICAgICAgYHB1YmxpYyB2YXIgJHtlc2NhcGVJZGVudGlmaWVySWZOZWVkZWQocHJvcGVydHlOYW1lKX06ICR7dHlwZU5hbWV9YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0aGlzLndpdGhpbkJsb2NrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKCdnZXQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLndpdGhpbkJsb2NrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChpc0NvbmRpdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoXG4gICAgICAgICAgICAgICAgICAgICAgYGlmICEke3N0cnVjdE5hbWV9LnBvc3NpYmxlVHlwZXMuY29udGFpbnMoc25hcHNob3RbXCJfX3R5cGVuYW1lXCJdISBhcyEgU3RyaW5nKSB7IHJldHVybiBuaWwgfWBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoYHJldHVybiAke3N0cnVjdE5hbWV9KHNuYXBzaG90OiBzbmFwc2hvdClgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKCdzZXQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLndpdGhpbkJsb2NrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChpc0NvbmRpdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoYGd1YXJkIGxldCBuZXdWYWx1ZSA9IG5ld1ZhbHVlIGVsc2UgeyByZXR1cm4gfWApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKGBzbmFwc2hvdCArPSBuZXdWYWx1ZS5zbmFwc2hvdGApO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgc25hcHNob3QgKz0gbmV3VmFsdWUuc25hcHNob3RgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICBpZiAoaXNDb21wb3NpdGVUeXBlKGdldE5hbWVkVHlwZShmaWVsZC50eXBlKSkgJiYgZmllbGQuc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgICAgdGhpcy5zdHJ1Y3REZWNsYXJhdGlvbkZvclNlbGVjdGlvblNldCh7XG4gICAgICAgICAgICBzdHJ1Y3ROYW1lOiBmaWVsZC5zdHJ1Y3ROYW1lLFxuICAgICAgICAgICAgc2VsZWN0aW9uU2V0OiBmaWVsZC5zZWxlY3Rpb25TZXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgYWZ0ZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGluaXRpYWxpemVyc0ZvclR5cGVDYXNlKHR5cGVDYXNlOiBUeXBlQ2FzZSkge1xuICAgIGNvbnN0IHZhcmlhbnRzID0gdHlwZUNhc2UudmFyaWFudHM7XG5cbiAgICBpZiAodmFyaWFudHMubGVuZ3RoID09IDApIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZXJzRm9yVmFyaWFudCh0eXBlQ2FzZS5kZWZhdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVtYWluZGVyID0gdHlwZUNhc2UucmVtYWluZGVyO1xuICAgICAgZm9yIChjb25zdCB2YXJpYW50IG9mIHJlbWFpbmRlciA/IFtyZW1haW5kZXIsIC4uLnZhcmlhbnRzXSA6IHZhcmlhbnRzKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZXJzRm9yVmFyaWFudChcbiAgICAgICAgICB2YXJpYW50LFxuICAgICAgICAgIHZhcmlhbnQgPT09IHJlbWFpbmRlciA/IHVuZGVmaW5lZCA6IHRoaXMuaGVscGVycy5zdHJ1Y3ROYW1lRm9yVmFyaWFudCh2YXJpYW50KSxcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGluaXRpYWxpemVyc0ZvclZhcmlhbnQoXG4gICAgdmFyaWFudDogVmFyaWFudCxcbiAgICBuYW1lc3BhY2U/OiBzdHJpbmcsXG4gICAgdXNlSW5pdGlhbGl6ZXJJZlBvc3NpYmxlOiBib29sZWFuID0gdHJ1ZVxuICApIHtcbiAgICBpZiAodXNlSW5pdGlhbGl6ZXJJZlBvc3NpYmxlICYmIHZhcmlhbnQucG9zc2libGVUeXBlcy5sZW5ndGggPT0gMSkge1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHRoaXMuaGVscGVycy5wcm9wZXJ0aWVzRm9yU2VsZWN0aW9uU2V0KHZhcmlhbnQpO1xuICAgICAgaWYgKCFwcm9wZXJ0aWVzKSByZXR1cm47XG5cbiAgICAgIHRoaXMucHJpbnROZXdsaW5lSWZOZWVkZWQoKTtcbiAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoYHB1YmxpYyBpbml0YCk7XG5cbiAgICAgIHRoaXMucGFyYW1ldGVyc0ZvclByb3BlcnRpZXMocHJvcGVydGllcyk7XG5cbiAgICAgIHRoaXMud2l0aGluQmxvY2soKCkgPT4ge1xuICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKFxuICAgICAgICAgIHdyYXAoXG4gICAgICAgICAgICBgc2VsZi5pbml0KHNuYXBzaG90OiBbYCxcbiAgICAgICAgICAgIGpvaW4oXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBgXCJfX3R5cGVuYW1lXCI6IFwiJHt2YXJpYW50LnBvc3NpYmxlVHlwZXNbMF19XCJgLFxuICAgICAgICAgICAgICAgIC4uLnByb3BlcnRpZXMubWFwKHRoaXMucHJvcGVydHlBc3NpZ25tZW50Rm9yRmllbGQsIHRoaXMpXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICcsICdcbiAgICAgICAgICAgICkgfHwgJzonLFxuICAgICAgICAgICAgYF0pYFxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdHJ1Y3ROYW1lID0gdGhpcy5zY29wZS50eXBlTmFtZTtcblxuICAgICAgZm9yIChjb25zdCBwb3NzaWJsZVR5cGUgb2YgdmFyaWFudC5wb3NzaWJsZVR5cGVzKSB7XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB0aGlzLmhlbHBlcnMucHJvcGVydGllc0ZvclNlbGVjdGlvblNldChcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwb3NzaWJsZVR5cGVzOiBbcG9zc2libGVUeXBlXSxcbiAgICAgICAgICAgIHNlbGVjdGlvbnM6IHZhcmlhbnQuc2VsZWN0aW9uc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbmFtZXNwYWNlXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCFwcm9wZXJ0aWVzKSBjb250aW51ZTtcblxuICAgICAgICB0aGlzLnByaW50TmV3bGluZUlmTmVlZGVkKCk7XG4gICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoYHB1YmxpYyBzdGF0aWMgZnVuYyBtYWtlJHtwb3NzaWJsZVR5cGV9YCk7XG5cbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzRm9yUHJvcGVydGllcyhwcm9wZXJ0aWVzKTtcblxuICAgICAgICB0aGlzLnByaW50KGAgLT4gJHtzdHJ1Y3ROYW1lfWApO1xuXG4gICAgICAgIHRoaXMud2l0aGluQmxvY2soKCkgPT4ge1xuICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoXG4gICAgICAgICAgICB3cmFwKFxuICAgICAgICAgICAgICBgcmV0dXJuICR7c3RydWN0TmFtZX0oc25hcHNob3Q6IFtgLFxuICAgICAgICAgICAgICBqb2luKFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgIGBcIl9fdHlwZW5hbWVcIjogXCIke3Bvc3NpYmxlVHlwZX1cImAsXG4gICAgICAgICAgICAgICAgICAuLi5wcm9wZXJ0aWVzLm1hcCh0aGlzLnByb3BlcnR5QXNzaWdubWVudEZvckZpZWxkLCB0aGlzKVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgJywgJ1xuICAgICAgICAgICAgICApIHx8ICc6JyxcbiAgICAgICAgICAgICAgYF0pYFxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3BlcnR5QXNzaWdubWVudEZvckZpZWxkKGZpZWxkOiB7XG4gICAgcmVzcG9uc2VLZXk6IHN0cmluZztcbiAgICBwcm9wZXJ0eU5hbWU6IHN0cmluZztcbiAgICB0eXBlOiBHcmFwaFFMVHlwZTtcbiAgfSkge1xuICAgIGNvbnN0IHsgcmVzcG9uc2VLZXksIHByb3BlcnR5TmFtZSwgdHlwZSB9ID0gZmllbGQ7XG4gICAgY29uc3QgdmFsdWVFeHByZXNzaW9uID0gaXNDb21wb3NpdGVUeXBlKGdldE5hbWVkVHlwZSh0eXBlKSlcbiAgICAgID8gdGhpcy5oZWxwZXJzLm1hcEV4cHJlc3Npb25Gb3JUeXBlKFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgaWRlbnRpZmllciA9PiBgJHtpZGVudGlmaWVyfS5zbmFwc2hvdGAsXG4gICAgICAgICAgZXNjYXBlSWRlbnRpZmllcklmTmVlZGVkKHByb3BlcnR5TmFtZSlcbiAgICAgICAgKVxuICAgICAgOiBlc2NhcGVJZGVudGlmaWVySWZOZWVkZWQocHJvcGVydHlOYW1lKTtcbiAgICByZXR1cm4gYFwiJHtyZXNwb25zZUtleX1cIjogJHt2YWx1ZUV4cHJlc3Npb259YDtcbiAgfVxuXG4gIHByb3BlcnR5RGVjbGFyYXRpb25Gb3JGaWVsZChmaWVsZDogRmllbGQgJiBQcm9wZXJ0eSkge1xuICAgIGNvbnN0IHsgcmVzcG9uc2VLZXksIHByb3BlcnR5TmFtZSwgdHlwZU5hbWUsIHR5cGUsIGlzT3B0aW9uYWwgfSA9IGZpZWxkO1xuXG4gICAgY29uc3QgdW5tb2RpZmllZEZpZWxkVHlwZSA9IGdldE5hbWVkVHlwZSh0eXBlKTtcblxuICAgIHRoaXMucHJpbnROZXdsaW5lSWZOZWVkZWQoKTtcblxuICAgIHRoaXMuY29tbWVudChmaWVsZC5kZXNjcmlwdGlvbik7XG4gICAgdGhpcy5kZXByZWNhdGlvbkF0dHJpYnV0ZXMoZmllbGQuaXNEZXByZWNhdGVkLCBmaWVsZC5kZXByZWNhdGlvblJlYXNvbik7XG5cbiAgICB0aGlzLnByaW50T25OZXdsaW5lKGBwdWJsaWMgdmFyICR7ZXNjYXBlSWRlbnRpZmllcklmTmVlZGVkKHByb3BlcnR5TmFtZSl9OiAke3R5cGVOYW1lfWApO1xuICAgIHRoaXMud2l0aGluQmxvY2soKCkgPT4ge1xuICAgICAgaWYgKGlzQ29tcG9zaXRlVHlwZSh1bm1vZGlmaWVkRmllbGRUeXBlKSkge1xuICAgICAgICBjb25zdCBzdHJ1Y3ROYW1lID0gZXNjYXBlSWRlbnRpZmllcklmTmVlZGVkKFxuICAgICAgICAgIHRoaXMuaGVscGVycy5zdHJ1Y3ROYW1lRm9yUHJvcGVydHlOYW1lKHByb3BlcnR5TmFtZSlcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaXNMaXN0KHR5cGUpKSB7XG4gICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZSgnZ2V0Jyk7XG4gICAgICAgICAgdGhpcy53aXRoaW5CbG9jaygoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzbmFwc2hvdFR5cGVOYW1lID0gdGhpcy5oZWxwZXJzLnR5cGVOYW1lRnJvbUdyYXBoUUxUeXBlKHR5cGUsICdTbmFwc2hvdCcsIGZhbHNlKTtcbiAgICAgICAgICAgIGxldCBnZXR0ZXI7XG4gICAgICAgICAgICBpZiAoaXNPcHRpb25hbCkge1xuICAgICAgICAgICAgICBnZXR0ZXIgPSBgcmV0dXJuIChzbmFwc2hvdFtcIiR7cmVzcG9uc2VLZXl9XCJdIGFzPyAke3NuYXBzaG90VHlwZU5hbWV9KWA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBnZXR0ZXIgPSBgcmV0dXJuIChzbmFwc2hvdFtcIiR7cmVzcG9uc2VLZXl9XCJdIGFzISAke3NuYXBzaG90VHlwZU5hbWV9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZXR0ZXIgKz0gdGhpcy5oZWxwZXJzLm1hcEV4cHJlc3Npb25Gb3JUeXBlKFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBpZGVudGlmaWVyID0+IGAke3N0cnVjdE5hbWV9KHNuYXBzaG90OiAke2lkZW50aWZpZXJ9KWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKGdldHRlcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZSgnc2V0Jyk7XG4gICAgICAgICAgdGhpcy53aXRoaW5CbG9jaygoKSA9PiB7XG4gICAgICAgICAgICBsZXQgbmV3VmFsdWVFeHByZXNzaW9uID0gdGhpcy5oZWxwZXJzLm1hcEV4cHJlc3Npb25Gb3JUeXBlKFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBpZGVudGlmaWVyID0+IGAke2lkZW50aWZpZXJ9LnNuYXBzaG90YCxcbiAgICAgICAgICAgICAgJ25ld1ZhbHVlJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoXG4gICAgICAgICAgICAgIGBzbmFwc2hvdC51cGRhdGVWYWx1ZSgke25ld1ZhbHVlRXhwcmVzc2lvbn0sIGZvcktleTogXCIke3Jlc3BvbnNlS2V5fVwiKWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZSgnZ2V0Jyk7XG4gICAgICAgICAgdGhpcy53aXRoaW5CbG9jaygoKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNPcHRpb25hbCkge1xuICAgICAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKFxuICAgICAgICAgICAgICAgIGByZXR1cm4gKHNuYXBzaG90W1wiJHtyZXNwb25zZUtleX1cIl0gYXM/IFNuYXBzaG90KS5mbGF0TWFwIHsgJHtzdHJ1Y3ROYW1lfShzbmFwc2hvdDogJDApIH1gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKFxuICAgICAgICAgICAgICAgIGByZXR1cm4gJHtzdHJ1Y3ROYW1lfShzbmFwc2hvdDogc25hcHNob3RbXCIke3Jlc3BvbnNlS2V5fVwiXSEgYXMhIFNuYXBzaG90KWBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKCdzZXQnKTtcbiAgICAgICAgICB0aGlzLndpdGhpbkJsb2NrKCgpID0+IHtcbiAgICAgICAgICAgIGxldCBuZXdWYWx1ZUV4cHJlc3Npb247XG4gICAgICAgICAgICBpZiAoaXNPcHRpb25hbCkge1xuICAgICAgICAgICAgICBuZXdWYWx1ZUV4cHJlc3Npb24gPSAnbmV3VmFsdWU/LnNuYXBzaG90JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld1ZhbHVlRXhwcmVzc2lvbiA9ICduZXdWYWx1ZS5zbmFwc2hvdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKFxuICAgICAgICAgICAgICBgc25hcHNob3QudXBkYXRlVmFsdWUoJHtuZXdWYWx1ZUV4cHJlc3Npb259LCBmb3JLZXk6IFwiJHtyZXNwb25zZUtleX1cIilgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKCdnZXQnKTtcbiAgICAgICAgdGhpcy53aXRoaW5CbG9jaygoKSA9PiB7XG4gICAgICAgICAgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoYHJldHVybiBzbmFwc2hvdFtcIiR7cmVzcG9uc2VLZXl9XCJdIGFzPyAke3R5cGVOYW1lLnNsaWNlKDAsIC0xKX1gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgcmV0dXJuIHNuYXBzaG90W1wiJHtyZXNwb25zZUtleX1cIl0hIGFzISAke3R5cGVOYW1lfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoJ3NldCcpO1xuICAgICAgICB0aGlzLndpdGhpbkJsb2NrKCgpID0+IHtcbiAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKGBzbmFwc2hvdC51cGRhdGVWYWx1ZShuZXdWYWx1ZSwgZm9yS2V5OiBcIiR7cmVzcG9uc2VLZXl9XCIpYCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHJvcGVydHlEZWNsYXJhdGlvbkZvclZhcmlhbnQodmFyaWFudDogUHJvcGVydHkgJiBTdHJ1Y3QpIHtcbiAgICBjb25zdCB7IHByb3BlcnR5TmFtZSwgdHlwZU5hbWUsIHN0cnVjdE5hbWUgfSA9IHZhcmlhbnQ7XG5cbiAgICB0aGlzLnByaW50TmV3bGluZUlmTmVlZGVkKCk7XG4gICAgdGhpcy5wcmludE9uTmV3bGluZShgcHVibGljIHZhciAke2VzY2FwZUlkZW50aWZpZXJJZk5lZWRlZChwcm9wZXJ0eU5hbWUpfTogJHt0eXBlTmFtZX1gKTtcbiAgICB0aGlzLndpdGhpbkJsb2NrKCgpID0+IHtcbiAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoJ2dldCcpO1xuICAgICAgdGhpcy53aXRoaW5CbG9jaygoKSA9PiB7XG4gICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoYGlmICEke3N0cnVjdE5hbWV9LnBvc3NpYmxlVHlwZXMuY29udGFpbnMoX190eXBlbmFtZSkgeyByZXR1cm4gbmlsIH1gKTtcbiAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgcmV0dXJuICR7c3RydWN0TmFtZX0oc25hcHNob3Q6IHNuYXBzaG90KWApO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnByaW50T25OZXdsaW5lKCdzZXQnKTtcbiAgICAgIHRoaXMud2l0aGluQmxvY2soKCkgPT4ge1xuICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKGBndWFyZCBsZXQgbmV3VmFsdWUgPSBuZXdWYWx1ZSBlbHNlIHsgcmV0dXJuIH1gKTtcbiAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgc25hcHNob3QgPSBuZXdWYWx1ZS5zbmFwc2hvdGApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBpbml0aWFsaXplckRlY2xhcmF0aW9uRm9yUHJvcGVydGllcyhwcm9wZXJ0aWVzOiBQcm9wZXJ0eVtdKSB7XG4gICAgdGhpcy5wcmludE9uTmV3bGluZShgcHVibGljIGluaXRgKTtcbiAgICB0aGlzLnBhcmFtZXRlcnNGb3JQcm9wZXJ0aWVzKHByb3BlcnRpZXMpO1xuXG4gICAgdGhpcy53aXRoaW5CbG9jaygoKSA9PiB7XG4gICAgICBwcm9wZXJ0aWVzLmZvckVhY2goKHsgcHJvcGVydHlOYW1lIH0pID0+IHtcbiAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgc2VsZi4ke3Byb3BlcnR5TmFtZX0gPSAke2VzY2FwZUlkZW50aWZpZXJJZk5lZWRlZChwcm9wZXJ0eU5hbWUpfWApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBwYXJhbWV0ZXJzRm9yUHJvcGVydGllcyhwcm9wZXJ0aWVzOiBQcm9wZXJ0eVtdKSB7XG4gICAgdGhpcy5wcmludCgnKCcpO1xuICAgIHRoaXMucHJpbnQoXG4gICAgICBqb2luKFxuICAgICAgICBwcm9wZXJ0aWVzLm1hcCgoeyBwcm9wZXJ0eU5hbWUsIHR5cGVOYW1lLCBpc09wdGlvbmFsIH0pID0+XG4gICAgICAgICAgam9pbihbYCR7ZXNjYXBlSWRlbnRpZmllcklmTmVlZGVkKHByb3BlcnR5TmFtZSl9OiAke3R5cGVOYW1lfWAsIGlzT3B0aW9uYWwgJiYgJyA9IG5pbCddKVxuICAgICAgICApLFxuICAgICAgICAnLCAnXG4gICAgICApXG4gICAgKTtcbiAgICB0aGlzLnByaW50KCcpJyk7XG4gIH1cblxuICB0eXBlQ2FzZUluaXRpYWxpemF0aW9uKHR5cGVDYXNlOiBUeXBlQ2FzZSkge1xuICAgIGlmICh0eXBlQ2FzZS52YXJpYW50cy5sZW5ndGggPCAxKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvblNldEluaXRpYWxpemF0aW9uKHR5cGVDYXNlLmRlZmF1bHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucHJpbnQoJ1snKTtcbiAgICB0aGlzLndpdGhJbmRlbnQoKCkgPT4ge1xuICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgR3JhcGhRTFR5cGVDYXNlKGApO1xuICAgICAgdGhpcy53aXRoSW5kZW50KCgpID0+IHtcbiAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgdmFyaWFudHM6IFtgKTtcbiAgICAgICAgdGhpcy5wcmludChcbiAgICAgICAgICB0eXBlQ2FzZS52YXJpYW50c1xuICAgICAgICAgICAgLmZsYXRNYXAodmFyaWFudCA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHN0cnVjdE5hbWUgPSB0aGlzLmhlbHBlcnMuc3RydWN0TmFtZUZvclZhcmlhbnQodmFyaWFudCk7XG4gICAgICAgICAgICAgIHJldHVybiB2YXJpYW50LnBvc3NpYmxlVHlwZXMubWFwKHR5cGUgPT4gYFwiJHt0eXBlfVwiOiAke3N0cnVjdE5hbWV9LnNlbGVjdGlvbnNgKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignLCAnKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnByaW50KCddLCcpO1xuICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKGBkZWZhdWx0OiBgKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXRJbml0aWFsaXphdGlvbih0eXBlQ2FzZS5kZWZhdWx0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcmludE9uTmV3bGluZSgnKScpO1xuICAgIH0pO1xuICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoJ10nKTtcbiAgfVxuXG4gIHNlbGVjdGlvblNldEluaXRpYWxpemF0aW9uKHNlbGVjdGlvblNldDogU2VsZWN0aW9uU2V0KSB7XG4gICAgdGhpcy5wcmludCgnWycpO1xuICAgIHRoaXMud2l0aEluZGVudCgoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHNlbGVjdGlvbiBvZiBzZWxlY3Rpb25TZXQuc2VsZWN0aW9ucykge1xuICAgICAgICBzd2l0Y2ggKHNlbGVjdGlvbi5raW5kKSB7XG4gICAgICAgICAgY2FzZSAnRmllbGQnOiB7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIGFsaWFzLCBhcmdzLCB0eXBlIH0gPSBzZWxlY3Rpb247XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUtleSA9IHNlbGVjdGlvbi5hbGlhcyB8fCBzZWxlY3Rpb24ubmFtZTtcbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdE5hbWUgPSB0aGlzLmhlbHBlcnMuc3RydWN0TmFtZUZvclByb3BlcnR5TmFtZShyZXNwb25zZUtleSk7XG5cbiAgICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoYEdyYXBoUUxGaWVsZChgKTtcbiAgICAgICAgICAgIHRoaXMucHJpbnQoXG4gICAgICAgICAgICAgIGpvaW4oXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgYFwiJHtuYW1lfVwiYCxcbiAgICAgICAgICAgICAgICAgIGFsaWFzID8gYGFsaWFzOiBcIiR7YWxpYXN9XCJgIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgIGFyZ3MgJiZcbiAgICAgICAgICAgICAgICAgICAgYXJncy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgYGFyZ3VtZW50czogJHt0aGlzLmhlbHBlcnMuZGljdGlvbmFyeUxpdGVyYWxGb3JGaWVsZEFyZ3VtZW50cyhhcmdzKX1gLFxuICAgICAgICAgICAgICAgICAgYHR5cGU6ICR7dGhpcy5oZWxwZXJzLmZpZWxkVHlwZUVudW0odHlwZSwgc3RydWN0TmFtZSl9YFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgJywgJ1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5wcmludCgnKSwnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdCb29sZWFuQ29uZGl0aW9uJzpcbiAgICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoYEdyYXBoUUxCb29sZWFuQ29uZGl0aW9uKGApO1xuICAgICAgICAgICAgdGhpcy5wcmludChcbiAgICAgICAgICAgICAgam9pbihcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICBgdmFyaWFibGVOYW1lOiBcIiR7c2VsZWN0aW9uLnZhcmlhYmxlTmFtZX1cImAsXG4gICAgICAgICAgICAgICAgICBgaW52ZXJ0ZWQ6ICR7c2VsZWN0aW9uLmludmVydGVkfWAsXG4gICAgICAgICAgICAgICAgICAnc2VsZWN0aW9uczogJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgJywgJ1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXRJbml0aWFsaXphdGlvbihzZWxlY3Rpb24uc2VsZWN0aW9uU2V0KTtcbiAgICAgICAgICAgIHRoaXMucHJpbnQoJyksJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdUeXBlQ29uZGl0aW9uJzoge1xuICAgICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgR3JhcGhRTFR5cGVDb25kaXRpb24oYCk7XG4gICAgICAgICAgICB0aGlzLnByaW50KFxuICAgICAgICAgICAgICBqb2luKFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgIGBwb3NzaWJsZVR5cGVzOiBbJHtqb2luKFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24uc2VsZWN0aW9uU2V0LnBvc3NpYmxlVHlwZXMubWFwKHR5cGUgPT4gYFwiJHt0eXBlLm5hbWV9XCJgKSxcbiAgICAgICAgICAgICAgICAgICAgJywgJ1xuICAgICAgICAgICAgICAgICAgKX1dYCxcbiAgICAgICAgICAgICAgICAgICdzZWxlY3Rpb25zOiAnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAnLCAnXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblNldEluaXRpYWxpemF0aW9uKHNlbGVjdGlvbi5zZWxlY3Rpb25TZXQpO1xuICAgICAgICAgICAgdGhpcy5wcmludCgnKSwnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdGcmFnbWVudFNwcmVhZCc6IHtcbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdE5hbWUgPSB0aGlzLmhlbHBlcnMuc3RydWN0TmFtZUZvckZyYWdtZW50TmFtZShzZWxlY3Rpb24uZnJhZ21lbnROYW1lKTtcbiAgICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoYEdyYXBoUUxGcmFnbWVudFNwcmVhZCgke3N0cnVjdE5hbWV9LnNlbGYpLGApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5wcmludE9uTmV3bGluZSgnXScpO1xuICB9XG5cbiAgdHlwZURlY2xhcmF0aW9uRm9yR3JhcGhRTFR5cGUodHlwZTogR3JhcGhRTFR5cGUpIHtcbiAgICBpZiAodHlwZSBpbnN0YW5jZW9mIEdyYXBoUUxFbnVtVHlwZSkge1xuICAgICAgdGhpcy5lbnVtZXJhdGlvbkRlY2xhcmF0aW9uKHR5cGUpO1xuICAgIH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIEdyYXBoUUxJbnB1dE9iamVjdFR5cGUpIHtcbiAgICAgIHRoaXMuc3RydWN0RGVjbGFyYXRpb25Gb3JJbnB1dE9iamVjdFR5cGUodHlwZSk7XG4gICAgfVxuICB9XG5cbiAgZW51bWVyYXRpb25EZWNsYXJhdGlvbih0eXBlOiBHcmFwaFFMRW51bVR5cGUpIHtcbiAgICBjb25zdCB7IG5hbWUsIGRlc2NyaXB0aW9uIH0gPSB0eXBlO1xuICAgIGNvbnN0IHZhbHVlcyA9IHR5cGUuZ2V0VmFsdWVzKCk7XG5cbiAgICB0aGlzLnByaW50TmV3bGluZUlmTmVlZGVkKCk7XG4gICAgdGhpcy5jb21tZW50KGRlc2NyaXB0aW9uIHx8IHVuZGVmaW5lZCk7XG4gICAgdGhpcy5wcmludE9uTmV3bGluZShcbiAgICAgIGBwdWJsaWMgZW51bSAke25hbWV9OiBSYXdSZXByZXNlbnRhYmxlLCBFcXVhdGFibGUsIEpTT05EZWNvZGFibGUsIEpTT05FbmNvZGFibGVgXG4gICAgKTtcbiAgICB0aGlzLndpdGhpbkJsb2NrKCgpID0+IHtcbiAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoJ3B1YmxpYyB0eXBlYWxpYXMgUmF3VmFsdWUgPSBTdHJpbmcnKTtcblxuICAgICAgdmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICB0aGlzLmNvbW1lbnQodmFsdWUuZGVzY3JpcHRpb24gfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5kZXByZWNhdGlvbkF0dHJpYnV0ZXModmFsdWUuaXNEZXByZWNhdGVkLCB2YWx1ZS5kZXByZWNhdGlvblJlYXNvbiB8fCB1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKFxuICAgICAgICAgIGBjYXNlICR7ZXNjYXBlSWRlbnRpZmllcklmTmVlZGVkKHRoaXMuaGVscGVycy5lbnVtQ2FzZU5hbWUodmFsdWUubmFtZSkpfWBcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb21tZW50KCdBdXRvIGdlbmVyYXRlZCBjb25zdGFudCBmb3IgdW5rbm93biBlbnVtIHZhbHVlcycpO1xuICAgICAgdGhpcy5wcmludE9uTmV3bGluZSgnY2FzZSB1bmtub3duKFJhd1ZhbHVlKScpO1xuXG4gICAgICB0aGlzLnByaW50TmV3bGluZUlmTmVlZGVkKCk7XG4gICAgICB0aGlzLnByaW50T25OZXdsaW5lKCdwdWJsaWMgaW5pdD8ocmF3VmFsdWU6IFJhd1ZhbHVlKScpO1xuICAgICAgdGhpcy53aXRoaW5CbG9jaygoKSA9PiB7XG4gICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoJ3N3aXRjaCByYXdWYWx1ZScpO1xuICAgICAgICB0aGlzLndpdGhpbkJsb2NrKCgpID0+IHtcbiAgICAgICAgICB2YWx1ZXMuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKFxuICAgICAgICAgICAgICBgY2FzZSBcIiR7dmFsdWUudmFsdWV9XCI6IHNlbGYgPSAke2VzY2FwZUlkZW50aWZpZXJJZk5lZWRlZChcbiAgICAgICAgICAgICAgICB0aGlzLmhlbHBlcnMuZW51bURvdENhc2VOYW1lKHZhbHVlLm5hbWUpXG4gICAgICAgICAgICAgICl9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKGBkZWZhdWx0OiBzZWxmID0gLnVua25vd24ocmF3VmFsdWUpYCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMucHJpbnROZXdsaW5lSWZOZWVkZWQoKTtcbiAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoJ3B1YmxpYyB2YXIgcmF3VmFsdWU6IFJhd1ZhbHVlJyk7XG4gICAgICB0aGlzLndpdGhpbkJsb2NrKCgpID0+IHtcbiAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZSgnc3dpdGNoIHNlbGYnKTtcbiAgICAgICAgdGhpcy53aXRoaW5CbG9jaygoKSA9PiB7XG4gICAgICAgICAgdmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShcbiAgICAgICAgICAgICAgYGNhc2UgJHtlc2NhcGVJZGVudGlmaWVySWZOZWVkZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5oZWxwZXJzLmVudW1Eb3RDYXNlTmFtZSh2YWx1ZS5uYW1lKVxuICAgICAgICAgICAgICApfTogcmV0dXJuIFwiJHt2YWx1ZS52YWx1ZX1cImBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgY2FzZSAudW5rbm93bihsZXQgdmFsdWUpOiByZXR1cm4gdmFsdWVgKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5wcmludE5ld2xpbmVJZk5lZWRlZCgpO1xuICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgcHVibGljIHN0YXRpYyBmdW5jID09IChsaHM6ICR7bmFtZX0sIHJoczogJHtuYW1lfSkgLT4gQm9vbGApO1xuICAgICAgdGhpcy53aXRoaW5CbG9jaygoKSA9PiB7XG4gICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoJ3N3aXRjaCAobGhzLCByaHMpJyk7XG4gICAgICAgIHRoaXMud2l0aGluQmxvY2soKCkgPT4ge1xuICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVudW1Eb3RDYXNlTmFtZSA9IGVzY2FwZUlkZW50aWZpZXJJZk5lZWRlZChcbiAgICAgICAgICAgICAgdGhpcy5oZWxwZXJzLmVudW1Eb3RDYXNlTmFtZSh2YWx1ZS5uYW1lKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHR1cGxlID0gYCgke2VudW1Eb3RDYXNlTmFtZX0sICR7ZW51bURvdENhc2VOYW1lfSlgO1xuICAgICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgY2FzZSAke3R1cGxlfTogcmV0dXJuIHRydWVgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKFxuICAgICAgICAgICAgYGNhc2UgKC51bmtub3duKGxldCBsaHNWYWx1ZSksIC51bmtub3duKGxldCByaHNWYWx1ZSkpOiByZXR1cm4gbGhzVmFsdWUgPT0gcmhzVmFsdWVgXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKGBkZWZhdWx0OiByZXR1cm4gZmFsc2VgKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0cnVjdERlY2xhcmF0aW9uRm9ySW5wdXRPYmplY3RUeXBlKHR5cGU6IEdyYXBoUUxJbnB1dE9iamVjdFR5cGUpIHtcbiAgICBjb25zdCB7IG5hbWU6IHN0cnVjdE5hbWUsIGRlc2NyaXB0aW9uIH0gPSB0eXBlO1xuICAgIGNvbnN0IGFkb3B0ZWRQcm90b2NvbHMgPSBbJ0dyYXBoUUxNYXBDb252ZXJ0aWJsZSddO1xuICAgIGNvbnN0IGZpZWxkcyA9IE9iamVjdC52YWx1ZXModHlwZS5nZXRGaWVsZHMoKSk7XG5cbiAgICBsZXQgcHJvcGVydGllcyA9IGZpZWxkcy5tYXAodGhpcy5oZWxwZXJzLnByb3BlcnR5RnJvbUlucHV0RmllbGQsIHRoaXMuaGVscGVycyk7XG5cbiAgICAvLyBGaWxlIGlucHV0IHNob3VsZCBoYXZlIGxvY2FsVXJpIGFuZCBtaW1lVHlwZSB3aGljaCBpcyB1c2VkIG9ubHkgaW4gY2xpZW50XG4gICAgaWYgKGlzUzNGaWVsZCh0eXBlKSkge1xuICAgICAgcHJvcGVydGllcyA9IFtcbiAgICAgICAgLi4ucHJvcGVydGllcyxcbiAgICAgICAge1xuICAgICAgICAgIHByb3BlcnR5TmFtZTogJ2xvY2FsVXJpJyxcbiAgICAgICAgICBuYW1lOiAnbG9jYWxVcmknLFxuICAgICAgICAgIHR5cGVOYW1lOiAnU3RyaW5nJyxcbiAgICAgICAgICBpc09wdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJycsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBwcm9wZXJ0eU5hbWU6ICdtaW1lVHlwZScsXG4gICAgICAgICAgbmFtZTogJ21pbWVUeXBlJyxcbiAgICAgICAgICB0eXBlTmFtZTogJ1N0cmluZycsXG4gICAgICAgICAgaXNPcHRpb25hbDogZmFsc2UsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICcnLFxuICAgICAgICB9LFxuICAgICAgXTtcbiAgICB9XG5cbiAgICB0aGlzLnN0cnVjdERlY2xhcmF0aW9uKFxuICAgICAgeyBzdHJ1Y3ROYW1lLCBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24gfHwgdW5kZWZpbmVkLCBhZG9wdGVkUHJvdG9jb2xzIH0sXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoYHB1YmxpYyB2YXIgZ3JhcGhRTE1hcDogR3JhcGhRTE1hcGApO1xuXG4gICAgICAgIHRoaXMucHJpbnROZXdsaW5lSWZOZWVkZWQoKTtcbiAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgcHVibGljIGluaXRgKTtcbiAgICAgICAgdGhpcy5wcmludCgnKCcpO1xuICAgICAgICB0aGlzLnByaW50KFxuICAgICAgICAgIGpvaW4oXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLm1hcCgoeyBwcm9wZXJ0eU5hbWUsIHR5cGVOYW1lLCBpc09wdGlvbmFsIH0pID0+XG4gICAgICAgICAgICAgIGpvaW4oW1xuICAgICAgICAgICAgICAgIGAke2VzY2FwZUlkZW50aWZpZXJJZk5lZWRlZChwcm9wZXJ0eU5hbWUpfTogJHt0eXBlTmFtZX1gLFxuICAgICAgICAgICAgICAgIGlzT3B0aW9uYWwgJiYgJyA9IG5pbCdcbiAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAnLCAnXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnByaW50KCcpJyk7XG5cbiAgICAgICAgdGhpcy53aXRoaW5CbG9jaygoKSA9PiB7XG4gICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShcbiAgICAgICAgICAgIHdyYXAoXG4gICAgICAgICAgICAgIGBncmFwaFFMTWFwID0gW2AsXG4gICAgICAgICAgICAgIGpvaW4oXG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5tYXAoXG4gICAgICAgICAgICAgICAgICAoeyBuYW1lLCBwcm9wZXJ0eU5hbWUgfSkgPT4gYFwiJHtuYW1lfVwiOiAke2VzY2FwZUlkZW50aWZpZXJJZk5lZWRlZChwcm9wZXJ0eU5hbWUpfWBcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICcsICdcbiAgICAgICAgICAgICAgKSB8fCAnOicsXG4gICAgICAgICAgICAgIGBdYFxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAoY29uc3QgeyBwcm9wZXJ0eU5hbWUsIHR5cGVOYW1lLCBkZXNjcmlwdGlvbiB9IG9mIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICB0aGlzLnByaW50TmV3bGluZUlmTmVlZGVkKCk7XG4gICAgICAgICAgdGhpcy5jb21tZW50KGRlc2NyaXB0aW9uIHx8IHVuZGVmaW5lZCk7XG4gICAgICAgICAgdGhpcy5wcmludE9uTmV3bGluZShgcHVibGljIHZhciAke2VzY2FwZUlkZW50aWZpZXJJZk5lZWRlZChwcm9wZXJ0eU5hbWUpfTogJHt0eXBlTmFtZX1gKTtcbiAgICAgICAgICB0aGlzLndpdGhpbkJsb2NrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoJ2dldCcpO1xuICAgICAgICAgICAgdGhpcy53aXRoaW5CbG9jaygoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucHJpbnRPbk5ld2xpbmUoYHJldHVybiBncmFwaFFMTWFwW1wiJHtwcm9wZXJ0eU5hbWV9XCJdIGFzISAke3R5cGVOYW1lfWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKCdzZXQnKTtcbiAgICAgICAgICAgIHRoaXMud2l0aGluQmxvY2soKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnByaW50T25OZXdsaW5lKGBncmFwaFFMTWFwLnVwZGF0ZVZhbHVlKG5ld1ZhbHVlLCBmb3JLZXk6IFwiJHtwcm9wZXJ0eU5hbWV9XCIpYCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=