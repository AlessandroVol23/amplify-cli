{"version":3,"sources":["ast.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * An if expression that takes a predicate and expression.\n */\nexport interface IfNode {\n    kind: 'If';\n    predicate: Expression;\n    expr: Expression;\n    inline: boolean;\n}\nexport function iff(predicate: Expression, expr: Expression, inline?: boolean): IfNode {\n    return {\n        kind: 'If',\n        predicate,\n        expr,\n        inline,\n    }\n}\n\n/**\n * An if else expression that takes a predicate, if expr, and else expr.\n */\nexport interface IfElseNode {\n    kind: 'IfElse';\n    predicate: Expression;\n    ifExpr: Expression;\n    elseExpr: Expression;\n    inline: boolean;\n}\nexport function ifElse(predicate: Expression, ifExpr: Expression, elseExpr: Expression, inline?: boolean): IfElseNode {\n    return {\n        kind: 'IfElse',\n        predicate,\n        ifExpr,\n        elseExpr,\n        inline\n    }\n}\n\n/**\n * An and expression that takes two or more expressions and joins them with &&.\n */\nexport interface AndNode {\n    kind: 'And';\n    expressions: Expression[];\n}\nexport function and(expressions: Expression[]): AndNode {\n    return {\n        kind: 'And',\n        expressions\n    }\n}\n\n/**\n * An or expression that takes two or more expressions and join them with ||\n */\nexport interface OrNode {\n    kind: 'Or';\n    expressions: Expression[];\n}\nexport function or(expressions: Expression[]): OrNode {\n    return {\n        kind: 'Or',\n        expressions\n    }\n}\n\n/**Node\n * WrapsNodeNode an expression in (...) for order of operations.\n */\nexport interface ParensNode {\n    kind: 'Parens';\n    expr: Expression;\n}\nexport function parens(expr: Expression): ParensNode {\n    return {\n        kind: 'Parens',\n        expr\n    }\n}\n\n/**\n * Compares two expressions for equality.\n */\nexport interface EqualsNode {\n    kind: 'Equals';\n    leftExpr: Expression;\n    rightExpr: Expression;\n}\nexport function equals(leftExpr: Expression, rightExpr: Expression): EqualsNode {\n    return {\n        kind: 'Equals',\n        leftExpr,\n        rightExpr\n    }\n}\n\n/**\n * Compares two expressions for unequality.\n */\nexport interface NotEqualsNode {\n    kind: 'NotEquals';\n    leftExpr: Expression;\n    rightExpr: Expression;\n}\nexport function notEquals(leftExpr: Expression, rightExpr: Expression): NotEqualsNode {\n    return {\n        kind: 'NotEquals',\n        leftExpr,\n        rightExpr\n    }\n}\n\n/**\n * Compares two expressions for unequality.\n */\nexport interface NotNode {\n    kind: 'Not';\n    expr: Expression;\n}\nexport function not(expr: Expression): NotNode {\n    return {\n        kind: 'Not',\n        expr,\n    }\n}\n\n/**\n * Iterates through a collection.\n */\nexport interface ForEachNode {\n    kind: 'ForEach';\n    key: ReferenceNode;\n    collection: ReferenceNode;\n    expressions: Expression[];\n}\nexport function forEach(key: ReferenceNode, collection: ReferenceNode, expressions: Expression[]): ForEachNode {\n    return {\n        kind: 'ForEach',\n        key,\n        collection,\n        expressions\n    }\n}\n\n/**\n * A literal string that should be printed in the template with quotes.\n */\nexport interface StringNode {\n    kind: 'String';\n    value: string;\n}\nexport function str(value: string): StringNode {\n    return {\n        kind: 'String',\n        value\n    }\n}\n\n/**\n * A literal string that should be printed in the template without quotes.\n */\nexport interface RawNode {\n    kind: 'Raw';\n    value: string;\n}\nexport function raw(value: string): RawNode {\n    return {\n        kind: 'Raw',\n        value\n    }\n}\n\n/**\n * Wraps an expression in quotes.\n */\nexport interface QuotesNode {\n    kind: 'Quotes';\n    expr: Expression;\n}\nexport function quotes(expr: Expression): QuotesNode {\n    return {\n        kind: 'Quotes',\n        expr\n    }\n}\n\n/**\n * A literal float that should be printed in the template.\n */\nexport interface FloatNode {\n    kind: 'Float';\n    value: number;\n}\nexport function float(value: number): FloatNode {\n    return {\n        kind: 'Float',\n        value\n    }\n}\n\n/**\n * A literal int that should be printed in the template.\n */\nexport interface IntNode {\n    kind: 'Int';\n    value: number;\n}\nexport function int(value: number): IntNode {\n    return {\n        kind: 'Int',\n        value\n    }\n}\n\n/**\n * A literal boolean that should be printed in the template.\n */\nexport interface BooleanNode {\n    kind: 'Boolean';\n    value: boolean;\n}\nexport function bool(value: boolean): BooleanNode {\n    return {\n        kind: 'Boolean',\n        value\n    }\n}\n\n/**\n * A literal null to be printed in the template.\n */\nexport interface NullNode {\n    kind: 'Null';\n}\nexport function nul(): NullNode {\n    return {\n        kind: 'Null'\n    }\n}\n\n/**\n * A place holder is a string wrapped in ${}.\n * VTL replaces placeholders with values from the context.\n */\nexport interface ReferenceNode {\n    kind: 'Reference';\n    value: string;\n}\nexport function ref(value: string): ReferenceNode {\n    return {\n        kind: 'Reference',\n        value\n    }\n}\n\n/**\n * A place holder is a string wrapped in $!{}.\n * VTL replaces placeholders with values from the context.\n */\nexport interface QuietReferenceNode {\n    kind: 'QuietReference';\n    value: string;\n}\nexport function qref(value: string): QuietReferenceNode {\n    return {\n        kind: 'QuietReference',\n        value\n    }\n}\n\n/**\n * A JSON object serialized directly to the VTL.\n */\nexport interface ObjectNode {\n    kind: 'Object';\n    attributes: [string, Expression][];\n}\n// TODO: This can also take a plain object. What is easier in practice?\nexport function obj(\n    o: { [key: string]: Expression }\n): ObjectNode {\n    const attributes = Object.keys(o).map(\n        (key: string) => ([key, o[key]] as [string, Expression])\n    )\n    return {\n        kind: 'Object',\n        attributes\n    }\n}\n\n/**\n * A JSON object serialized directly to the VTL.\n */\nexport interface ListNode {\n    kind: 'List';\n    expressions: Expression[];\n}\nexport function list(expressions: Expression[]): ListNode {\n    return {\n        kind: 'List',\n        expressions\n    }\n}\n\n/**\n * Set a value in the mapping template.\n */\nexport interface SetNode {\n    kind: 'Set',\n    key: ReferenceNode,\n    value: Expression\n}\nexport function set(key: ReferenceNode, value: Expression): SetNode {\n    return {\n        kind: 'Set',\n        key,\n        value\n    }\n}\n\nexport interface CommentNode {\n    kind: 'Comment',\n    text: string\n}\nexport function comment(text: string): CommentNode {\n    return {\n        kind: 'Comment',\n        text\n    }\n}\n\nexport interface CompoundExpressionNode {\n    kind: 'CompoundExpression',\n    expressions: Expression[]\n}\nexport function compoundExpression(expressions: Expression[]): CompoundExpressionNode {\n    return {\n        kind: 'CompoundExpression',\n        expressions\n    }\n}\n\nexport type ToJsonNode = {\n    kind: 'Util.ToJson',\n    expr: Expression\n}\nexport function toJson(expr: Expression): ToJsonNode {\n    return {\n        kind: 'Util.ToJson',\n        expr\n    }\n}\n\nexport type NewLineNode = {\n    kind: 'NewLine'\n}\nexport function newline(): NewLineNode {\n    return {\n        kind: 'NewLine',\n    }\n}\n\nexport function block(name: string, exprs: Expression[]): CompoundExpressionNode {\n    return compoundExpression([\n        comment(`[Start] ${name}`),\n        ...exprs,\n        comment(`[End] ${name}`)\n    ])\n}\n\n/**\n * A flow expression is one that dictates program flow e.g. if, ifelse, for, while, etc.\n */\nexport type Expression =\n    IfNode\n    | IfElseNode\n    | AndNode\n    | OrNode\n    | ParensNode\n    | EqualsNode\n    | NotEqualsNode\n    | ForEachNode\n    | StringNode\n    | RawNode\n    | QuotesNode\n    | FloatNode\n    | IntNode\n    | BooleanNode\n    | NullNode\n    | ReferenceNode\n    | QuietReferenceNode\n    | ObjectNode\n    | ListNode\n    | SetNode\n    | CommentNode\n    | CompoundExpressionNode\n    | ToJsonNode\n    | NotNode\n    | NewLineNode;\n"],"sourceRoot":""}