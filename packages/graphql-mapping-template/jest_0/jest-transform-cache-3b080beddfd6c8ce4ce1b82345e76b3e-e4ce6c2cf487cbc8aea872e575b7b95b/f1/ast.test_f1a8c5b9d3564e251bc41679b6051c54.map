{"version":3,"sources":["ast.test.ts"],"names":[],"mappings":";;AAAA,IAAA,QAAA,QAAA,QAAA,CAAA;AACA,IAAA,aAAA,QAAA,aAAA,CAAA;AACA,IAAA,UAAA,QAAA,UAAA,CAAA;AAEA,KAAK,yCAAL,EAAgD,YAAA;AAC5C,QAAM,WAAW,WAAA,uBAAA,CAAwB,OAAxB,CAAgC;AAC7C,aAAK,MAAA,GAAA,CAAI;AACL,kBAAM,MAAA,GAAA,CAAI,MAAJ,CADD;AAEL,gBAAI,MAAA,GAAA,CAAI,eAAJ,CAFC,EAAJ,CADwC;;AAK7C,yBAAiB,MAAA,GAAA,CAAI;AACjB,mBAAO,MAAA,GAAA,CAAI,uCAAJ,CADU,EAAJ,CAL4B,EAAhC,CAAjB;;;AASA,QAAM,WAAW,QAAA,KAAA,CAAM,QAAN,CAAjB;AACA,WAAO,QAAP,EAAiB,WAAjB;AACH,CAZD;AAcA,KAAK,sCAAL,EAA6C,YAAA;AACzC,QAAM,WAAW,WAAA,uBAAA,CAAwB,KAAxB,CAA8B;AAC3C,eAAO,MAAA,GAAA,CAAI;AACP,0BAAe,MAAA,GAAA,CAAI,uBAAJ,CADR;AAEP,+BAAoB,MAAA,GAAA,CAAI;AACpB,6BAAc,MAAA,GAAA,CAAI,YAAJ,CADM,EAAJ,CAFb;;AAKP,gCAAqB,MAAA,GAAA,CAAI;AACrB,6BAAc,MAAA,GAAA,CAAI;AACd,yBAAM,MAAA,GAAA,CAAI,MAAJ,CADQ,EAAJ,CADO,EAAJ,CALd,EAAJ,CADoC;;;;AAY3C,0BAAkB,MAAA,IAAA,CAAK,IAAL,CAZyB;AAa3C,gBAAQ,MAAA,MAAA,CACJ,MAAA,GAAA,CAAI,qBAAJ,CADI,EAEJ,MAAA,GAAA,CAAI,6DAAJ,CAFI,EAGJ,MAAA,GAAA,EAHI,CAbmC;AAkB3C,eAAO,MAAA,GAAA,CAAI,OAAJ,CAlBoC;AAmB3C,mBAAW,MAAA,MAAA,CACP,MAAA,GAAA,CAAI,wBAAJ,CADO,EAEP,MAAA,GAAA,CAAI,yBAAJ,CAFO,EAGP,MAAA,GAAA,EAHO,CAnBgC,EAA9B,CAAjB;;AAyBA,QAAM,WAAW,QAAA,KAAA,CAAM,QAAN,CAAjB;AACA,WAAO,QAAP,EAAiB,WAAjB;AACH,CA5BD;AA8BA,KAAK,gEAAL,EAAuE,YAAA;AACnE,QAAM,YAAY,MAAA,GAAA,CAAI,MAAA,GAAA,CAAI,QAAJ,CAAJ,EAAmB,MAAA,GAAA,CAAI,2DAAJ,CAAnB,CAAlB;AACA,QAAM,YAAY,MAAA,OAAA,CAAQ,MAAA,GAAA,CAAI,OAAJ,CAAR,EAAsB,MAAA,GAAA,CAAI,iCAAJ,CAAtB,EAA8D;AAC5E,UAAA,IAAA,CAAK,uCAAL,CAD4E,CAA9D,CAAlB;;AAGA,QAAM,kBAAkB,MAAA,GAAA,CAAI,sBAAJ,CAAxB;AACA,QAAM,WAAW,QAAA,KAAA,CAAM,MAAA,kBAAA,CAAmB,CAAC,SAAD,EAAY,SAAZ,EAAuB,eAAvB,CAAnB,CAAN,CAAjB;AACA,WAAO,QAAP,EAAiB,WAAjB;AACH,CARD","sourcesContent":["import { ref, obj, str, forEach, qref, set, compoundExpression, ifElse, nul, bool } from '../ast'\nimport { DynamoDBMappingTemplate } from '../dynamodb'\nimport { print } from '../print'\n\ntest('create a put item resolver with the ast', () => {\n    const resolver = DynamoDBMappingTemplate.putItem({\n        key: obj({\n            type: str('Post'),\n            id: ref('util.autoId()')\n        }),\n        attributeValues: obj({\n            value: ref(`util.dynamodb.toMapJson(\\${ctx.input})`)\n        })\n    })\n    const template = print(resolver)\n    expect(template).toBeDefined()\n});\n\ntest('create a query resolver with the ast', () => {\n    const resolver = DynamoDBMappingTemplate.query({\n        query: obj({\n            'expression' : str('#typename = :typename'),\n            'expressionNames' : obj({\n                '#typename' : str('__typename')\n            }),\n            'expressionValues' : obj({\n                ':typename' : obj({\n                    'S' : str('test')\n                })\n            })\n        }),\n        scanIndexForward: bool(true),\n        filter: ifElse(\n            ref('context.args.filter'),\n            ref('util.transform.toDynamoDBFilterExpression($ctx.args.filter)'),\n            nul()\n        ),\n        limit: ref('limit'),\n        nextToken: ifElse(\n            ref('context.args.nextToken'),\n            str('$context.args.nextToken'),\n            nul()\n        )\n    })\n    const template = print(resolver)\n    expect(template).toBeDefined()\n});\n\ntest('create a response mapping template that merges a nested object', () => {\n    const setResult = set(ref('result'), ref('util.map.copyAndRemoveAllKeys($context.result, [\"value\"])'))\n    const mergeLoop = forEach(ref('entry'), ref('context.result.value.entrySet()'), [\n        qref('$result.put($entry.key, $entry.value)')\n    ]);\n    const returnStatement = ref('util.toJson($result)')\n    const template = print(compoundExpression([setResult, mergeLoop, returnStatement]))\n    expect(template).toBeDefined()\n})"],"sourceRoot":""}