f7b36e0eb6a8516a18fa4bb85fc89649













jest.mock('../../src/codegen-config');
jest.mock('../../src/walkthrough/questions/updateCode');
jest.mock('../../src/walkthrough/questions/updateDocs');const loadConfig = require('../../src/codegen-config');const askShouldUpdateCode = require('../../src/walkthrough/questions/updateCode');const askShouldUpdateStatements = require('../../src/walkthrough/questions/updateDocs');const prePushUpdateCallback = require('../../src/callbacks/prePushUpdateCallback');const MOCK_CONTEXT = { exeInfo: {}, print: { info: jest.fn() } };

const MOCK_PROJECT_NAME = 'MOCK_PROJECT';
const MOCK_SELECTED_PROJECT = { projectName: MOCK_PROJECT_NAME, foo: 'bar' };
const MOCK_PROJECTS = [MOCK_SELECTED_PROJECT];

const LOAD_CONFIG_METHODS = {
  getProjects: jest.fn(),
  addProject: jest.fn(),
  save: jest.fn() };


describe('callback - prepushUpdate AppSync API', () => {
  beforeEach(() => {
    jest.resetAllMocks();
    loadConfig.mockReturnValue(LOAD_CONFIG_METHODS);
    LOAD_CONFIG_METHODS.getProjects.mockReturnValue(MOCK_PROJECTS);
    askShouldUpdateCode.mockReturnValue(true);
    askShouldUpdateStatements.mockReturnValue(true);
  });

  it('should ask prompt user to update statements and types', async () => {
    const result = await prePushUpdateCallback(MOCK_CONTEXT, MOCK_PROJECT_NAME);
    expect(result.gqlConfig).toEqual(MOCK_SELECTED_PROJECT);
    expect(result.shouldGenerateDocs).toEqual(true);
  });

  it('should not return anything if the user declines updating code', async () => {
    askShouldUpdateCode.mockReturnValue(false);
    const result = await prePushUpdateCallback(MOCK_CONTEXT, MOCK_PROJECT_NAME);
    expect(result).toBeUndefined();
  });

  it('should set shouldGenerateDocs when user declines statement generation', async () => {
    askShouldUpdateStatements.mockReturnValue(false);
    const result = await prePushUpdateCallback(MOCK_CONTEXT, MOCK_PROJECT_NAME);
    expect(result.shouldGenerateDocs).toEqual(false);
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInByZVB1c2hVcGRhdGVDYWxsYmFjay50ZXN0LmpzIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwibG9hZENvbmZpZyIsInJlcXVpcmUiLCJhc2tTaG91bGRVcGRhdGVDb2RlIiwiYXNrU2hvdWxkVXBkYXRlU3RhdGVtZW50cyIsInByZVB1c2hVcGRhdGVDYWxsYmFjayIsIk1PQ0tfQ09OVEVYVCIsImV4ZUluZm8iLCJwcmludCIsImluZm8iLCJmbiIsIk1PQ0tfUFJPSkVDVF9OQU1FIiwiTU9DS19TRUxFQ1RFRF9QUk9KRUNUIiwicHJvamVjdE5hbWUiLCJmb28iLCJNT0NLX1BST0pFQ1RTIiwiTE9BRF9DT05GSUdfTUVUSE9EUyIsImdldFByb2plY3RzIiwiYWRkUHJvamVjdCIsInNhdmUiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJyZXNldEFsbE1vY2tzIiwibW9ja1JldHVyblZhbHVlIiwiaXQiLCJyZXN1bHQiLCJleHBlY3QiLCJncWxDb25maWciLCJ0b0VxdWFsIiwic2hvdWxkR2VuZXJhdGVEb2NzIiwidG9CZVVuZGVmaW5lZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQWFBQSxLQUFLQyxJQUFMLENBQVUsMEJBQVY7QUFDQUQsS0FBS0MsSUFBTCxDQUFVLDRDQUFWO0FBQ0FELEtBQUtDLElBQUwsQ0FBVSw0Q0FBVixFQWZBLE1BQU1DLGFBQWFDLFFBQVEsMEJBQVIsQ0FBbkIsQ0FDQSxNQUFNQyxzQkFBc0JELFFBQVEsNENBQVIsQ0FBNUIsQ0FDQSxNQUFNRSw0QkFBNEJGLFFBQVEsNENBQVIsQ0FBbEMsQ0FFQSxNQUFNRyx3QkFBd0JILFFBQVEsMkNBQVIsQ0FBOUIsQ0FFQSxNQUFNSSxlQUFlLEVBQ25CQyxTQUFTLEVBRFUsRUFFbkJDLE9BQU8sRUFDTEMsTUFBTVYsS0FBS1csRUFBTCxFQURELEVBRlksRUFBckI7O0FBV0EsTUFBTUMsb0JBQW9CLGNBQTFCO0FBQ0EsTUFBTUMsd0JBQXdCLEVBQUVDLGFBQWFGLGlCQUFmLEVBQWtDRyxLQUFLLEtBQXZDLEVBQTlCO0FBQ0EsTUFBTUMsZ0JBQWdCLENBQUNILHFCQUFELENBQXRCOztBQUVBLE1BQU1JLHNCQUFzQjtBQUMxQkMsZUFBYWxCLEtBQUtXLEVBQUwsRUFEYTtBQUUxQlEsY0FBWW5CLEtBQUtXLEVBQUwsRUFGYztBQUcxQlMsUUFBTXBCLEtBQUtXLEVBQUwsRUFIb0IsRUFBNUI7OztBQU1BVSxTQUFTLHNDQUFULEVBQWlELE1BQU07QUFDckRDLGFBQVcsTUFBTTtBQUNmdEIsU0FBS3VCLGFBQUw7QUFDQXJCLGVBQVdzQixlQUFYLENBQTJCUCxtQkFBM0I7QUFDQUEsd0JBQW9CQyxXQUFwQixDQUFnQ00sZUFBaEMsQ0FBZ0RSLGFBQWhEO0FBQ0FaLHdCQUFvQm9CLGVBQXBCLENBQW9DLElBQXBDO0FBQ0FuQiw4QkFBMEJtQixlQUExQixDQUEwQyxJQUExQztBQUNELEdBTkQ7O0FBUUFDLEtBQUcsdURBQUgsRUFBNEQsWUFBWTtBQUN0RSxVQUFNQyxTQUFTLE1BQU1wQixzQkFBc0JDLFlBQXRCLEVBQW9DSyxpQkFBcEMsQ0FBckI7QUFDQWUsV0FBT0QsT0FBT0UsU0FBZCxFQUF5QkMsT0FBekIsQ0FBaUNoQixxQkFBakM7QUFDQWMsV0FBT0QsT0FBT0ksa0JBQWQsRUFBa0NELE9BQWxDLENBQTBDLElBQTFDO0FBQ0QsR0FKRDs7QUFNQUosS0FBRywrREFBSCxFQUFvRSxZQUFZO0FBQzlFckIsd0JBQW9Cb0IsZUFBcEIsQ0FBb0MsS0FBcEM7QUFDQSxVQUFNRSxTQUFTLE1BQU1wQixzQkFBc0JDLFlBQXRCLEVBQW9DSyxpQkFBcEMsQ0FBckI7QUFDQWUsV0FBT0QsTUFBUCxFQUFlSyxhQUFmO0FBQ0QsR0FKRDs7QUFNQU4sS0FBRyx1RUFBSCxFQUE0RSxZQUFZO0FBQ3RGcEIsOEJBQTBCbUIsZUFBMUIsQ0FBMEMsS0FBMUM7QUFDQSxVQUFNRSxTQUFTLE1BQU1wQixzQkFBc0JDLFlBQXRCLEVBQW9DSyxpQkFBcEMsQ0FBckI7QUFDQWUsV0FBT0QsT0FBT0ksa0JBQWQsRUFBa0NELE9BQWxDLENBQTBDLEtBQTFDO0FBQ0QsR0FKRDtBQUtELENBMUJEIiwiZmlsZSI6InByZVB1c2hVcGRhdGVDYWxsYmFjay50ZXN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgbG9hZENvbmZpZyA9IHJlcXVpcmUoJy4uLy4uL3NyYy9jb2RlZ2VuLWNvbmZpZycpO1xuY29uc3QgYXNrU2hvdWxkVXBkYXRlQ29kZSA9IHJlcXVpcmUoJy4uLy4uL3NyYy93YWxrdGhyb3VnaC9xdWVzdGlvbnMvdXBkYXRlQ29kZScpO1xuY29uc3QgYXNrU2hvdWxkVXBkYXRlU3RhdGVtZW50cyA9IHJlcXVpcmUoJy4uLy4uL3NyYy93YWxrdGhyb3VnaC9xdWVzdGlvbnMvdXBkYXRlRG9jcycpO1xuXG5jb25zdCBwcmVQdXNoVXBkYXRlQ2FsbGJhY2sgPSByZXF1aXJlKCcuLi8uLi9zcmMvY2FsbGJhY2tzL3ByZVB1c2hVcGRhdGVDYWxsYmFjaycpO1xuXG5jb25zdCBNT0NLX0NPTlRFWFQgPSB7XG4gIGV4ZUluZm86IHt9LFxuICBwcmludDoge1xuICAgIGluZm86IGplc3QuZm4oKSxcbiAgfSxcbn07XG5cbmplc3QubW9jaygnLi4vLi4vc3JjL2NvZGVnZW4tY29uZmlnJyk7XG5qZXN0Lm1vY2soJy4uLy4uL3NyYy93YWxrdGhyb3VnaC9xdWVzdGlvbnMvdXBkYXRlQ29kZScpO1xuamVzdC5tb2NrKCcuLi8uLi9zcmMvd2Fsa3Rocm91Z2gvcXVlc3Rpb25zL3VwZGF0ZURvY3MnKTtcblxuY29uc3QgTU9DS19QUk9KRUNUX05BTUUgPSAnTU9DS19QUk9KRUNUJztcbmNvbnN0IE1PQ0tfU0VMRUNURURfUFJPSkVDVCA9IHsgcHJvamVjdE5hbWU6IE1PQ0tfUFJPSkVDVF9OQU1FLCBmb286ICdiYXInIH07XG5jb25zdCBNT0NLX1BST0pFQ1RTID0gW01PQ0tfU0VMRUNURURfUFJPSkVDVF07XG5cbmNvbnN0IExPQURfQ09ORklHX01FVEhPRFMgPSB7XG4gIGdldFByb2plY3RzOiBqZXN0LmZuKCksXG4gIGFkZFByb2plY3Q6IGplc3QuZm4oKSxcbiAgc2F2ZTogamVzdC5mbigpLFxufTtcblxuZGVzY3JpYmUoJ2NhbGxiYWNrIC0gcHJlcHVzaFVwZGF0ZSBBcHBTeW5jIEFQSScsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5yZXNldEFsbE1vY2tzKCk7XG4gICAgbG9hZENvbmZpZy5tb2NrUmV0dXJuVmFsdWUoTE9BRF9DT05GSUdfTUVUSE9EUyk7XG4gICAgTE9BRF9DT05GSUdfTUVUSE9EUy5nZXRQcm9qZWN0cy5tb2NrUmV0dXJuVmFsdWUoTU9DS19QUk9KRUNUUyk7XG4gICAgYXNrU2hvdWxkVXBkYXRlQ29kZS5tb2NrUmV0dXJuVmFsdWUodHJ1ZSk7XG4gICAgYXNrU2hvdWxkVXBkYXRlU3RhdGVtZW50cy5tb2NrUmV0dXJuVmFsdWUodHJ1ZSk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgYXNrIHByb21wdCB1c2VyIHRvIHVwZGF0ZSBzdGF0ZW1lbnRzIGFuZCB0eXBlcycsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcmVQdXNoVXBkYXRlQ2FsbGJhY2soTU9DS19DT05URVhULCBNT0NLX1BST0pFQ1RfTkFNRSk7XG4gICAgZXhwZWN0KHJlc3VsdC5ncWxDb25maWcpLnRvRXF1YWwoTU9DS19TRUxFQ1RFRF9QUk9KRUNUKTtcbiAgICBleHBlY3QocmVzdWx0LnNob3VsZEdlbmVyYXRlRG9jcykudG9FcXVhbCh0cnVlKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBub3QgcmV0dXJuIGFueXRoaW5nIGlmIHRoZSB1c2VyIGRlY2xpbmVzIHVwZGF0aW5nIGNvZGUnLCBhc3luYyAoKSA9PiB7XG4gICAgYXNrU2hvdWxkVXBkYXRlQ29kZS5tb2NrUmV0dXJuVmFsdWUoZmFsc2UpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByZVB1c2hVcGRhdGVDYWxsYmFjayhNT0NLX0NPTlRFWFQsIE1PQ0tfUFJPSkVDVF9OQU1FKTtcbiAgICBleHBlY3QocmVzdWx0KS50b0JlVW5kZWZpbmVkKCk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgc2V0IHNob3VsZEdlbmVyYXRlRG9jcyB3aGVuIHVzZXIgZGVjbGluZXMgc3RhdGVtZW50IGdlbmVyYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgYXNrU2hvdWxkVXBkYXRlU3RhdGVtZW50cy5tb2NrUmV0dXJuVmFsdWUoZmFsc2UpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByZVB1c2hVcGRhdGVDYWxsYmFjayhNT0NLX0NPTlRFWFQsIE1PQ0tfUFJPSkVDVF9OQU1FKTtcbiAgICBleHBlY3QocmVzdWx0LnNob3VsZEdlbmVyYXRlRG9jcykudG9FcXVhbChmYWxzZSk7XG4gIH0pO1xufSk7XG4iXX0=